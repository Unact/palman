// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'database.dart';

// ignore_for_file: type=lint
class $UsersTable extends Users with TableInfo<$UsersTable, User> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UsersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _usernameMeta =
      const VerificationMeta('username');
  @override
  late final GeneratedColumn<String> username = GeneratedColumn<String>(
      'username', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _salesmanNameMeta =
      const VerificationMeta('salesmanName');
  @override
  late final GeneratedColumn<String> salesmanName = GeneratedColumn<String>(
      'salesman_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _preOrderModeMeta =
      const VerificationMeta('preOrderMode');
  @override
  late final GeneratedColumn<bool> preOrderMode = GeneratedColumn<bool>(
      'pre_order_mode', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("pre_order_mode" IN (0, 1))'));
  static const VerificationMeta _closedMeta = const VerificationMeta('closed');
  @override
  late final GeneratedColumn<bool> closed = GeneratedColumn<bool>(
      'closed', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("closed" IN (0, 1))'));
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
      'email', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _versionMeta =
      const VerificationMeta('version');
  @override
  late final GeneratedColumn<String> version = GeneratedColumn<String>(
      'version', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [id, username, salesmanName, preOrderMode, closed, email, version];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'users';
  @override
  VerificationContext validateIntegrity(Insertable<User> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('username')) {
      context.handle(_usernameMeta,
          username.isAcceptableOrUnknown(data['username']!, _usernameMeta));
    } else if (isInserting) {
      context.missing(_usernameMeta);
    }
    if (data.containsKey('salesman_name')) {
      context.handle(
          _salesmanNameMeta,
          salesmanName.isAcceptableOrUnknown(
              data['salesman_name']!, _salesmanNameMeta));
    } else if (isInserting) {
      context.missing(_salesmanNameMeta);
    }
    if (data.containsKey('pre_order_mode')) {
      context.handle(
          _preOrderModeMeta,
          preOrderMode.isAcceptableOrUnknown(
              data['pre_order_mode']!, _preOrderModeMeta));
    } else if (isInserting) {
      context.missing(_preOrderModeMeta);
    }
    if (data.containsKey('closed')) {
      context.handle(_closedMeta,
          closed.isAcceptableOrUnknown(data['closed']!, _closedMeta));
    } else if (isInserting) {
      context.missing(_closedMeta);
    }
    if (data.containsKey('email')) {
      context.handle(
          _emailMeta, email.isAcceptableOrUnknown(data['email']!, _emailMeta));
    } else if (isInserting) {
      context.missing(_emailMeta);
    }
    if (data.containsKey('version')) {
      context.handle(_versionMeta,
          version.isAcceptableOrUnknown(data['version']!, _versionMeta));
    } else if (isInserting) {
      context.missing(_versionMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  User map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return User(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      username: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}username'])!,
      salesmanName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}salesman_name'])!,
      preOrderMode: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}pre_order_mode'])!,
      closed: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}closed'])!,
      email: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}email'])!,
      version: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}version'])!,
    );
  }

  @override
  $UsersTable createAlias(String alias) {
    return $UsersTable(attachedDatabase, alias);
  }
}

class User extends DataClass implements Insertable<User> {
  final int id;
  final String username;
  final String salesmanName;
  final bool preOrderMode;
  final bool closed;
  final String email;
  final String version;
  const User(
      {required this.id,
      required this.username,
      required this.salesmanName,
      required this.preOrderMode,
      required this.closed,
      required this.email,
      required this.version});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['username'] = Variable<String>(username);
    map['salesman_name'] = Variable<String>(salesmanName);
    map['pre_order_mode'] = Variable<bool>(preOrderMode);
    map['closed'] = Variable<bool>(closed);
    map['email'] = Variable<String>(email);
    map['version'] = Variable<String>(version);
    return map;
  }

  UsersCompanion toCompanion(bool nullToAbsent) {
    return UsersCompanion(
      id: Value(id),
      username: Value(username),
      salesmanName: Value(salesmanName),
      preOrderMode: Value(preOrderMode),
      closed: Value(closed),
      email: Value(email),
      version: Value(version),
    );
  }

  factory User.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return User(
      id: serializer.fromJson<int>(json['id']),
      username: serializer.fromJson<String>(json['username']),
      salesmanName: serializer.fromJson<String>(json['salesmanName']),
      preOrderMode: serializer.fromJson<bool>(json['preOrderMode']),
      closed: serializer.fromJson<bool>(json['closed']),
      email: serializer.fromJson<String>(json['email']),
      version: serializer.fromJson<String>(json['version']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'username': serializer.toJson<String>(username),
      'salesmanName': serializer.toJson<String>(salesmanName),
      'preOrderMode': serializer.toJson<bool>(preOrderMode),
      'closed': serializer.toJson<bool>(closed),
      'email': serializer.toJson<String>(email),
      'version': serializer.toJson<String>(version),
    };
  }

  User copyWith(
          {int? id,
          String? username,
          String? salesmanName,
          bool? preOrderMode,
          bool? closed,
          String? email,
          String? version}) =>
      User(
        id: id ?? this.id,
        username: username ?? this.username,
        salesmanName: salesmanName ?? this.salesmanName,
        preOrderMode: preOrderMode ?? this.preOrderMode,
        closed: closed ?? this.closed,
        email: email ?? this.email,
        version: version ?? this.version,
      );
  User copyWithCompanion(UsersCompanion data) {
    return User(
      id: data.id.present ? data.id.value : this.id,
      username: data.username.present ? data.username.value : this.username,
      salesmanName: data.salesmanName.present
          ? data.salesmanName.value
          : this.salesmanName,
      preOrderMode: data.preOrderMode.present
          ? data.preOrderMode.value
          : this.preOrderMode,
      closed: data.closed.present ? data.closed.value : this.closed,
      email: data.email.present ? data.email.value : this.email,
      version: data.version.present ? data.version.value : this.version,
    );
  }

  @override
  String toString() {
    return (StringBuffer('User(')
          ..write('id: $id, ')
          ..write('username: $username, ')
          ..write('salesmanName: $salesmanName, ')
          ..write('preOrderMode: $preOrderMode, ')
          ..write('closed: $closed, ')
          ..write('email: $email, ')
          ..write('version: $version')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id, username, salesmanName, preOrderMode, closed, email, version);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is User &&
          other.id == this.id &&
          other.username == this.username &&
          other.salesmanName == this.salesmanName &&
          other.preOrderMode == this.preOrderMode &&
          other.closed == this.closed &&
          other.email == this.email &&
          other.version == this.version);
}

class UsersCompanion extends UpdateCompanion<User> {
  final Value<int> id;
  final Value<String> username;
  final Value<String> salesmanName;
  final Value<bool> preOrderMode;
  final Value<bool> closed;
  final Value<String> email;
  final Value<String> version;
  const UsersCompanion({
    this.id = const Value.absent(),
    this.username = const Value.absent(),
    this.salesmanName = const Value.absent(),
    this.preOrderMode = const Value.absent(),
    this.closed = const Value.absent(),
    this.email = const Value.absent(),
    this.version = const Value.absent(),
  });
  UsersCompanion.insert({
    this.id = const Value.absent(),
    required String username,
    required String salesmanName,
    required bool preOrderMode,
    required bool closed,
    required String email,
    required String version,
  })  : username = Value(username),
        salesmanName = Value(salesmanName),
        preOrderMode = Value(preOrderMode),
        closed = Value(closed),
        email = Value(email),
        version = Value(version);
  static Insertable<User> custom({
    Expression<int>? id,
    Expression<String>? username,
    Expression<String>? salesmanName,
    Expression<bool>? preOrderMode,
    Expression<bool>? closed,
    Expression<String>? email,
    Expression<String>? version,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (username != null) 'username': username,
      if (salesmanName != null) 'salesman_name': salesmanName,
      if (preOrderMode != null) 'pre_order_mode': preOrderMode,
      if (closed != null) 'closed': closed,
      if (email != null) 'email': email,
      if (version != null) 'version': version,
    });
  }

  UsersCompanion copyWith(
      {Value<int>? id,
      Value<String>? username,
      Value<String>? salesmanName,
      Value<bool>? preOrderMode,
      Value<bool>? closed,
      Value<String>? email,
      Value<String>? version}) {
    return UsersCompanion(
      id: id ?? this.id,
      username: username ?? this.username,
      salesmanName: salesmanName ?? this.salesmanName,
      preOrderMode: preOrderMode ?? this.preOrderMode,
      closed: closed ?? this.closed,
      email: email ?? this.email,
      version: version ?? this.version,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (username.present) {
      map['username'] = Variable<String>(username.value);
    }
    if (salesmanName.present) {
      map['salesman_name'] = Variable<String>(salesmanName.value);
    }
    if (preOrderMode.present) {
      map['pre_order_mode'] = Variable<bool>(preOrderMode.value);
    }
    if (closed.present) {
      map['closed'] = Variable<bool>(closed.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (version.present) {
      map['version'] = Variable<String>(version.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UsersCompanion(')
          ..write('id: $id, ')
          ..write('username: $username, ')
          ..write('salesmanName: $salesmanName, ')
          ..write('preOrderMode: $preOrderMode, ')
          ..write('closed: $closed, ')
          ..write('email: $email, ')
          ..write('version: $version')
          ..write(')'))
        .toString();
  }
}

class $PrefsTable extends Prefs with TableInfo<$PrefsTable, Pref> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PrefsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _showLocalImageMeta =
      const VerificationMeta('showLocalImage');
  @override
  late final GeneratedColumn<bool> showLocalImage = GeneratedColumn<bool>(
      'show_local_image', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("show_local_image" IN (0, 1))'));
  static const VerificationMeta _showWithPriceMeta =
      const VerificationMeta('showWithPrice');
  @override
  late final GeneratedColumn<bool> showWithPrice = GeneratedColumn<bool>(
      'show_with_price', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("show_with_price" IN (0, 1))'));
  static const VerificationMeta _lastLoadTimeMeta =
      const VerificationMeta('lastLoadTime');
  @override
  late final GeneratedColumn<DateTime> lastLoadTime = GeneratedColumn<DateTime>(
      'last_load_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [showLocalImage, showWithPrice, lastLoadTime];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'prefs';
  @override
  VerificationContext validateIntegrity(Insertable<Pref> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('show_local_image')) {
      context.handle(
          _showLocalImageMeta,
          showLocalImage.isAcceptableOrUnknown(
              data['show_local_image']!, _showLocalImageMeta));
    } else if (isInserting) {
      context.missing(_showLocalImageMeta);
    }
    if (data.containsKey('show_with_price')) {
      context.handle(
          _showWithPriceMeta,
          showWithPrice.isAcceptableOrUnknown(
              data['show_with_price']!, _showWithPriceMeta));
    } else if (isInserting) {
      context.missing(_showWithPriceMeta);
    }
    if (data.containsKey('last_load_time')) {
      context.handle(
          _lastLoadTimeMeta,
          lastLoadTime.isAcceptableOrUnknown(
              data['last_load_time']!, _lastLoadTimeMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => const {};
  @override
  Pref map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Pref(
      showLocalImage: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}show_local_image'])!,
      showWithPrice: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}show_with_price'])!,
      lastLoadTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_load_time']),
    );
  }

  @override
  $PrefsTable createAlias(String alias) {
    return $PrefsTable(attachedDatabase, alias);
  }
}

class Pref extends DataClass implements Insertable<Pref> {
  final bool showLocalImage;
  final bool showWithPrice;
  final DateTime? lastLoadTime;
  const Pref(
      {required this.showLocalImage,
      required this.showWithPrice,
      this.lastLoadTime});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['show_local_image'] = Variable<bool>(showLocalImage);
    map['show_with_price'] = Variable<bool>(showWithPrice);
    if (!nullToAbsent || lastLoadTime != null) {
      map['last_load_time'] = Variable<DateTime>(lastLoadTime);
    }
    return map;
  }

  PrefsCompanion toCompanion(bool nullToAbsent) {
    return PrefsCompanion(
      showLocalImage: Value(showLocalImage),
      showWithPrice: Value(showWithPrice),
      lastLoadTime: lastLoadTime == null && nullToAbsent
          ? const Value.absent()
          : Value(lastLoadTime),
    );
  }

  factory Pref.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Pref(
      showLocalImage: serializer.fromJson<bool>(json['showLocalImage']),
      showWithPrice: serializer.fromJson<bool>(json['showWithPrice']),
      lastLoadTime: serializer.fromJson<DateTime?>(json['lastLoadTime']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'showLocalImage': serializer.toJson<bool>(showLocalImage),
      'showWithPrice': serializer.toJson<bool>(showWithPrice),
      'lastLoadTime': serializer.toJson<DateTime?>(lastLoadTime),
    };
  }

  Pref copyWith(
          {bool? showLocalImage,
          bool? showWithPrice,
          Value<DateTime?> lastLoadTime = const Value.absent()}) =>
      Pref(
        showLocalImage: showLocalImage ?? this.showLocalImage,
        showWithPrice: showWithPrice ?? this.showWithPrice,
        lastLoadTime:
            lastLoadTime.present ? lastLoadTime.value : this.lastLoadTime,
      );
  Pref copyWithCompanion(PrefsCompanion data) {
    return Pref(
      showLocalImage: data.showLocalImage.present
          ? data.showLocalImage.value
          : this.showLocalImage,
      showWithPrice: data.showWithPrice.present
          ? data.showWithPrice.value
          : this.showWithPrice,
      lastLoadTime: data.lastLoadTime.present
          ? data.lastLoadTime.value
          : this.lastLoadTime,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Pref(')
          ..write('showLocalImage: $showLocalImage, ')
          ..write('showWithPrice: $showWithPrice, ')
          ..write('lastLoadTime: $lastLoadTime')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(showLocalImage, showWithPrice, lastLoadTime);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Pref &&
          other.showLocalImage == this.showLocalImage &&
          other.showWithPrice == this.showWithPrice &&
          other.lastLoadTime == this.lastLoadTime);
}

class PrefsCompanion extends UpdateCompanion<Pref> {
  final Value<bool> showLocalImage;
  final Value<bool> showWithPrice;
  final Value<DateTime?> lastLoadTime;
  final Value<int> rowid;
  const PrefsCompanion({
    this.showLocalImage = const Value.absent(),
    this.showWithPrice = const Value.absent(),
    this.lastLoadTime = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PrefsCompanion.insert({
    required bool showLocalImage,
    required bool showWithPrice,
    this.lastLoadTime = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : showLocalImage = Value(showLocalImage),
        showWithPrice = Value(showWithPrice);
  static Insertable<Pref> custom({
    Expression<bool>? showLocalImage,
    Expression<bool>? showWithPrice,
    Expression<DateTime>? lastLoadTime,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (showLocalImage != null) 'show_local_image': showLocalImage,
      if (showWithPrice != null) 'show_with_price': showWithPrice,
      if (lastLoadTime != null) 'last_load_time': lastLoadTime,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PrefsCompanion copyWith(
      {Value<bool>? showLocalImage,
      Value<bool>? showWithPrice,
      Value<DateTime?>? lastLoadTime,
      Value<int>? rowid}) {
    return PrefsCompanion(
      showLocalImage: showLocalImage ?? this.showLocalImage,
      showWithPrice: showWithPrice ?? this.showWithPrice,
      lastLoadTime: lastLoadTime ?? this.lastLoadTime,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (showLocalImage.present) {
      map['show_local_image'] = Variable<bool>(showLocalImage.value);
    }
    if (showWithPrice.present) {
      map['show_with_price'] = Variable<bool>(showWithPrice.value);
    }
    if (lastLoadTime.present) {
      map['last_load_time'] = Variable<DateTime>(lastLoadTime.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PrefsCompanion(')
          ..write('showLocalImage: $showLocalImage, ')
          ..write('showWithPrice: $showWithPrice, ')
          ..write('lastLoadTime: $lastLoadTime, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BuyersTable extends Buyers with TableInfo<$BuyersTable, Buyer> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BuyersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _loadtoMeta = const VerificationMeta('loadto');
  @override
  late final GeneratedColumn<String> loadto = GeneratedColumn<String>(
      'loadto', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _partnerIdMeta =
      const VerificationMeta('partnerId');
  @override
  late final GeneratedColumn<int> partnerId = GeneratedColumn<int>(
      'partner_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _siteIdMeta = const VerificationMeta('siteId');
  @override
  late final GeneratedColumn<int> siteId = GeneratedColumn<int>(
      'site_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _pointIdMeta =
      const VerificationMeta('pointId');
  @override
  late final GeneratedColumn<int> pointId = GeneratedColumn<int>(
      'point_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _weekdaysMeta =
      const VerificationMeta('weekdays');
  @override
  late final GeneratedColumnWithTypeConverter<EqualList<bool>, String>
      weekdays = GeneratedColumn<String>('weekdays', aliasedName, false,
              type: DriftSqlType.string, requiredDuringInsert: true)
          .withConverter<EqualList<bool>>($BuyersTable.$converterweekdays);
  @override
  List<GeneratedColumn> get $columns =>
      [id, name, loadto, partnerId, siteId, pointId, weekdays];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'buyers';
  @override
  VerificationContext validateIntegrity(Insertable<Buyer> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('loadto')) {
      context.handle(_loadtoMeta,
          loadto.isAcceptableOrUnknown(data['loadto']!, _loadtoMeta));
    } else if (isInserting) {
      context.missing(_loadtoMeta);
    }
    if (data.containsKey('partner_id')) {
      context.handle(_partnerIdMeta,
          partnerId.isAcceptableOrUnknown(data['partner_id']!, _partnerIdMeta));
    } else if (isInserting) {
      context.missing(_partnerIdMeta);
    }
    if (data.containsKey('site_id')) {
      context.handle(_siteIdMeta,
          siteId.isAcceptableOrUnknown(data['site_id']!, _siteIdMeta));
    } else if (isInserting) {
      context.missing(_siteIdMeta);
    }
    if (data.containsKey('point_id')) {
      context.handle(_pointIdMeta,
          pointId.isAcceptableOrUnknown(data['point_id']!, _pointIdMeta));
    }
    context.handle(_weekdaysMeta, const VerificationResult.success());
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Buyer map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Buyer(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      loadto: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}loadto'])!,
      partnerId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}partner_id'])!,
      siteId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}site_id'])!,
      pointId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}point_id']),
      weekdays: $BuyersTable.$converterweekdays.fromSql(attachedDatabase
          .typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}weekdays'])!),
    );
  }

  @override
  $BuyersTable createAlias(String alias) {
    return $BuyersTable(attachedDatabase, alias);
  }

  static TypeConverter<EqualList<bool>, String> $converterweekdays =
      const JsonListConverter<bool>();
}

class Buyer extends DataClass implements Insertable<Buyer> {
  final int id;
  final String name;
  final String loadto;
  final int partnerId;
  final int siteId;
  final int? pointId;
  final EqualList<bool> weekdays;
  const Buyer(
      {required this.id,
      required this.name,
      required this.loadto,
      required this.partnerId,
      required this.siteId,
      this.pointId,
      required this.weekdays});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    map['loadto'] = Variable<String>(loadto);
    map['partner_id'] = Variable<int>(partnerId);
    map['site_id'] = Variable<int>(siteId);
    if (!nullToAbsent || pointId != null) {
      map['point_id'] = Variable<int>(pointId);
    }
    {
      map['weekdays'] =
          Variable<String>($BuyersTable.$converterweekdays.toSql(weekdays));
    }
    return map;
  }

  BuyersCompanion toCompanion(bool nullToAbsent) {
    return BuyersCompanion(
      id: Value(id),
      name: Value(name),
      loadto: Value(loadto),
      partnerId: Value(partnerId),
      siteId: Value(siteId),
      pointId: pointId == null && nullToAbsent
          ? const Value.absent()
          : Value(pointId),
      weekdays: Value(weekdays),
    );
  }

  factory Buyer.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Buyer(
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      loadto: serializer.fromJson<String>(json['loadto']),
      partnerId: serializer.fromJson<int>(json['partnerId']),
      siteId: serializer.fromJson<int>(json['siteId']),
      pointId: serializer.fromJson<int?>(json['pointId']),
      weekdays: serializer.fromJson<EqualList<bool>>(json['weekdays']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
      'loadto': serializer.toJson<String>(loadto),
      'partnerId': serializer.toJson<int>(partnerId),
      'siteId': serializer.toJson<int>(siteId),
      'pointId': serializer.toJson<int?>(pointId),
      'weekdays': serializer.toJson<EqualList<bool>>(weekdays),
    };
  }

  Buyer copyWith(
          {int? id,
          String? name,
          String? loadto,
          int? partnerId,
          int? siteId,
          Value<int?> pointId = const Value.absent(),
          EqualList<bool>? weekdays}) =>
      Buyer(
        id: id ?? this.id,
        name: name ?? this.name,
        loadto: loadto ?? this.loadto,
        partnerId: partnerId ?? this.partnerId,
        siteId: siteId ?? this.siteId,
        pointId: pointId.present ? pointId.value : this.pointId,
        weekdays: weekdays ?? this.weekdays,
      );
  Buyer copyWithCompanion(BuyersCompanion data) {
    return Buyer(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      loadto: data.loadto.present ? data.loadto.value : this.loadto,
      partnerId: data.partnerId.present ? data.partnerId.value : this.partnerId,
      siteId: data.siteId.present ? data.siteId.value : this.siteId,
      pointId: data.pointId.present ? data.pointId.value : this.pointId,
      weekdays: data.weekdays.present ? data.weekdays.value : this.weekdays,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Buyer(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('loadto: $loadto, ')
          ..write('partnerId: $partnerId, ')
          ..write('siteId: $siteId, ')
          ..write('pointId: $pointId, ')
          ..write('weekdays: $weekdays')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, name, loadto, partnerId, siteId, pointId, weekdays);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Buyer &&
          other.id == this.id &&
          other.name == this.name &&
          other.loadto == this.loadto &&
          other.partnerId == this.partnerId &&
          other.siteId == this.siteId &&
          other.pointId == this.pointId &&
          other.weekdays == this.weekdays);
}

class BuyersCompanion extends UpdateCompanion<Buyer> {
  final Value<int> id;
  final Value<String> name;
  final Value<String> loadto;
  final Value<int> partnerId;
  final Value<int> siteId;
  final Value<int?> pointId;
  final Value<EqualList<bool>> weekdays;
  const BuyersCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.loadto = const Value.absent(),
    this.partnerId = const Value.absent(),
    this.siteId = const Value.absent(),
    this.pointId = const Value.absent(),
    this.weekdays = const Value.absent(),
  });
  BuyersCompanion.insert({
    this.id = const Value.absent(),
    required String name,
    required String loadto,
    required int partnerId,
    required int siteId,
    this.pointId = const Value.absent(),
    required EqualList<bool> weekdays,
  })  : name = Value(name),
        loadto = Value(loadto),
        partnerId = Value(partnerId),
        siteId = Value(siteId),
        weekdays = Value(weekdays);
  static Insertable<Buyer> custom({
    Expression<int>? id,
    Expression<String>? name,
    Expression<String>? loadto,
    Expression<int>? partnerId,
    Expression<int>? siteId,
    Expression<int>? pointId,
    Expression<String>? weekdays,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (loadto != null) 'loadto': loadto,
      if (partnerId != null) 'partner_id': partnerId,
      if (siteId != null) 'site_id': siteId,
      if (pointId != null) 'point_id': pointId,
      if (weekdays != null) 'weekdays': weekdays,
    });
  }

  BuyersCompanion copyWith(
      {Value<int>? id,
      Value<String>? name,
      Value<String>? loadto,
      Value<int>? partnerId,
      Value<int>? siteId,
      Value<int?>? pointId,
      Value<EqualList<bool>>? weekdays}) {
    return BuyersCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      loadto: loadto ?? this.loadto,
      partnerId: partnerId ?? this.partnerId,
      siteId: siteId ?? this.siteId,
      pointId: pointId ?? this.pointId,
      weekdays: weekdays ?? this.weekdays,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (loadto.present) {
      map['loadto'] = Variable<String>(loadto.value);
    }
    if (partnerId.present) {
      map['partner_id'] = Variable<int>(partnerId.value);
    }
    if (siteId.present) {
      map['site_id'] = Variable<int>(siteId.value);
    }
    if (pointId.present) {
      map['point_id'] = Variable<int>(pointId.value);
    }
    if (weekdays.present) {
      map['weekdays'] = Variable<String>(
          $BuyersTable.$converterweekdays.toSql(weekdays.value));
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BuyersCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('loadto: $loadto, ')
          ..write('partnerId: $partnerId, ')
          ..write('siteId: $siteId, ')
          ..write('pointId: $pointId, ')
          ..write('weekdays: $weekdays')
          ..write(')'))
        .toString();
  }
}

class $PartnersTable extends Partners with TableInfo<$PartnersTable, Partner> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PartnersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [id, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'partners';
  @override
  VerificationContext validateIntegrity(Insertable<Partner> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Partner map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Partner(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $PartnersTable createAlias(String alias) {
    return $PartnersTable(attachedDatabase, alias);
  }
}

class Partner extends DataClass implements Insertable<Partner> {
  final int id;
  final String name;
  const Partner({required this.id, required this.name});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    return map;
  }

  PartnersCompanion toCompanion(bool nullToAbsent) {
    return PartnersCompanion(
      id: Value(id),
      name: Value(name),
    );
  }

  factory Partner.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Partner(
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
    };
  }

  Partner copyWith({int? id, String? name}) => Partner(
        id: id ?? this.id,
        name: name ?? this.name,
      );
  Partner copyWithCompanion(PartnersCompanion data) {
    return Partner(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Partner(')
          ..write('id: $id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Partner && other.id == this.id && other.name == this.name);
}

class PartnersCompanion extends UpdateCompanion<Partner> {
  final Value<int> id;
  final Value<String> name;
  const PartnersCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
  });
  PartnersCompanion.insert({
    this.id = const Value.absent(),
    required String name,
  }) : name = Value(name);
  static Insertable<Partner> custom({
    Expression<int>? id,
    Expression<String>? name,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
    });
  }

  PartnersCompanion copyWith({Value<int>? id, Value<String>? name}) {
    return PartnersCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PartnersCompanion(')
          ..write('id: $id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class $LocationsTable extends Locations
    with TableInfo<$LocationsTable, Location> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LocationsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _latitudeMeta =
      const VerificationMeta('latitude');
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
      'latitude', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _longitudeMeta =
      const VerificationMeta('longitude');
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
      'longitude', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _accuracyMeta =
      const VerificationMeta('accuracy');
  @override
  late final GeneratedColumn<double> accuracy = GeneratedColumn<double>(
      'accuracy', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _altitudeMeta =
      const VerificationMeta('altitude');
  @override
  late final GeneratedColumn<double> altitude = GeneratedColumn<double>(
      'altitude', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _headingMeta =
      const VerificationMeta('heading');
  @override
  late final GeneratedColumn<double> heading = GeneratedColumn<double>(
      'heading', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _speedMeta = const VerificationMeta('speed');
  @override
  late final GeneratedColumn<double> speed = GeneratedColumn<double>(
      'speed', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _timestampMeta =
      const VerificationMeta('timestamp');
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
      'timestamp', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _batteryLevelMeta =
      const VerificationMeta('batteryLevel');
  @override
  late final GeneratedColumn<int> batteryLevel = GeneratedColumn<int>(
      'battery_level', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _batteryStateMeta =
      const VerificationMeta('batteryState');
  @override
  late final GeneratedColumn<String> batteryState = GeneratedColumn<String>(
      'battery_state', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        latitude,
        longitude,
        accuracy,
        altitude,
        heading,
        speed,
        timestamp,
        batteryLevel,
        batteryState
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'locations';
  @override
  VerificationContext validateIntegrity(Insertable<Location> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('latitude')) {
      context.handle(_latitudeMeta,
          latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta));
    } else if (isInserting) {
      context.missing(_latitudeMeta);
    }
    if (data.containsKey('longitude')) {
      context.handle(_longitudeMeta,
          longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta));
    } else if (isInserting) {
      context.missing(_longitudeMeta);
    }
    if (data.containsKey('accuracy')) {
      context.handle(_accuracyMeta,
          accuracy.isAcceptableOrUnknown(data['accuracy']!, _accuracyMeta));
    } else if (isInserting) {
      context.missing(_accuracyMeta);
    }
    if (data.containsKey('altitude')) {
      context.handle(_altitudeMeta,
          altitude.isAcceptableOrUnknown(data['altitude']!, _altitudeMeta));
    } else if (isInserting) {
      context.missing(_altitudeMeta);
    }
    if (data.containsKey('heading')) {
      context.handle(_headingMeta,
          heading.isAcceptableOrUnknown(data['heading']!, _headingMeta));
    } else if (isInserting) {
      context.missing(_headingMeta);
    }
    if (data.containsKey('speed')) {
      context.handle(
          _speedMeta, speed.isAcceptableOrUnknown(data['speed']!, _speedMeta));
    } else if (isInserting) {
      context.missing(_speedMeta);
    }
    if (data.containsKey('timestamp')) {
      context.handle(_timestampMeta,
          timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta));
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    if (data.containsKey('battery_level')) {
      context.handle(
          _batteryLevelMeta,
          batteryLevel.isAcceptableOrUnknown(
              data['battery_level']!, _batteryLevelMeta));
    } else if (isInserting) {
      context.missing(_batteryLevelMeta);
    }
    if (data.containsKey('battery_state')) {
      context.handle(
          _batteryStateMeta,
          batteryState.isAcceptableOrUnknown(
              data['battery_state']!, _batteryStateMeta));
    } else if (isInserting) {
      context.missing(_batteryStateMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Location map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Location(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      latitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}latitude'])!,
      longitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}longitude'])!,
      accuracy: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}accuracy'])!,
      altitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}altitude'])!,
      heading: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}heading'])!,
      speed: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}speed'])!,
      timestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}timestamp'])!,
      batteryLevel: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}battery_level'])!,
      batteryState: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}battery_state'])!,
    );
  }

  @override
  $LocationsTable createAlias(String alias) {
    return $LocationsTable(attachedDatabase, alias);
  }
}

class Location extends DataClass implements Insertable<Location> {
  final int id;
  final double latitude;
  final double longitude;
  final double accuracy;
  final double altitude;
  final double heading;
  final double speed;
  final DateTime timestamp;
  final int batteryLevel;
  final String batteryState;
  const Location(
      {required this.id,
      required this.latitude,
      required this.longitude,
      required this.accuracy,
      required this.altitude,
      required this.heading,
      required this.speed,
      required this.timestamp,
      required this.batteryLevel,
      required this.batteryState});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['latitude'] = Variable<double>(latitude);
    map['longitude'] = Variable<double>(longitude);
    map['accuracy'] = Variable<double>(accuracy);
    map['altitude'] = Variable<double>(altitude);
    map['heading'] = Variable<double>(heading);
    map['speed'] = Variable<double>(speed);
    map['timestamp'] = Variable<DateTime>(timestamp);
    map['battery_level'] = Variable<int>(batteryLevel);
    map['battery_state'] = Variable<String>(batteryState);
    return map;
  }

  LocationsCompanion toCompanion(bool nullToAbsent) {
    return LocationsCompanion(
      id: Value(id),
      latitude: Value(latitude),
      longitude: Value(longitude),
      accuracy: Value(accuracy),
      altitude: Value(altitude),
      heading: Value(heading),
      speed: Value(speed),
      timestamp: Value(timestamp),
      batteryLevel: Value(batteryLevel),
      batteryState: Value(batteryState),
    );
  }

  factory Location.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Location(
      id: serializer.fromJson<int>(json['id']),
      latitude: serializer.fromJson<double>(json['latitude']),
      longitude: serializer.fromJson<double>(json['longitude']),
      accuracy: serializer.fromJson<double>(json['accuracy']),
      altitude: serializer.fromJson<double>(json['altitude']),
      heading: serializer.fromJson<double>(json['heading']),
      speed: serializer.fromJson<double>(json['speed']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      batteryLevel: serializer.fromJson<int>(json['batteryLevel']),
      batteryState: serializer.fromJson<String>(json['batteryState']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'latitude': serializer.toJson<double>(latitude),
      'longitude': serializer.toJson<double>(longitude),
      'accuracy': serializer.toJson<double>(accuracy),
      'altitude': serializer.toJson<double>(altitude),
      'heading': serializer.toJson<double>(heading),
      'speed': serializer.toJson<double>(speed),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'batteryLevel': serializer.toJson<int>(batteryLevel),
      'batteryState': serializer.toJson<String>(batteryState),
    };
  }

  Location copyWith(
          {int? id,
          double? latitude,
          double? longitude,
          double? accuracy,
          double? altitude,
          double? heading,
          double? speed,
          DateTime? timestamp,
          int? batteryLevel,
          String? batteryState}) =>
      Location(
        id: id ?? this.id,
        latitude: latitude ?? this.latitude,
        longitude: longitude ?? this.longitude,
        accuracy: accuracy ?? this.accuracy,
        altitude: altitude ?? this.altitude,
        heading: heading ?? this.heading,
        speed: speed ?? this.speed,
        timestamp: timestamp ?? this.timestamp,
        batteryLevel: batteryLevel ?? this.batteryLevel,
        batteryState: batteryState ?? this.batteryState,
      );
  Location copyWithCompanion(LocationsCompanion data) {
    return Location(
      id: data.id.present ? data.id.value : this.id,
      latitude: data.latitude.present ? data.latitude.value : this.latitude,
      longitude: data.longitude.present ? data.longitude.value : this.longitude,
      accuracy: data.accuracy.present ? data.accuracy.value : this.accuracy,
      altitude: data.altitude.present ? data.altitude.value : this.altitude,
      heading: data.heading.present ? data.heading.value : this.heading,
      speed: data.speed.present ? data.speed.value : this.speed,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
      batteryLevel: data.batteryLevel.present
          ? data.batteryLevel.value
          : this.batteryLevel,
      batteryState: data.batteryState.present
          ? data.batteryState.value
          : this.batteryState,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Location(')
          ..write('id: $id, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('accuracy: $accuracy, ')
          ..write('altitude: $altitude, ')
          ..write('heading: $heading, ')
          ..write('speed: $speed, ')
          ..write('timestamp: $timestamp, ')
          ..write('batteryLevel: $batteryLevel, ')
          ..write('batteryState: $batteryState')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, latitude, longitude, accuracy, altitude,
      heading, speed, timestamp, batteryLevel, batteryState);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Location &&
          other.id == this.id &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.accuracy == this.accuracy &&
          other.altitude == this.altitude &&
          other.heading == this.heading &&
          other.speed == this.speed &&
          other.timestamp == this.timestamp &&
          other.batteryLevel == this.batteryLevel &&
          other.batteryState == this.batteryState);
}

class LocationsCompanion extends UpdateCompanion<Location> {
  final Value<int> id;
  final Value<double> latitude;
  final Value<double> longitude;
  final Value<double> accuracy;
  final Value<double> altitude;
  final Value<double> heading;
  final Value<double> speed;
  final Value<DateTime> timestamp;
  final Value<int> batteryLevel;
  final Value<String> batteryState;
  const LocationsCompanion({
    this.id = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.accuracy = const Value.absent(),
    this.altitude = const Value.absent(),
    this.heading = const Value.absent(),
    this.speed = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.batteryLevel = const Value.absent(),
    this.batteryState = const Value.absent(),
  });
  LocationsCompanion.insert({
    this.id = const Value.absent(),
    required double latitude,
    required double longitude,
    required double accuracy,
    required double altitude,
    required double heading,
    required double speed,
    required DateTime timestamp,
    required int batteryLevel,
    required String batteryState,
  })  : latitude = Value(latitude),
        longitude = Value(longitude),
        accuracy = Value(accuracy),
        altitude = Value(altitude),
        heading = Value(heading),
        speed = Value(speed),
        timestamp = Value(timestamp),
        batteryLevel = Value(batteryLevel),
        batteryState = Value(batteryState);
  static Insertable<Location> custom({
    Expression<int>? id,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<double>? accuracy,
    Expression<double>? altitude,
    Expression<double>? heading,
    Expression<double>? speed,
    Expression<DateTime>? timestamp,
    Expression<int>? batteryLevel,
    Expression<String>? batteryState,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (accuracy != null) 'accuracy': accuracy,
      if (altitude != null) 'altitude': altitude,
      if (heading != null) 'heading': heading,
      if (speed != null) 'speed': speed,
      if (timestamp != null) 'timestamp': timestamp,
      if (batteryLevel != null) 'battery_level': batteryLevel,
      if (batteryState != null) 'battery_state': batteryState,
    });
  }

  LocationsCompanion copyWith(
      {Value<int>? id,
      Value<double>? latitude,
      Value<double>? longitude,
      Value<double>? accuracy,
      Value<double>? altitude,
      Value<double>? heading,
      Value<double>? speed,
      Value<DateTime>? timestamp,
      Value<int>? batteryLevel,
      Value<String>? batteryState}) {
    return LocationsCompanion(
      id: id ?? this.id,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      accuracy: accuracy ?? this.accuracy,
      altitude: altitude ?? this.altitude,
      heading: heading ?? this.heading,
      speed: speed ?? this.speed,
      timestamp: timestamp ?? this.timestamp,
      batteryLevel: batteryLevel ?? this.batteryLevel,
      batteryState: batteryState ?? this.batteryState,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (accuracy.present) {
      map['accuracy'] = Variable<double>(accuracy.value);
    }
    if (altitude.present) {
      map['altitude'] = Variable<double>(altitude.value);
    }
    if (heading.present) {
      map['heading'] = Variable<double>(heading.value);
    }
    if (speed.present) {
      map['speed'] = Variable<double>(speed.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (batteryLevel.present) {
      map['battery_level'] = Variable<int>(batteryLevel.value);
    }
    if (batteryState.present) {
      map['battery_state'] = Variable<String>(batteryState.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LocationsCompanion(')
          ..write('id: $id, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('accuracy: $accuracy, ')
          ..write('altitude: $altitude, ')
          ..write('heading: $heading, ')
          ..write('speed: $speed, ')
          ..write('timestamp: $timestamp, ')
          ..write('batteryLevel: $batteryLevel, ')
          ..write('batteryState: $batteryState')
          ..write(')'))
        .toString();
  }
}

class $PointFormatsTable extends PointFormats
    with TableInfo<$PointFormatsTable, PointFormat> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PointFormatsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [id, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'point_formats';
  @override
  VerificationContext validateIntegrity(Insertable<PointFormat> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  PointFormat map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PointFormat(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $PointFormatsTable createAlias(String alias) {
    return $PointFormatsTable(attachedDatabase, alias);
  }
}

class PointFormat extends DataClass implements Insertable<PointFormat> {
  final int id;
  final String name;
  const PointFormat({required this.id, required this.name});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    return map;
  }

  PointFormatsCompanion toCompanion(bool nullToAbsent) {
    return PointFormatsCompanion(
      id: Value(id),
      name: Value(name),
    );
  }

  factory PointFormat.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PointFormat(
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
    };
  }

  PointFormat copyWith({int? id, String? name}) => PointFormat(
        id: id ?? this.id,
        name: name ?? this.name,
      );
  PointFormat copyWithCompanion(PointFormatsCompanion data) {
    return PointFormat(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PointFormat(')
          ..write('id: $id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PointFormat && other.id == this.id && other.name == this.name);
}

class PointFormatsCompanion extends UpdateCompanion<PointFormat> {
  final Value<int> id;
  final Value<String> name;
  const PointFormatsCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
  });
  PointFormatsCompanion.insert({
    this.id = const Value.absent(),
    required String name,
  }) : name = Value(name);
  static Insertable<PointFormat> custom({
    Expression<int>? id,
    Expression<String>? name,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
    });
  }

  PointFormatsCompanion copyWith({Value<int>? id, Value<String>? name}) {
    return PointFormatsCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PointFormatsCompanion(')
          ..write('id: $id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class $PointsTable extends Points with TableInfo<$PointsTable, Point> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PointsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _guidMeta = const VerificationMeta('guid');
  @override
  late final GeneratedColumn<String> guid = GeneratedColumn<String>(
      'guid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _timestampMeta =
      const VerificationMeta('timestamp');
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
      'timestamp', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _currentTimestampMeta =
      const VerificationMeta('currentTimestamp');
  @override
  late final GeneratedColumn<DateTime> currentTimestamp =
      GeneratedColumn<DateTime>('current_timestamp', aliasedName, false,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          defaultValue: currentDateAndTime);
  static const VerificationMeta _lastSyncTimeMeta =
      const VerificationMeta('lastSyncTime');
  @override
  late final GeneratedColumn<DateTime> lastSyncTime = GeneratedColumn<DateTime>(
      'last_sync_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _needSyncMeta =
      const VerificationMeta('needSync');
  @override
  late final GeneratedColumn<bool> needSync = GeneratedColumn<bool>(
      'need_sync', aliasedName, false,
      generatedAs: GeneratedAs(
          (isNew & BooleanExpressionOperators(isDeleted).not()) |
              (BooleanExpressionOperators(isNew).not() &
                  ComparableExpr(lastSyncTime).isSmallerThan(timestamp)),
          true),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("need_sync" IN (0, 1))'));
  static const VerificationMeta _isNewMeta = const VerificationMeta('isNew');
  @override
  late final GeneratedColumn<bool> isNew = GeneratedColumn<bool>(
      'is_new', aliasedName, false,
      generatedAs: GeneratedAs(lastSyncTime.isNull(), false),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_new" IN (0, 1))'));
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _addressMeta =
      const VerificationMeta('address');
  @override
  late final GeneratedColumn<String> address = GeneratedColumn<String>(
      'address', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _buyerNameMeta =
      const VerificationMeta('buyerName');
  @override
  late final GeneratedColumn<String> buyerName = GeneratedColumn<String>(
      'buyer_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _reasonMeta = const VerificationMeta('reason');
  @override
  late final GeneratedColumn<String> reason = GeneratedColumn<String>(
      'reason', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _latitudeMeta =
      const VerificationMeta('latitude');
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
      'latitude', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _longitudeMeta =
      const VerificationMeta('longitude');
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
      'longitude', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _pointFormatMeta =
      const VerificationMeta('pointFormat');
  @override
  late final GeneratedColumn<int> pointFormat = GeneratedColumn<int>(
      'point_format', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _numberOfCdesksMeta =
      const VerificationMeta('numberOfCdesks');
  @override
  late final GeneratedColumn<int> numberOfCdesks = GeneratedColumn<int>(
      'number_of_cdesks', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _emailOnlineCheckMeta =
      const VerificationMeta('emailOnlineCheck');
  @override
  late final GeneratedColumn<String> emailOnlineCheck = GeneratedColumn<String>(
      'email_online_check', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
      'email', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _phoneOnlineCheckMeta =
      const VerificationMeta('phoneOnlineCheck');
  @override
  late final GeneratedColumn<String> phoneOnlineCheck = GeneratedColumn<String>(
      'phone_online_check', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _innMeta = const VerificationMeta('inn');
  @override
  late final GeneratedColumn<String> inn = GeneratedColumn<String>(
      'inn', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _jurMeta = const VerificationMeta('jur');
  @override
  late final GeneratedColumn<String> jur = GeneratedColumn<String>(
      'jur', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _plongMeta = const VerificationMeta('plong');
  @override
  late final GeneratedColumn<int> plong = GeneratedColumn<int>(
      'plong', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _maxdebtMeta =
      const VerificationMeta('maxdebt');
  @override
  late final GeneratedColumn<int> maxdebt = GeneratedColumn<int>(
      'maxdebt', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _nds10Meta = const VerificationMeta('nds10');
  @override
  late final GeneratedColumn<int> nds10 = GeneratedColumn<int>(
      'nds10', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _nds20Meta = const VerificationMeta('nds20');
  @override
  late final GeneratedColumn<int> nds20 = GeneratedColumn<int>(
      'nds20', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _formsLinkMeta =
      const VerificationMeta('formsLink');
  @override
  late final GeneratedColumn<String> formsLink = GeneratedColumn<String>(
      'forms_link', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _ntDeptTypeIdMeta =
      const VerificationMeta('ntDeptTypeId');
  @override
  late final GeneratedColumn<int> ntDeptTypeId = GeneratedColumn<int>(
      'nt_dept_type_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        guid,
        isDeleted,
        timestamp,
        currentTimestamp,
        lastSyncTime,
        needSync,
        isNew,
        id,
        name,
        address,
        buyerName,
        reason,
        latitude,
        longitude,
        pointFormat,
        numberOfCdesks,
        emailOnlineCheck,
        email,
        phoneOnlineCheck,
        inn,
        jur,
        plong,
        maxdebt,
        nds10,
        nds20,
        formsLink,
        ntDeptTypeId
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'points';
  @override
  VerificationContext validateIntegrity(Insertable<Point> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('guid')) {
      context.handle(
          _guidMeta, guid.isAcceptableOrUnknown(data['guid']!, _guidMeta));
    } else if (isInserting) {
      context.missing(_guidMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('timestamp')) {
      context.handle(_timestampMeta,
          timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta));
    }
    if (data.containsKey('current_timestamp')) {
      context.handle(
          _currentTimestampMeta,
          currentTimestamp.isAcceptableOrUnknown(
              data['current_timestamp']!, _currentTimestampMeta));
    }
    if (data.containsKey('last_sync_time')) {
      context.handle(
          _lastSyncTimeMeta,
          lastSyncTime.isAcceptableOrUnknown(
              data['last_sync_time']!, _lastSyncTimeMeta));
    }
    if (data.containsKey('need_sync')) {
      context.handle(_needSyncMeta,
          needSync.isAcceptableOrUnknown(data['need_sync']!, _needSyncMeta));
    }
    if (data.containsKey('is_new')) {
      context.handle(
          _isNewMeta, isNew.isAcceptableOrUnknown(data['is_new']!, _isNewMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('address')) {
      context.handle(_addressMeta,
          address.isAcceptableOrUnknown(data['address']!, _addressMeta));
    }
    if (data.containsKey('buyer_name')) {
      context.handle(_buyerNameMeta,
          buyerName.isAcceptableOrUnknown(data['buyer_name']!, _buyerNameMeta));
    } else if (isInserting) {
      context.missing(_buyerNameMeta);
    }
    if (data.containsKey('reason')) {
      context.handle(_reasonMeta,
          reason.isAcceptableOrUnknown(data['reason']!, _reasonMeta));
    } else if (isInserting) {
      context.missing(_reasonMeta);
    }
    if (data.containsKey('latitude')) {
      context.handle(_latitudeMeta,
          latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta));
    }
    if (data.containsKey('longitude')) {
      context.handle(_longitudeMeta,
          longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta));
    }
    if (data.containsKey('point_format')) {
      context.handle(
          _pointFormatMeta,
          pointFormat.isAcceptableOrUnknown(
              data['point_format']!, _pointFormatMeta));
    }
    if (data.containsKey('number_of_cdesks')) {
      context.handle(
          _numberOfCdesksMeta,
          numberOfCdesks.isAcceptableOrUnknown(
              data['number_of_cdesks']!, _numberOfCdesksMeta));
    }
    if (data.containsKey('email_online_check')) {
      context.handle(
          _emailOnlineCheckMeta,
          emailOnlineCheck.isAcceptableOrUnknown(
              data['email_online_check']!, _emailOnlineCheckMeta));
    }
    if (data.containsKey('email')) {
      context.handle(
          _emailMeta, email.isAcceptableOrUnknown(data['email']!, _emailMeta));
    }
    if (data.containsKey('phone_online_check')) {
      context.handle(
          _phoneOnlineCheckMeta,
          phoneOnlineCheck.isAcceptableOrUnknown(
              data['phone_online_check']!, _phoneOnlineCheckMeta));
    }
    if (data.containsKey('inn')) {
      context.handle(
          _innMeta, inn.isAcceptableOrUnknown(data['inn']!, _innMeta));
    }
    if (data.containsKey('jur')) {
      context.handle(
          _jurMeta, jur.isAcceptableOrUnknown(data['jur']!, _jurMeta));
    }
    if (data.containsKey('plong')) {
      context.handle(
          _plongMeta, plong.isAcceptableOrUnknown(data['plong']!, _plongMeta));
    }
    if (data.containsKey('maxdebt')) {
      context.handle(_maxdebtMeta,
          maxdebt.isAcceptableOrUnknown(data['maxdebt']!, _maxdebtMeta));
    }
    if (data.containsKey('nds10')) {
      context.handle(
          _nds10Meta, nds10.isAcceptableOrUnknown(data['nds10']!, _nds10Meta));
    }
    if (data.containsKey('nds20')) {
      context.handle(
          _nds20Meta, nds20.isAcceptableOrUnknown(data['nds20']!, _nds20Meta));
    }
    if (data.containsKey('forms_link')) {
      context.handle(_formsLinkMeta,
          formsLink.isAcceptableOrUnknown(data['forms_link']!, _formsLinkMeta));
    }
    if (data.containsKey('nt_dept_type_id')) {
      context.handle(
          _ntDeptTypeIdMeta,
          ntDeptTypeId.isAcceptableOrUnknown(
              data['nt_dept_type_id']!, _ntDeptTypeIdMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {guid};
  @override
  Point map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Point(
      guid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}guid'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      timestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}timestamp'])!,
      currentTimestamp: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}current_timestamp'])!,
      lastSyncTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_sync_time']),
      needSync: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_sync'])!,
      isNew: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_new'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id']),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      address: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}address']),
      buyerName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}buyer_name'])!,
      reason: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reason'])!,
      latitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}latitude']),
      longitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}longitude']),
      pointFormat: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}point_format']),
      numberOfCdesks: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}number_of_cdesks']),
      emailOnlineCheck: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}email_online_check']),
      email: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}email']),
      phoneOnlineCheck: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}phone_online_check']),
      inn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}inn']),
      jur: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}jur']),
      plong: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}plong']),
      maxdebt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}maxdebt']),
      nds10: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}nds10']),
      nds20: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}nds20']),
      formsLink: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}forms_link']),
      ntDeptTypeId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}nt_dept_type_id']),
    );
  }

  @override
  $PointsTable createAlias(String alias) {
    return $PointsTable(attachedDatabase, alias);
  }
}

class Point extends DataClass implements Insertable<Point> {
  final String guid;
  final bool isDeleted;
  final DateTime timestamp;
  final DateTime currentTimestamp;
  final DateTime? lastSyncTime;
  final bool needSync;
  final bool isNew;
  final int? id;
  final String name;
  final String? address;
  final String buyerName;
  final String reason;
  final double? latitude;
  final double? longitude;
  final int? pointFormat;
  final int? numberOfCdesks;
  final String? emailOnlineCheck;
  final String? email;
  final String? phoneOnlineCheck;
  final String? inn;
  final String? jur;
  final int? plong;
  final int? maxdebt;
  final int? nds10;
  final int? nds20;
  final String? formsLink;
  final int? ntDeptTypeId;
  const Point(
      {required this.guid,
      required this.isDeleted,
      required this.timestamp,
      required this.currentTimestamp,
      this.lastSyncTime,
      required this.needSync,
      required this.isNew,
      this.id,
      required this.name,
      this.address,
      required this.buyerName,
      required this.reason,
      this.latitude,
      this.longitude,
      this.pointFormat,
      this.numberOfCdesks,
      this.emailOnlineCheck,
      this.email,
      this.phoneOnlineCheck,
      this.inn,
      this.jur,
      this.plong,
      this.maxdebt,
      this.nds10,
      this.nds20,
      this.formsLink,
      this.ntDeptTypeId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['guid'] = Variable<String>(guid);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['timestamp'] = Variable<DateTime>(timestamp);
    map['current_timestamp'] = Variable<DateTime>(currentTimestamp);
    if (!nullToAbsent || lastSyncTime != null) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || address != null) {
      map['address'] = Variable<String>(address);
    }
    map['buyer_name'] = Variable<String>(buyerName);
    map['reason'] = Variable<String>(reason);
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<double>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<double>(longitude);
    }
    if (!nullToAbsent || pointFormat != null) {
      map['point_format'] = Variable<int>(pointFormat);
    }
    if (!nullToAbsent || numberOfCdesks != null) {
      map['number_of_cdesks'] = Variable<int>(numberOfCdesks);
    }
    if (!nullToAbsent || emailOnlineCheck != null) {
      map['email_online_check'] = Variable<String>(emailOnlineCheck);
    }
    if (!nullToAbsent || email != null) {
      map['email'] = Variable<String>(email);
    }
    if (!nullToAbsent || phoneOnlineCheck != null) {
      map['phone_online_check'] = Variable<String>(phoneOnlineCheck);
    }
    if (!nullToAbsent || inn != null) {
      map['inn'] = Variable<String>(inn);
    }
    if (!nullToAbsent || jur != null) {
      map['jur'] = Variable<String>(jur);
    }
    if (!nullToAbsent || plong != null) {
      map['plong'] = Variable<int>(plong);
    }
    if (!nullToAbsent || maxdebt != null) {
      map['maxdebt'] = Variable<int>(maxdebt);
    }
    if (!nullToAbsent || nds10 != null) {
      map['nds10'] = Variable<int>(nds10);
    }
    if (!nullToAbsent || nds20 != null) {
      map['nds20'] = Variable<int>(nds20);
    }
    if (!nullToAbsent || formsLink != null) {
      map['forms_link'] = Variable<String>(formsLink);
    }
    if (!nullToAbsent || ntDeptTypeId != null) {
      map['nt_dept_type_id'] = Variable<int>(ntDeptTypeId);
    }
    return map;
  }

  PointsCompanion toCompanion(bool nullToAbsent) {
    return PointsCompanion(
      guid: Value(guid),
      isDeleted: Value(isDeleted),
      timestamp: Value(timestamp),
      currentTimestamp: Value(currentTimestamp),
      lastSyncTime: lastSyncTime == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncTime),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      name: Value(name),
      address: address == null && nullToAbsent
          ? const Value.absent()
          : Value(address),
      buyerName: Value(buyerName),
      reason: Value(reason),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      pointFormat: pointFormat == null && nullToAbsent
          ? const Value.absent()
          : Value(pointFormat),
      numberOfCdesks: numberOfCdesks == null && nullToAbsent
          ? const Value.absent()
          : Value(numberOfCdesks),
      emailOnlineCheck: emailOnlineCheck == null && nullToAbsent
          ? const Value.absent()
          : Value(emailOnlineCheck),
      email:
          email == null && nullToAbsent ? const Value.absent() : Value(email),
      phoneOnlineCheck: phoneOnlineCheck == null && nullToAbsent
          ? const Value.absent()
          : Value(phoneOnlineCheck),
      inn: inn == null && nullToAbsent ? const Value.absent() : Value(inn),
      jur: jur == null && nullToAbsent ? const Value.absent() : Value(jur),
      plong:
          plong == null && nullToAbsent ? const Value.absent() : Value(plong),
      maxdebt: maxdebt == null && nullToAbsent
          ? const Value.absent()
          : Value(maxdebt),
      nds10:
          nds10 == null && nullToAbsent ? const Value.absent() : Value(nds10),
      nds20:
          nds20 == null && nullToAbsent ? const Value.absent() : Value(nds20),
      formsLink: formsLink == null && nullToAbsent
          ? const Value.absent()
          : Value(formsLink),
      ntDeptTypeId: ntDeptTypeId == null && nullToAbsent
          ? const Value.absent()
          : Value(ntDeptTypeId),
    );
  }

  factory Point.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Point(
      guid: serializer.fromJson<String>(json['guid']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      currentTimestamp: serializer.fromJson<DateTime>(json['currentTimestamp']),
      lastSyncTime: serializer.fromJson<DateTime?>(json['lastSyncTime']),
      needSync: serializer.fromJson<bool>(json['needSync']),
      isNew: serializer.fromJson<bool>(json['isNew']),
      id: serializer.fromJson<int?>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      address: serializer.fromJson<String?>(json['address']),
      buyerName: serializer.fromJson<String>(json['buyerName']),
      reason: serializer.fromJson<String>(json['reason']),
      latitude: serializer.fromJson<double?>(json['latitude']),
      longitude: serializer.fromJson<double?>(json['longitude']),
      pointFormat: serializer.fromJson<int?>(json['pointFormat']),
      numberOfCdesks: serializer.fromJson<int?>(json['numberOfCdesks']),
      emailOnlineCheck: serializer.fromJson<String?>(json['emailOnlineCheck']),
      email: serializer.fromJson<String?>(json['email']),
      phoneOnlineCheck: serializer.fromJson<String?>(json['phoneOnlineCheck']),
      inn: serializer.fromJson<String?>(json['inn']),
      jur: serializer.fromJson<String?>(json['jur']),
      plong: serializer.fromJson<int?>(json['plong']),
      maxdebt: serializer.fromJson<int?>(json['maxdebt']),
      nds10: serializer.fromJson<int?>(json['nds10']),
      nds20: serializer.fromJson<int?>(json['nds20']),
      formsLink: serializer.fromJson<String?>(json['formsLink']),
      ntDeptTypeId: serializer.fromJson<int?>(json['ntDeptTypeId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'guid': serializer.toJson<String>(guid),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'currentTimestamp': serializer.toJson<DateTime>(currentTimestamp),
      'lastSyncTime': serializer.toJson<DateTime?>(lastSyncTime),
      'needSync': serializer.toJson<bool>(needSync),
      'isNew': serializer.toJson<bool>(isNew),
      'id': serializer.toJson<int?>(id),
      'name': serializer.toJson<String>(name),
      'address': serializer.toJson<String?>(address),
      'buyerName': serializer.toJson<String>(buyerName),
      'reason': serializer.toJson<String>(reason),
      'latitude': serializer.toJson<double?>(latitude),
      'longitude': serializer.toJson<double?>(longitude),
      'pointFormat': serializer.toJson<int?>(pointFormat),
      'numberOfCdesks': serializer.toJson<int?>(numberOfCdesks),
      'emailOnlineCheck': serializer.toJson<String?>(emailOnlineCheck),
      'email': serializer.toJson<String?>(email),
      'phoneOnlineCheck': serializer.toJson<String?>(phoneOnlineCheck),
      'inn': serializer.toJson<String?>(inn),
      'jur': serializer.toJson<String?>(jur),
      'plong': serializer.toJson<int?>(plong),
      'maxdebt': serializer.toJson<int?>(maxdebt),
      'nds10': serializer.toJson<int?>(nds10),
      'nds20': serializer.toJson<int?>(nds20),
      'formsLink': serializer.toJson<String?>(formsLink),
      'ntDeptTypeId': serializer.toJson<int?>(ntDeptTypeId),
    };
  }

  Point copyWith(
          {String? guid,
          bool? isDeleted,
          DateTime? timestamp,
          DateTime? currentTimestamp,
          Value<DateTime?> lastSyncTime = const Value.absent(),
          bool? needSync,
          bool? isNew,
          Value<int?> id = const Value.absent(),
          String? name,
          Value<String?> address = const Value.absent(),
          String? buyerName,
          String? reason,
          Value<double?> latitude = const Value.absent(),
          Value<double?> longitude = const Value.absent(),
          Value<int?> pointFormat = const Value.absent(),
          Value<int?> numberOfCdesks = const Value.absent(),
          Value<String?> emailOnlineCheck = const Value.absent(),
          Value<String?> email = const Value.absent(),
          Value<String?> phoneOnlineCheck = const Value.absent(),
          Value<String?> inn = const Value.absent(),
          Value<String?> jur = const Value.absent(),
          Value<int?> plong = const Value.absent(),
          Value<int?> maxdebt = const Value.absent(),
          Value<int?> nds10 = const Value.absent(),
          Value<int?> nds20 = const Value.absent(),
          Value<String?> formsLink = const Value.absent(),
          Value<int?> ntDeptTypeId = const Value.absent()}) =>
      Point(
        guid: guid ?? this.guid,
        isDeleted: isDeleted ?? this.isDeleted,
        timestamp: timestamp ?? this.timestamp,
        currentTimestamp: currentTimestamp ?? this.currentTimestamp,
        lastSyncTime:
            lastSyncTime.present ? lastSyncTime.value : this.lastSyncTime,
        needSync: needSync ?? this.needSync,
        isNew: isNew ?? this.isNew,
        id: id.present ? id.value : this.id,
        name: name ?? this.name,
        address: address.present ? address.value : this.address,
        buyerName: buyerName ?? this.buyerName,
        reason: reason ?? this.reason,
        latitude: latitude.present ? latitude.value : this.latitude,
        longitude: longitude.present ? longitude.value : this.longitude,
        pointFormat: pointFormat.present ? pointFormat.value : this.pointFormat,
        numberOfCdesks:
            numberOfCdesks.present ? numberOfCdesks.value : this.numberOfCdesks,
        emailOnlineCheck: emailOnlineCheck.present
            ? emailOnlineCheck.value
            : this.emailOnlineCheck,
        email: email.present ? email.value : this.email,
        phoneOnlineCheck: phoneOnlineCheck.present
            ? phoneOnlineCheck.value
            : this.phoneOnlineCheck,
        inn: inn.present ? inn.value : this.inn,
        jur: jur.present ? jur.value : this.jur,
        plong: plong.present ? plong.value : this.plong,
        maxdebt: maxdebt.present ? maxdebt.value : this.maxdebt,
        nds10: nds10.present ? nds10.value : this.nds10,
        nds20: nds20.present ? nds20.value : this.nds20,
        formsLink: formsLink.present ? formsLink.value : this.formsLink,
        ntDeptTypeId:
            ntDeptTypeId.present ? ntDeptTypeId.value : this.ntDeptTypeId,
      );
  @override
  String toString() {
    return (StringBuffer('Point(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('needSync: $needSync, ')
          ..write('isNew: $isNew, ')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('address: $address, ')
          ..write('buyerName: $buyerName, ')
          ..write('reason: $reason, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('pointFormat: $pointFormat, ')
          ..write('numberOfCdesks: $numberOfCdesks, ')
          ..write('emailOnlineCheck: $emailOnlineCheck, ')
          ..write('email: $email, ')
          ..write('phoneOnlineCheck: $phoneOnlineCheck, ')
          ..write('inn: $inn, ')
          ..write('jur: $jur, ')
          ..write('plong: $plong, ')
          ..write('maxdebt: $maxdebt, ')
          ..write('nds10: $nds10, ')
          ..write('nds20: $nds20, ')
          ..write('formsLink: $formsLink, ')
          ..write('ntDeptTypeId: $ntDeptTypeId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        guid,
        isDeleted,
        timestamp,
        currentTimestamp,
        lastSyncTime,
        needSync,
        isNew,
        id,
        name,
        address,
        buyerName,
        reason,
        latitude,
        longitude,
        pointFormat,
        numberOfCdesks,
        emailOnlineCheck,
        email,
        phoneOnlineCheck,
        inn,
        jur,
        plong,
        maxdebt,
        nds10,
        nds20,
        formsLink,
        ntDeptTypeId
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Point &&
          other.guid == this.guid &&
          other.isDeleted == this.isDeleted &&
          other.timestamp == this.timestamp &&
          other.currentTimestamp == this.currentTimestamp &&
          other.lastSyncTime == this.lastSyncTime &&
          other.needSync == this.needSync &&
          other.isNew == this.isNew &&
          other.id == this.id &&
          other.name == this.name &&
          other.address == this.address &&
          other.buyerName == this.buyerName &&
          other.reason == this.reason &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.pointFormat == this.pointFormat &&
          other.numberOfCdesks == this.numberOfCdesks &&
          other.emailOnlineCheck == this.emailOnlineCheck &&
          other.email == this.email &&
          other.phoneOnlineCheck == this.phoneOnlineCheck &&
          other.inn == this.inn &&
          other.jur == this.jur &&
          other.plong == this.plong &&
          other.maxdebt == this.maxdebt &&
          other.nds10 == this.nds10 &&
          other.nds20 == this.nds20 &&
          other.formsLink == this.formsLink &&
          other.ntDeptTypeId == this.ntDeptTypeId);
}

class PointsCompanion extends UpdateCompanion<Point> {
  final Value<String> guid;
  final Value<bool> isDeleted;
  final Value<DateTime> timestamp;
  final Value<DateTime> currentTimestamp;
  final Value<DateTime?> lastSyncTime;
  final Value<int?> id;
  final Value<String> name;
  final Value<String?> address;
  final Value<String> buyerName;
  final Value<String> reason;
  final Value<double?> latitude;
  final Value<double?> longitude;
  final Value<int?> pointFormat;
  final Value<int?> numberOfCdesks;
  final Value<String?> emailOnlineCheck;
  final Value<String?> email;
  final Value<String?> phoneOnlineCheck;
  final Value<String?> inn;
  final Value<String?> jur;
  final Value<int?> plong;
  final Value<int?> maxdebt;
  final Value<int?> nds10;
  final Value<int?> nds20;
  final Value<String?> formsLink;
  final Value<int?> ntDeptTypeId;
  final Value<int> rowid;
  const PointsCompanion({
    this.guid = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.address = const Value.absent(),
    this.buyerName = const Value.absent(),
    this.reason = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.pointFormat = const Value.absent(),
    this.numberOfCdesks = const Value.absent(),
    this.emailOnlineCheck = const Value.absent(),
    this.email = const Value.absent(),
    this.phoneOnlineCheck = const Value.absent(),
    this.inn = const Value.absent(),
    this.jur = const Value.absent(),
    this.plong = const Value.absent(),
    this.maxdebt = const Value.absent(),
    this.nds10 = const Value.absent(),
    this.nds20 = const Value.absent(),
    this.formsLink = const Value.absent(),
    this.ntDeptTypeId = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PointsCompanion.insert({
    required String guid,
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    required String name,
    this.address = const Value.absent(),
    required String buyerName,
    required String reason,
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.pointFormat = const Value.absent(),
    this.numberOfCdesks = const Value.absent(),
    this.emailOnlineCheck = const Value.absent(),
    this.email = const Value.absent(),
    this.phoneOnlineCheck = const Value.absent(),
    this.inn = const Value.absent(),
    this.jur = const Value.absent(),
    this.plong = const Value.absent(),
    this.maxdebt = const Value.absent(),
    this.nds10 = const Value.absent(),
    this.nds20 = const Value.absent(),
    this.formsLink = const Value.absent(),
    this.ntDeptTypeId = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : guid = Value(guid),
        name = Value(name),
        buyerName = Value(buyerName),
        reason = Value(reason);
  static Insertable<Point> custom({
    Expression<String>? guid,
    Expression<bool>? isDeleted,
    Expression<DateTime>? timestamp,
    Expression<DateTime>? currentTimestamp,
    Expression<DateTime>? lastSyncTime,
    Expression<int>? id,
    Expression<String>? name,
    Expression<String>? address,
    Expression<String>? buyerName,
    Expression<String>? reason,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<int>? pointFormat,
    Expression<int>? numberOfCdesks,
    Expression<String>? emailOnlineCheck,
    Expression<String>? email,
    Expression<String>? phoneOnlineCheck,
    Expression<String>? inn,
    Expression<String>? jur,
    Expression<int>? plong,
    Expression<int>? maxdebt,
    Expression<int>? nds10,
    Expression<int>? nds20,
    Expression<String>? formsLink,
    Expression<int>? ntDeptTypeId,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (guid != null) 'guid': guid,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (timestamp != null) 'timestamp': timestamp,
      if (currentTimestamp != null) 'current_timestamp': currentTimestamp,
      if (lastSyncTime != null) 'last_sync_time': lastSyncTime,
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (address != null) 'address': address,
      if (buyerName != null) 'buyer_name': buyerName,
      if (reason != null) 'reason': reason,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (pointFormat != null) 'point_format': pointFormat,
      if (numberOfCdesks != null) 'number_of_cdesks': numberOfCdesks,
      if (emailOnlineCheck != null) 'email_online_check': emailOnlineCheck,
      if (email != null) 'email': email,
      if (phoneOnlineCheck != null) 'phone_online_check': phoneOnlineCheck,
      if (inn != null) 'inn': inn,
      if (jur != null) 'jur': jur,
      if (plong != null) 'plong': plong,
      if (maxdebt != null) 'maxdebt': maxdebt,
      if (nds10 != null) 'nds10': nds10,
      if (nds20 != null) 'nds20': nds20,
      if (formsLink != null) 'forms_link': formsLink,
      if (ntDeptTypeId != null) 'nt_dept_type_id': ntDeptTypeId,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PointsCompanion copyWith(
      {Value<String>? guid,
      Value<bool>? isDeleted,
      Value<DateTime>? timestamp,
      Value<DateTime>? currentTimestamp,
      Value<DateTime?>? lastSyncTime,
      Value<int?>? id,
      Value<String>? name,
      Value<String?>? address,
      Value<String>? buyerName,
      Value<String>? reason,
      Value<double?>? latitude,
      Value<double?>? longitude,
      Value<int?>? pointFormat,
      Value<int?>? numberOfCdesks,
      Value<String?>? emailOnlineCheck,
      Value<String?>? email,
      Value<String?>? phoneOnlineCheck,
      Value<String?>? inn,
      Value<String?>? jur,
      Value<int?>? plong,
      Value<int?>? maxdebt,
      Value<int?>? nds10,
      Value<int?>? nds20,
      Value<String?>? formsLink,
      Value<int?>? ntDeptTypeId,
      Value<int>? rowid}) {
    return PointsCompanion(
      guid: guid ?? this.guid,
      isDeleted: isDeleted ?? this.isDeleted,
      timestamp: timestamp ?? this.timestamp,
      currentTimestamp: currentTimestamp ?? this.currentTimestamp,
      lastSyncTime: lastSyncTime ?? this.lastSyncTime,
      id: id ?? this.id,
      name: name ?? this.name,
      address: address ?? this.address,
      buyerName: buyerName ?? this.buyerName,
      reason: reason ?? this.reason,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      pointFormat: pointFormat ?? this.pointFormat,
      numberOfCdesks: numberOfCdesks ?? this.numberOfCdesks,
      emailOnlineCheck: emailOnlineCheck ?? this.emailOnlineCheck,
      email: email ?? this.email,
      phoneOnlineCheck: phoneOnlineCheck ?? this.phoneOnlineCheck,
      inn: inn ?? this.inn,
      jur: jur ?? this.jur,
      plong: plong ?? this.plong,
      maxdebt: maxdebt ?? this.maxdebt,
      nds10: nds10 ?? this.nds10,
      nds20: nds20 ?? this.nds20,
      formsLink: formsLink ?? this.formsLink,
      ntDeptTypeId: ntDeptTypeId ?? this.ntDeptTypeId,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (guid.present) {
      map['guid'] = Variable<String>(guid.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (currentTimestamp.present) {
      map['current_timestamp'] = Variable<DateTime>(currentTimestamp.value);
    }
    if (lastSyncTime.present) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (address.present) {
      map['address'] = Variable<String>(address.value);
    }
    if (buyerName.present) {
      map['buyer_name'] = Variable<String>(buyerName.value);
    }
    if (reason.present) {
      map['reason'] = Variable<String>(reason.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (pointFormat.present) {
      map['point_format'] = Variable<int>(pointFormat.value);
    }
    if (numberOfCdesks.present) {
      map['number_of_cdesks'] = Variable<int>(numberOfCdesks.value);
    }
    if (emailOnlineCheck.present) {
      map['email_online_check'] = Variable<String>(emailOnlineCheck.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (phoneOnlineCheck.present) {
      map['phone_online_check'] = Variable<String>(phoneOnlineCheck.value);
    }
    if (inn.present) {
      map['inn'] = Variable<String>(inn.value);
    }
    if (jur.present) {
      map['jur'] = Variable<String>(jur.value);
    }
    if (plong.present) {
      map['plong'] = Variable<int>(plong.value);
    }
    if (maxdebt.present) {
      map['maxdebt'] = Variable<int>(maxdebt.value);
    }
    if (nds10.present) {
      map['nds10'] = Variable<int>(nds10.value);
    }
    if (nds20.present) {
      map['nds20'] = Variable<int>(nds20.value);
    }
    if (formsLink.present) {
      map['forms_link'] = Variable<String>(formsLink.value);
    }
    if (ntDeptTypeId.present) {
      map['nt_dept_type_id'] = Variable<int>(ntDeptTypeId.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PointsCompanion(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('address: $address, ')
          ..write('buyerName: $buyerName, ')
          ..write('reason: $reason, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('pointFormat: $pointFormat, ')
          ..write('numberOfCdesks: $numberOfCdesks, ')
          ..write('emailOnlineCheck: $emailOnlineCheck, ')
          ..write('email: $email, ')
          ..write('phoneOnlineCheck: $phoneOnlineCheck, ')
          ..write('inn: $inn, ')
          ..write('jur: $jur, ')
          ..write('plong: $plong, ')
          ..write('maxdebt: $maxdebt, ')
          ..write('nds10: $nds10, ')
          ..write('nds20: $nds20, ')
          ..write('formsLink: $formsLink, ')
          ..write('ntDeptTypeId: $ntDeptTypeId, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PointImagesTable extends PointImages
    with TableInfo<$PointImagesTable, PointImage> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PointImagesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _guidMeta = const VerificationMeta('guid');
  @override
  late final GeneratedColumn<String> guid = GeneratedColumn<String>(
      'guid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _timestampMeta =
      const VerificationMeta('timestamp');
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
      'timestamp', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _currentTimestampMeta =
      const VerificationMeta('currentTimestamp');
  @override
  late final GeneratedColumn<DateTime> currentTimestamp =
      GeneratedColumn<DateTime>('current_timestamp', aliasedName, false,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          defaultValue: currentDateAndTime);
  static const VerificationMeta _lastSyncTimeMeta =
      const VerificationMeta('lastSyncTime');
  @override
  late final GeneratedColumn<DateTime> lastSyncTime = GeneratedColumn<DateTime>(
      'last_sync_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _needSyncMeta =
      const VerificationMeta('needSync');
  @override
  late final GeneratedColumn<bool> needSync = GeneratedColumn<bool>(
      'need_sync', aliasedName, false,
      generatedAs: GeneratedAs(
          (isNew & BooleanExpressionOperators(isDeleted).not()) |
              (BooleanExpressionOperators(isNew).not() &
                  ComparableExpr(lastSyncTime).isSmallerThan(timestamp)),
          true),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("need_sync" IN (0, 1))'));
  static const VerificationMeta _isNewMeta = const VerificationMeta('isNew');
  @override
  late final GeneratedColumn<bool> isNew = GeneratedColumn<bool>(
      'is_new', aliasedName, false,
      generatedAs: GeneratedAs(lastSyncTime.isNull(), false),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_new" IN (0, 1))'));
  static const VerificationMeta _latitudeMeta =
      const VerificationMeta('latitude');
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
      'latitude', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _longitudeMeta =
      const VerificationMeta('longitude');
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
      'longitude', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _accuracyMeta =
      const VerificationMeta('accuracy');
  @override
  late final GeneratedColumn<double> accuracy = GeneratedColumn<double>(
      'accuracy', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _imageUrlMeta =
      const VerificationMeta('imageUrl');
  @override
  late final GeneratedColumn<String> imageUrl = GeneratedColumn<String>(
      'image_url', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _imageKeyMeta =
      const VerificationMeta('imageKey');
  @override
  late final GeneratedColumn<String> imageKey = GeneratedColumn<String>(
      'image_key', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _pointGuidMeta =
      const VerificationMeta('pointGuid');
  @override
  late final GeneratedColumn<String> pointGuid = GeneratedColumn<String>(
      'point_guid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES points (guid) ON UPDATE CASCADE ON DELETE CASCADE'));
  @override
  List<GeneratedColumn> get $columns => [
        guid,
        isDeleted,
        timestamp,
        currentTimestamp,
        lastSyncTime,
        needSync,
        isNew,
        latitude,
        longitude,
        accuracy,
        imageUrl,
        imageKey,
        id,
        pointGuid
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'point_images';
  @override
  VerificationContext validateIntegrity(Insertable<PointImage> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('guid')) {
      context.handle(
          _guidMeta, guid.isAcceptableOrUnknown(data['guid']!, _guidMeta));
    } else if (isInserting) {
      context.missing(_guidMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('timestamp')) {
      context.handle(_timestampMeta,
          timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta));
    }
    if (data.containsKey('current_timestamp')) {
      context.handle(
          _currentTimestampMeta,
          currentTimestamp.isAcceptableOrUnknown(
              data['current_timestamp']!, _currentTimestampMeta));
    }
    if (data.containsKey('last_sync_time')) {
      context.handle(
          _lastSyncTimeMeta,
          lastSyncTime.isAcceptableOrUnknown(
              data['last_sync_time']!, _lastSyncTimeMeta));
    }
    if (data.containsKey('need_sync')) {
      context.handle(_needSyncMeta,
          needSync.isAcceptableOrUnknown(data['need_sync']!, _needSyncMeta));
    }
    if (data.containsKey('is_new')) {
      context.handle(
          _isNewMeta, isNew.isAcceptableOrUnknown(data['is_new']!, _isNewMeta));
    }
    if (data.containsKey('latitude')) {
      context.handle(_latitudeMeta,
          latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta));
    } else if (isInserting) {
      context.missing(_latitudeMeta);
    }
    if (data.containsKey('longitude')) {
      context.handle(_longitudeMeta,
          longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta));
    } else if (isInserting) {
      context.missing(_longitudeMeta);
    }
    if (data.containsKey('accuracy')) {
      context.handle(_accuracyMeta,
          accuracy.isAcceptableOrUnknown(data['accuracy']!, _accuracyMeta));
    } else if (isInserting) {
      context.missing(_accuracyMeta);
    }
    if (data.containsKey('image_url')) {
      context.handle(_imageUrlMeta,
          imageUrl.isAcceptableOrUnknown(data['image_url']!, _imageUrlMeta));
    } else if (isInserting) {
      context.missing(_imageUrlMeta);
    }
    if (data.containsKey('image_key')) {
      context.handle(_imageKeyMeta,
          imageKey.isAcceptableOrUnknown(data['image_key']!, _imageKeyMeta));
    } else if (isInserting) {
      context.missing(_imageKeyMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('point_guid')) {
      context.handle(_pointGuidMeta,
          pointGuid.isAcceptableOrUnknown(data['point_guid']!, _pointGuidMeta));
    } else if (isInserting) {
      context.missing(_pointGuidMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {guid};
  @override
  PointImage map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PointImage(
      guid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}guid'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      timestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}timestamp'])!,
      currentTimestamp: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}current_timestamp'])!,
      lastSyncTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_sync_time']),
      needSync: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_sync'])!,
      isNew: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_new'])!,
      latitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}latitude'])!,
      longitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}longitude'])!,
      accuracy: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}accuracy'])!,
      imageUrl: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}image_url'])!,
      imageKey: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}image_key'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id']),
      pointGuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}point_guid'])!,
    );
  }

  @override
  $PointImagesTable createAlias(String alias) {
    return $PointImagesTable(attachedDatabase, alias);
  }
}

class PointImage extends DataClass implements Insertable<PointImage> {
  final String guid;
  final bool isDeleted;
  final DateTime timestamp;
  final DateTime currentTimestamp;
  final DateTime? lastSyncTime;
  final bool needSync;
  final bool isNew;
  final double latitude;
  final double longitude;
  final double accuracy;
  final String imageUrl;
  final String imageKey;
  final int? id;
  final String pointGuid;
  const PointImage(
      {required this.guid,
      required this.isDeleted,
      required this.timestamp,
      required this.currentTimestamp,
      this.lastSyncTime,
      required this.needSync,
      required this.isNew,
      required this.latitude,
      required this.longitude,
      required this.accuracy,
      required this.imageUrl,
      required this.imageKey,
      this.id,
      required this.pointGuid});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['guid'] = Variable<String>(guid);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['timestamp'] = Variable<DateTime>(timestamp);
    map['current_timestamp'] = Variable<DateTime>(currentTimestamp);
    if (!nullToAbsent || lastSyncTime != null) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime);
    }
    map['latitude'] = Variable<double>(latitude);
    map['longitude'] = Variable<double>(longitude);
    map['accuracy'] = Variable<double>(accuracy);
    map['image_url'] = Variable<String>(imageUrl);
    map['image_key'] = Variable<String>(imageKey);
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    map['point_guid'] = Variable<String>(pointGuid);
    return map;
  }

  PointImagesCompanion toCompanion(bool nullToAbsent) {
    return PointImagesCompanion(
      guid: Value(guid),
      isDeleted: Value(isDeleted),
      timestamp: Value(timestamp),
      currentTimestamp: Value(currentTimestamp),
      lastSyncTime: lastSyncTime == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncTime),
      latitude: Value(latitude),
      longitude: Value(longitude),
      accuracy: Value(accuracy),
      imageUrl: Value(imageUrl),
      imageKey: Value(imageKey),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      pointGuid: Value(pointGuid),
    );
  }

  factory PointImage.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PointImage(
      guid: serializer.fromJson<String>(json['guid']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      currentTimestamp: serializer.fromJson<DateTime>(json['currentTimestamp']),
      lastSyncTime: serializer.fromJson<DateTime?>(json['lastSyncTime']),
      needSync: serializer.fromJson<bool>(json['needSync']),
      isNew: serializer.fromJson<bool>(json['isNew']),
      latitude: serializer.fromJson<double>(json['latitude']),
      longitude: serializer.fromJson<double>(json['longitude']),
      accuracy: serializer.fromJson<double>(json['accuracy']),
      imageUrl: serializer.fromJson<String>(json['imageUrl']),
      imageKey: serializer.fromJson<String>(json['imageKey']),
      id: serializer.fromJson<int?>(json['id']),
      pointGuid: serializer.fromJson<String>(json['pointGuid']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'guid': serializer.toJson<String>(guid),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'currentTimestamp': serializer.toJson<DateTime>(currentTimestamp),
      'lastSyncTime': serializer.toJson<DateTime?>(lastSyncTime),
      'needSync': serializer.toJson<bool>(needSync),
      'isNew': serializer.toJson<bool>(isNew),
      'latitude': serializer.toJson<double>(latitude),
      'longitude': serializer.toJson<double>(longitude),
      'accuracy': serializer.toJson<double>(accuracy),
      'imageUrl': serializer.toJson<String>(imageUrl),
      'imageKey': serializer.toJson<String>(imageKey),
      'id': serializer.toJson<int?>(id),
      'pointGuid': serializer.toJson<String>(pointGuid),
    };
  }

  PointImage copyWith(
          {String? guid,
          bool? isDeleted,
          DateTime? timestamp,
          DateTime? currentTimestamp,
          Value<DateTime?> lastSyncTime = const Value.absent(),
          bool? needSync,
          bool? isNew,
          double? latitude,
          double? longitude,
          double? accuracy,
          String? imageUrl,
          String? imageKey,
          Value<int?> id = const Value.absent(),
          String? pointGuid}) =>
      PointImage(
        guid: guid ?? this.guid,
        isDeleted: isDeleted ?? this.isDeleted,
        timestamp: timestamp ?? this.timestamp,
        currentTimestamp: currentTimestamp ?? this.currentTimestamp,
        lastSyncTime:
            lastSyncTime.present ? lastSyncTime.value : this.lastSyncTime,
        needSync: needSync ?? this.needSync,
        isNew: isNew ?? this.isNew,
        latitude: latitude ?? this.latitude,
        longitude: longitude ?? this.longitude,
        accuracy: accuracy ?? this.accuracy,
        imageUrl: imageUrl ?? this.imageUrl,
        imageKey: imageKey ?? this.imageKey,
        id: id.present ? id.value : this.id,
        pointGuid: pointGuid ?? this.pointGuid,
      );
  @override
  String toString() {
    return (StringBuffer('PointImage(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('needSync: $needSync, ')
          ..write('isNew: $isNew, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('accuracy: $accuracy, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('imageKey: $imageKey, ')
          ..write('id: $id, ')
          ..write('pointGuid: $pointGuid')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      guid,
      isDeleted,
      timestamp,
      currentTimestamp,
      lastSyncTime,
      needSync,
      isNew,
      latitude,
      longitude,
      accuracy,
      imageUrl,
      imageKey,
      id,
      pointGuid);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PointImage &&
          other.guid == this.guid &&
          other.isDeleted == this.isDeleted &&
          other.timestamp == this.timestamp &&
          other.currentTimestamp == this.currentTimestamp &&
          other.lastSyncTime == this.lastSyncTime &&
          other.needSync == this.needSync &&
          other.isNew == this.isNew &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.accuracy == this.accuracy &&
          other.imageUrl == this.imageUrl &&
          other.imageKey == this.imageKey &&
          other.id == this.id &&
          other.pointGuid == this.pointGuid);
}

class PointImagesCompanion extends UpdateCompanion<PointImage> {
  final Value<String> guid;
  final Value<bool> isDeleted;
  final Value<DateTime> timestamp;
  final Value<DateTime> currentTimestamp;
  final Value<DateTime?> lastSyncTime;
  final Value<double> latitude;
  final Value<double> longitude;
  final Value<double> accuracy;
  final Value<String> imageUrl;
  final Value<String> imageKey;
  final Value<int?> id;
  final Value<String> pointGuid;
  final Value<int> rowid;
  const PointImagesCompanion({
    this.guid = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.accuracy = const Value.absent(),
    this.imageUrl = const Value.absent(),
    this.imageKey = const Value.absent(),
    this.id = const Value.absent(),
    this.pointGuid = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PointImagesCompanion.insert({
    required String guid,
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    required double latitude,
    required double longitude,
    required double accuracy,
    required String imageUrl,
    required String imageKey,
    this.id = const Value.absent(),
    required String pointGuid,
    this.rowid = const Value.absent(),
  })  : guid = Value(guid),
        latitude = Value(latitude),
        longitude = Value(longitude),
        accuracy = Value(accuracy),
        imageUrl = Value(imageUrl),
        imageKey = Value(imageKey),
        pointGuid = Value(pointGuid);
  static Insertable<PointImage> custom({
    Expression<String>? guid,
    Expression<bool>? isDeleted,
    Expression<DateTime>? timestamp,
    Expression<DateTime>? currentTimestamp,
    Expression<DateTime>? lastSyncTime,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<double>? accuracy,
    Expression<String>? imageUrl,
    Expression<String>? imageKey,
    Expression<int>? id,
    Expression<String>? pointGuid,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (guid != null) 'guid': guid,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (timestamp != null) 'timestamp': timestamp,
      if (currentTimestamp != null) 'current_timestamp': currentTimestamp,
      if (lastSyncTime != null) 'last_sync_time': lastSyncTime,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (accuracy != null) 'accuracy': accuracy,
      if (imageUrl != null) 'image_url': imageUrl,
      if (imageKey != null) 'image_key': imageKey,
      if (id != null) 'id': id,
      if (pointGuid != null) 'point_guid': pointGuid,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PointImagesCompanion copyWith(
      {Value<String>? guid,
      Value<bool>? isDeleted,
      Value<DateTime>? timestamp,
      Value<DateTime>? currentTimestamp,
      Value<DateTime?>? lastSyncTime,
      Value<double>? latitude,
      Value<double>? longitude,
      Value<double>? accuracy,
      Value<String>? imageUrl,
      Value<String>? imageKey,
      Value<int?>? id,
      Value<String>? pointGuid,
      Value<int>? rowid}) {
    return PointImagesCompanion(
      guid: guid ?? this.guid,
      isDeleted: isDeleted ?? this.isDeleted,
      timestamp: timestamp ?? this.timestamp,
      currentTimestamp: currentTimestamp ?? this.currentTimestamp,
      lastSyncTime: lastSyncTime ?? this.lastSyncTime,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      accuracy: accuracy ?? this.accuracy,
      imageUrl: imageUrl ?? this.imageUrl,
      imageKey: imageKey ?? this.imageKey,
      id: id ?? this.id,
      pointGuid: pointGuid ?? this.pointGuid,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (guid.present) {
      map['guid'] = Variable<String>(guid.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (currentTimestamp.present) {
      map['current_timestamp'] = Variable<DateTime>(currentTimestamp.value);
    }
    if (lastSyncTime.present) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (accuracy.present) {
      map['accuracy'] = Variable<double>(accuracy.value);
    }
    if (imageUrl.present) {
      map['image_url'] = Variable<String>(imageUrl.value);
    }
    if (imageKey.present) {
      map['image_key'] = Variable<String>(imageKey.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (pointGuid.present) {
      map['point_guid'] = Variable<String>(pointGuid.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PointImagesCompanion(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('accuracy: $accuracy, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('imageKey: $imageKey, ')
          ..write('id: $id, ')
          ..write('pointGuid: $pointGuid, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PreEncashmentsTable extends PreEncashments
    with TableInfo<$PreEncashmentsTable, PreEncashment> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PreEncashmentsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _guidMeta = const VerificationMeta('guid');
  @override
  late final GeneratedColumn<String> guid = GeneratedColumn<String>(
      'guid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _timestampMeta =
      const VerificationMeta('timestamp');
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
      'timestamp', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _currentTimestampMeta =
      const VerificationMeta('currentTimestamp');
  @override
  late final GeneratedColumn<DateTime> currentTimestamp =
      GeneratedColumn<DateTime>('current_timestamp', aliasedName, false,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          defaultValue: currentDateAndTime);
  static const VerificationMeta _lastSyncTimeMeta =
      const VerificationMeta('lastSyncTime');
  @override
  late final GeneratedColumn<DateTime> lastSyncTime = GeneratedColumn<DateTime>(
      'last_sync_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _needSyncMeta =
      const VerificationMeta('needSync');
  @override
  late final GeneratedColumn<bool> needSync = GeneratedColumn<bool>(
      'need_sync', aliasedName, false,
      generatedAs: GeneratedAs(
          (isNew & BooleanExpressionOperators(isDeleted).not()) |
              (BooleanExpressionOperators(isNew).not() &
                  ComparableExpr(lastSyncTime).isSmallerThan(timestamp)),
          true),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("need_sync" IN (0, 1))'));
  static const VerificationMeta _isNewMeta = const VerificationMeta('isNew');
  @override
  late final GeneratedColumn<bool> isNew = GeneratedColumn<bool>(
      'is_new', aliasedName, false,
      generatedAs: GeneratedAs(lastSyncTime.isNull(), false),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_new" IN (0, 1))'));
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
      'date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _needReceiptMeta =
      const VerificationMeta('needReceipt');
  @override
  late final GeneratedColumn<bool> needReceipt = GeneratedColumn<bool>(
      'need_receipt', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("need_receipt" IN (0, 1))'));
  static const VerificationMeta _debtIdMeta = const VerificationMeta('debtId');
  @override
  late final GeneratedColumn<int> debtId = GeneratedColumn<int>(
      'debt_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _buyerIdMeta =
      const VerificationMeta('buyerId');
  @override
  late final GeneratedColumn<int> buyerId = GeneratedColumn<int>(
      'buyer_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _infoMeta = const VerificationMeta('info');
  @override
  late final GeneratedColumn<String> info = GeneratedColumn<String>(
      'info', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _encSumMeta = const VerificationMeta('encSum');
  @override
  late final GeneratedColumn<double> encSum = GeneratedColumn<double>(
      'enc_sum', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        guid,
        isDeleted,
        timestamp,
        currentTimestamp,
        lastSyncTime,
        needSync,
        isNew,
        id,
        date,
        needReceipt,
        debtId,
        buyerId,
        info,
        encSum
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'pre_encashments';
  @override
  VerificationContext validateIntegrity(Insertable<PreEncashment> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('guid')) {
      context.handle(
          _guidMeta, guid.isAcceptableOrUnknown(data['guid']!, _guidMeta));
    } else if (isInserting) {
      context.missing(_guidMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('timestamp')) {
      context.handle(_timestampMeta,
          timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta));
    }
    if (data.containsKey('current_timestamp')) {
      context.handle(
          _currentTimestampMeta,
          currentTimestamp.isAcceptableOrUnknown(
              data['current_timestamp']!, _currentTimestampMeta));
    }
    if (data.containsKey('last_sync_time')) {
      context.handle(
          _lastSyncTimeMeta,
          lastSyncTime.isAcceptableOrUnknown(
              data['last_sync_time']!, _lastSyncTimeMeta));
    }
    if (data.containsKey('need_sync')) {
      context.handle(_needSyncMeta,
          needSync.isAcceptableOrUnknown(data['need_sync']!, _needSyncMeta));
    }
    if (data.containsKey('is_new')) {
      context.handle(
          _isNewMeta, isNew.isAcceptableOrUnknown(data['is_new']!, _isNewMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('date')) {
      context.handle(
          _dateMeta, date.isAcceptableOrUnknown(data['date']!, _dateMeta));
    } else if (isInserting) {
      context.missing(_dateMeta);
    }
    if (data.containsKey('need_receipt')) {
      context.handle(
          _needReceiptMeta,
          needReceipt.isAcceptableOrUnknown(
              data['need_receipt']!, _needReceiptMeta));
    } else if (isInserting) {
      context.missing(_needReceiptMeta);
    }
    if (data.containsKey('debt_id')) {
      context.handle(_debtIdMeta,
          debtId.isAcceptableOrUnknown(data['debt_id']!, _debtIdMeta));
    } else if (isInserting) {
      context.missing(_debtIdMeta);
    }
    if (data.containsKey('buyer_id')) {
      context.handle(_buyerIdMeta,
          buyerId.isAcceptableOrUnknown(data['buyer_id']!, _buyerIdMeta));
    } else if (isInserting) {
      context.missing(_buyerIdMeta);
    }
    if (data.containsKey('info')) {
      context.handle(
          _infoMeta, info.isAcceptableOrUnknown(data['info']!, _infoMeta));
    }
    if (data.containsKey('enc_sum')) {
      context.handle(_encSumMeta,
          encSum.isAcceptableOrUnknown(data['enc_sum']!, _encSumMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {guid};
  @override
  PreEncashment map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PreEncashment(
      guid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}guid'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      timestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}timestamp'])!,
      currentTimestamp: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}current_timestamp'])!,
      lastSyncTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_sync_time']),
      needSync: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_sync'])!,
      isNew: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_new'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id']),
      date: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}date'])!,
      needReceipt: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_receipt'])!,
      debtId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}debt_id'])!,
      buyerId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}buyer_id'])!,
      info: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}info']),
      encSum: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}enc_sum']),
    );
  }

  @override
  $PreEncashmentsTable createAlias(String alias) {
    return $PreEncashmentsTable(attachedDatabase, alias);
  }
}

class PreEncashment extends DataClass implements Insertable<PreEncashment> {
  final String guid;
  final bool isDeleted;
  final DateTime timestamp;
  final DateTime currentTimestamp;
  final DateTime? lastSyncTime;
  final bool needSync;
  final bool isNew;
  final int? id;
  final DateTime date;
  final bool needReceipt;
  final int debtId;
  final int buyerId;
  final String? info;
  final double? encSum;
  const PreEncashment(
      {required this.guid,
      required this.isDeleted,
      required this.timestamp,
      required this.currentTimestamp,
      this.lastSyncTime,
      required this.needSync,
      required this.isNew,
      this.id,
      required this.date,
      required this.needReceipt,
      required this.debtId,
      required this.buyerId,
      this.info,
      this.encSum});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['guid'] = Variable<String>(guid);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['timestamp'] = Variable<DateTime>(timestamp);
    map['current_timestamp'] = Variable<DateTime>(currentTimestamp);
    if (!nullToAbsent || lastSyncTime != null) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    map['date'] = Variable<DateTime>(date);
    map['need_receipt'] = Variable<bool>(needReceipt);
    map['debt_id'] = Variable<int>(debtId);
    map['buyer_id'] = Variable<int>(buyerId);
    if (!nullToAbsent || info != null) {
      map['info'] = Variable<String>(info);
    }
    if (!nullToAbsent || encSum != null) {
      map['enc_sum'] = Variable<double>(encSum);
    }
    return map;
  }

  PreEncashmentsCompanion toCompanion(bool nullToAbsent) {
    return PreEncashmentsCompanion(
      guid: Value(guid),
      isDeleted: Value(isDeleted),
      timestamp: Value(timestamp),
      currentTimestamp: Value(currentTimestamp),
      lastSyncTime: lastSyncTime == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncTime),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      date: Value(date),
      needReceipt: Value(needReceipt),
      debtId: Value(debtId),
      buyerId: Value(buyerId),
      info: info == null && nullToAbsent ? const Value.absent() : Value(info),
      encSum:
          encSum == null && nullToAbsent ? const Value.absent() : Value(encSum),
    );
  }

  factory PreEncashment.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PreEncashment(
      guid: serializer.fromJson<String>(json['guid']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      currentTimestamp: serializer.fromJson<DateTime>(json['currentTimestamp']),
      lastSyncTime: serializer.fromJson<DateTime?>(json['lastSyncTime']),
      needSync: serializer.fromJson<bool>(json['needSync']),
      isNew: serializer.fromJson<bool>(json['isNew']),
      id: serializer.fromJson<int?>(json['id']),
      date: serializer.fromJson<DateTime>(json['date']),
      needReceipt: serializer.fromJson<bool>(json['needReceipt']),
      debtId: serializer.fromJson<int>(json['debtId']),
      buyerId: serializer.fromJson<int>(json['buyerId']),
      info: serializer.fromJson<String?>(json['info']),
      encSum: serializer.fromJson<double?>(json['encSum']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'guid': serializer.toJson<String>(guid),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'currentTimestamp': serializer.toJson<DateTime>(currentTimestamp),
      'lastSyncTime': serializer.toJson<DateTime?>(lastSyncTime),
      'needSync': serializer.toJson<bool>(needSync),
      'isNew': serializer.toJson<bool>(isNew),
      'id': serializer.toJson<int?>(id),
      'date': serializer.toJson<DateTime>(date),
      'needReceipt': serializer.toJson<bool>(needReceipt),
      'debtId': serializer.toJson<int>(debtId),
      'buyerId': serializer.toJson<int>(buyerId),
      'info': serializer.toJson<String?>(info),
      'encSum': serializer.toJson<double?>(encSum),
    };
  }

  PreEncashment copyWith(
          {String? guid,
          bool? isDeleted,
          DateTime? timestamp,
          DateTime? currentTimestamp,
          Value<DateTime?> lastSyncTime = const Value.absent(),
          bool? needSync,
          bool? isNew,
          Value<int?> id = const Value.absent(),
          DateTime? date,
          bool? needReceipt,
          int? debtId,
          int? buyerId,
          Value<String?> info = const Value.absent(),
          Value<double?> encSum = const Value.absent()}) =>
      PreEncashment(
        guid: guid ?? this.guid,
        isDeleted: isDeleted ?? this.isDeleted,
        timestamp: timestamp ?? this.timestamp,
        currentTimestamp: currentTimestamp ?? this.currentTimestamp,
        lastSyncTime:
            lastSyncTime.present ? lastSyncTime.value : this.lastSyncTime,
        needSync: needSync ?? this.needSync,
        isNew: isNew ?? this.isNew,
        id: id.present ? id.value : this.id,
        date: date ?? this.date,
        needReceipt: needReceipt ?? this.needReceipt,
        debtId: debtId ?? this.debtId,
        buyerId: buyerId ?? this.buyerId,
        info: info.present ? info.value : this.info,
        encSum: encSum.present ? encSum.value : this.encSum,
      );
  @override
  String toString() {
    return (StringBuffer('PreEncashment(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('needSync: $needSync, ')
          ..write('isNew: $isNew, ')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('needReceipt: $needReceipt, ')
          ..write('debtId: $debtId, ')
          ..write('buyerId: $buyerId, ')
          ..write('info: $info, ')
          ..write('encSum: $encSum')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      guid,
      isDeleted,
      timestamp,
      currentTimestamp,
      lastSyncTime,
      needSync,
      isNew,
      id,
      date,
      needReceipt,
      debtId,
      buyerId,
      info,
      encSum);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PreEncashment &&
          other.guid == this.guid &&
          other.isDeleted == this.isDeleted &&
          other.timestamp == this.timestamp &&
          other.currentTimestamp == this.currentTimestamp &&
          other.lastSyncTime == this.lastSyncTime &&
          other.needSync == this.needSync &&
          other.isNew == this.isNew &&
          other.id == this.id &&
          other.date == this.date &&
          other.needReceipt == this.needReceipt &&
          other.debtId == this.debtId &&
          other.buyerId == this.buyerId &&
          other.info == this.info &&
          other.encSum == this.encSum);
}

class PreEncashmentsCompanion extends UpdateCompanion<PreEncashment> {
  final Value<String> guid;
  final Value<bool> isDeleted;
  final Value<DateTime> timestamp;
  final Value<DateTime> currentTimestamp;
  final Value<DateTime?> lastSyncTime;
  final Value<int?> id;
  final Value<DateTime> date;
  final Value<bool> needReceipt;
  final Value<int> debtId;
  final Value<int> buyerId;
  final Value<String?> info;
  final Value<double?> encSum;
  final Value<int> rowid;
  const PreEncashmentsCompanion({
    this.guid = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    this.date = const Value.absent(),
    this.needReceipt = const Value.absent(),
    this.debtId = const Value.absent(),
    this.buyerId = const Value.absent(),
    this.info = const Value.absent(),
    this.encSum = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PreEncashmentsCompanion.insert({
    required String guid,
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    required DateTime date,
    required bool needReceipt,
    required int debtId,
    required int buyerId,
    this.info = const Value.absent(),
    this.encSum = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : guid = Value(guid),
        date = Value(date),
        needReceipt = Value(needReceipt),
        debtId = Value(debtId),
        buyerId = Value(buyerId);
  static Insertable<PreEncashment> custom({
    Expression<String>? guid,
    Expression<bool>? isDeleted,
    Expression<DateTime>? timestamp,
    Expression<DateTime>? currentTimestamp,
    Expression<DateTime>? lastSyncTime,
    Expression<int>? id,
    Expression<DateTime>? date,
    Expression<bool>? needReceipt,
    Expression<int>? debtId,
    Expression<int>? buyerId,
    Expression<String>? info,
    Expression<double>? encSum,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (guid != null) 'guid': guid,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (timestamp != null) 'timestamp': timestamp,
      if (currentTimestamp != null) 'current_timestamp': currentTimestamp,
      if (lastSyncTime != null) 'last_sync_time': lastSyncTime,
      if (id != null) 'id': id,
      if (date != null) 'date': date,
      if (needReceipt != null) 'need_receipt': needReceipt,
      if (debtId != null) 'debt_id': debtId,
      if (buyerId != null) 'buyer_id': buyerId,
      if (info != null) 'info': info,
      if (encSum != null) 'enc_sum': encSum,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PreEncashmentsCompanion copyWith(
      {Value<String>? guid,
      Value<bool>? isDeleted,
      Value<DateTime>? timestamp,
      Value<DateTime>? currentTimestamp,
      Value<DateTime?>? lastSyncTime,
      Value<int?>? id,
      Value<DateTime>? date,
      Value<bool>? needReceipt,
      Value<int>? debtId,
      Value<int>? buyerId,
      Value<String?>? info,
      Value<double?>? encSum,
      Value<int>? rowid}) {
    return PreEncashmentsCompanion(
      guid: guid ?? this.guid,
      isDeleted: isDeleted ?? this.isDeleted,
      timestamp: timestamp ?? this.timestamp,
      currentTimestamp: currentTimestamp ?? this.currentTimestamp,
      lastSyncTime: lastSyncTime ?? this.lastSyncTime,
      id: id ?? this.id,
      date: date ?? this.date,
      needReceipt: needReceipt ?? this.needReceipt,
      debtId: debtId ?? this.debtId,
      buyerId: buyerId ?? this.buyerId,
      info: info ?? this.info,
      encSum: encSum ?? this.encSum,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (guid.present) {
      map['guid'] = Variable<String>(guid.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (currentTimestamp.present) {
      map['current_timestamp'] = Variable<DateTime>(currentTimestamp.value);
    }
    if (lastSyncTime.present) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (needReceipt.present) {
      map['need_receipt'] = Variable<bool>(needReceipt.value);
    }
    if (debtId.present) {
      map['debt_id'] = Variable<int>(debtId.value);
    }
    if (buyerId.present) {
      map['buyer_id'] = Variable<int>(buyerId.value);
    }
    if (info.present) {
      map['info'] = Variable<String>(info.value);
    }
    if (encSum.present) {
      map['enc_sum'] = Variable<double>(encSum.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PreEncashmentsCompanion(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('needReceipt: $needReceipt, ')
          ..write('debtId: $debtId, ')
          ..write('buyerId: $buyerId, ')
          ..write('info: $info, ')
          ..write('encSum: $encSum, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $DebtsTable extends Debts with TableInfo<$DebtsTable, Debt> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DebtsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
      'date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _buyerIdMeta =
      const VerificationMeta('buyerId');
  @override
  late final GeneratedColumn<int> buyerId = GeneratedColumn<int>(
      'buyer_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _infoMeta = const VerificationMeta('info');
  @override
  late final GeneratedColumn<String> info = GeneratedColumn<String>(
      'info', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _debtSumMeta =
      const VerificationMeta('debtSum');
  @override
  late final GeneratedColumn<double> debtSum = GeneratedColumn<double>(
      'debt_sum', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _orderSumMeta =
      const VerificationMeta('orderSum');
  @override
  late final GeneratedColumn<double> orderSum = GeneratedColumn<double>(
      'order_sum', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _needReceiptMeta =
      const VerificationMeta('needReceipt');
  @override
  late final GeneratedColumn<bool> needReceipt = GeneratedColumn<bool>(
      'need_receipt', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("need_receipt" IN (0, 1))'));
  static const VerificationMeta _dateUntilMeta =
      const VerificationMeta('dateUntil');
  @override
  late final GeneratedColumn<DateTime> dateUntil = GeneratedColumn<DateTime>(
      'date_until', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _overdueMeta =
      const VerificationMeta('overdue');
  @override
  late final GeneratedColumn<bool> overdue = GeneratedColumn<bool>(
      'overdue', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("overdue" IN (0, 1))'));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        date,
        buyerId,
        info,
        debtSum,
        orderSum,
        needReceipt,
        dateUntil,
        overdue
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'debts';
  @override
  VerificationContext validateIntegrity(Insertable<Debt> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('date')) {
      context.handle(
          _dateMeta, date.isAcceptableOrUnknown(data['date']!, _dateMeta));
    } else if (isInserting) {
      context.missing(_dateMeta);
    }
    if (data.containsKey('buyer_id')) {
      context.handle(_buyerIdMeta,
          buyerId.isAcceptableOrUnknown(data['buyer_id']!, _buyerIdMeta));
    } else if (isInserting) {
      context.missing(_buyerIdMeta);
    }
    if (data.containsKey('info')) {
      context.handle(
          _infoMeta, info.isAcceptableOrUnknown(data['info']!, _infoMeta));
    }
    if (data.containsKey('debt_sum')) {
      context.handle(_debtSumMeta,
          debtSum.isAcceptableOrUnknown(data['debt_sum']!, _debtSumMeta));
    } else if (isInserting) {
      context.missing(_debtSumMeta);
    }
    if (data.containsKey('order_sum')) {
      context.handle(_orderSumMeta,
          orderSum.isAcceptableOrUnknown(data['order_sum']!, _orderSumMeta));
    } else if (isInserting) {
      context.missing(_orderSumMeta);
    }
    if (data.containsKey('need_receipt')) {
      context.handle(
          _needReceiptMeta,
          needReceipt.isAcceptableOrUnknown(
              data['need_receipt']!, _needReceiptMeta));
    } else if (isInserting) {
      context.missing(_needReceiptMeta);
    }
    if (data.containsKey('date_until')) {
      context.handle(_dateUntilMeta,
          dateUntil.isAcceptableOrUnknown(data['date_until']!, _dateUntilMeta));
    } else if (isInserting) {
      context.missing(_dateUntilMeta);
    }
    if (data.containsKey('overdue')) {
      context.handle(_overdueMeta,
          overdue.isAcceptableOrUnknown(data['overdue']!, _overdueMeta));
    } else if (isInserting) {
      context.missing(_overdueMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Debt map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Debt(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      date: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}date'])!,
      buyerId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}buyer_id'])!,
      info: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}info']),
      debtSum: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}debt_sum'])!,
      orderSum: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}order_sum'])!,
      needReceipt: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_receipt'])!,
      dateUntil: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}date_until'])!,
      overdue: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}overdue'])!,
    );
  }

  @override
  $DebtsTable createAlias(String alias) {
    return $DebtsTable(attachedDatabase, alias);
  }
}

class Debt extends DataClass implements Insertable<Debt> {
  final int id;
  final DateTime date;
  final int buyerId;
  final String? info;
  final double debtSum;
  final double orderSum;
  final bool needReceipt;
  final DateTime dateUntil;
  final bool overdue;
  const Debt(
      {required this.id,
      required this.date,
      required this.buyerId,
      this.info,
      required this.debtSum,
      required this.orderSum,
      required this.needReceipt,
      required this.dateUntil,
      required this.overdue});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['date'] = Variable<DateTime>(date);
    map['buyer_id'] = Variable<int>(buyerId);
    if (!nullToAbsent || info != null) {
      map['info'] = Variable<String>(info);
    }
    map['debt_sum'] = Variable<double>(debtSum);
    map['order_sum'] = Variable<double>(orderSum);
    map['need_receipt'] = Variable<bool>(needReceipt);
    map['date_until'] = Variable<DateTime>(dateUntil);
    map['overdue'] = Variable<bool>(overdue);
    return map;
  }

  DebtsCompanion toCompanion(bool nullToAbsent) {
    return DebtsCompanion(
      id: Value(id),
      date: Value(date),
      buyerId: Value(buyerId),
      info: info == null && nullToAbsent ? const Value.absent() : Value(info),
      debtSum: Value(debtSum),
      orderSum: Value(orderSum),
      needReceipt: Value(needReceipt),
      dateUntil: Value(dateUntil),
      overdue: Value(overdue),
    );
  }

  factory Debt.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Debt(
      id: serializer.fromJson<int>(json['id']),
      date: serializer.fromJson<DateTime>(json['date']),
      buyerId: serializer.fromJson<int>(json['buyerId']),
      info: serializer.fromJson<String?>(json['info']),
      debtSum: serializer.fromJson<double>(json['debtSum']),
      orderSum: serializer.fromJson<double>(json['orderSum']),
      needReceipt: serializer.fromJson<bool>(json['needReceipt']),
      dateUntil: serializer.fromJson<DateTime>(json['dateUntil']),
      overdue: serializer.fromJson<bool>(json['overdue']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'date': serializer.toJson<DateTime>(date),
      'buyerId': serializer.toJson<int>(buyerId),
      'info': serializer.toJson<String?>(info),
      'debtSum': serializer.toJson<double>(debtSum),
      'orderSum': serializer.toJson<double>(orderSum),
      'needReceipt': serializer.toJson<bool>(needReceipt),
      'dateUntil': serializer.toJson<DateTime>(dateUntil),
      'overdue': serializer.toJson<bool>(overdue),
    };
  }

  Debt copyWith(
          {int? id,
          DateTime? date,
          int? buyerId,
          Value<String?> info = const Value.absent(),
          double? debtSum,
          double? orderSum,
          bool? needReceipt,
          DateTime? dateUntil,
          bool? overdue}) =>
      Debt(
        id: id ?? this.id,
        date: date ?? this.date,
        buyerId: buyerId ?? this.buyerId,
        info: info.present ? info.value : this.info,
        debtSum: debtSum ?? this.debtSum,
        orderSum: orderSum ?? this.orderSum,
        needReceipt: needReceipt ?? this.needReceipt,
        dateUntil: dateUntil ?? this.dateUntil,
        overdue: overdue ?? this.overdue,
      );
  Debt copyWithCompanion(DebtsCompanion data) {
    return Debt(
      id: data.id.present ? data.id.value : this.id,
      date: data.date.present ? data.date.value : this.date,
      buyerId: data.buyerId.present ? data.buyerId.value : this.buyerId,
      info: data.info.present ? data.info.value : this.info,
      debtSum: data.debtSum.present ? data.debtSum.value : this.debtSum,
      orderSum: data.orderSum.present ? data.orderSum.value : this.orderSum,
      needReceipt:
          data.needReceipt.present ? data.needReceipt.value : this.needReceipt,
      dateUntil: data.dateUntil.present ? data.dateUntil.value : this.dateUntil,
      overdue: data.overdue.present ? data.overdue.value : this.overdue,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Debt(')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('buyerId: $buyerId, ')
          ..write('info: $info, ')
          ..write('debtSum: $debtSum, ')
          ..write('orderSum: $orderSum, ')
          ..write('needReceipt: $needReceipt, ')
          ..write('dateUntil: $dateUntil, ')
          ..write('overdue: $overdue')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, date, buyerId, info, debtSum, orderSum,
      needReceipt, dateUntil, overdue);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Debt &&
          other.id == this.id &&
          other.date == this.date &&
          other.buyerId == this.buyerId &&
          other.info == this.info &&
          other.debtSum == this.debtSum &&
          other.orderSum == this.orderSum &&
          other.needReceipt == this.needReceipt &&
          other.dateUntil == this.dateUntil &&
          other.overdue == this.overdue);
}

class DebtsCompanion extends UpdateCompanion<Debt> {
  final Value<int> id;
  final Value<DateTime> date;
  final Value<int> buyerId;
  final Value<String?> info;
  final Value<double> debtSum;
  final Value<double> orderSum;
  final Value<bool> needReceipt;
  final Value<DateTime> dateUntil;
  final Value<bool> overdue;
  const DebtsCompanion({
    this.id = const Value.absent(),
    this.date = const Value.absent(),
    this.buyerId = const Value.absent(),
    this.info = const Value.absent(),
    this.debtSum = const Value.absent(),
    this.orderSum = const Value.absent(),
    this.needReceipt = const Value.absent(),
    this.dateUntil = const Value.absent(),
    this.overdue = const Value.absent(),
  });
  DebtsCompanion.insert({
    this.id = const Value.absent(),
    required DateTime date,
    required int buyerId,
    this.info = const Value.absent(),
    required double debtSum,
    required double orderSum,
    required bool needReceipt,
    required DateTime dateUntil,
    required bool overdue,
  })  : date = Value(date),
        buyerId = Value(buyerId),
        debtSum = Value(debtSum),
        orderSum = Value(orderSum),
        needReceipt = Value(needReceipt),
        dateUntil = Value(dateUntil),
        overdue = Value(overdue);
  static Insertable<Debt> custom({
    Expression<int>? id,
    Expression<DateTime>? date,
    Expression<int>? buyerId,
    Expression<String>? info,
    Expression<double>? debtSum,
    Expression<double>? orderSum,
    Expression<bool>? needReceipt,
    Expression<DateTime>? dateUntil,
    Expression<bool>? overdue,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (date != null) 'date': date,
      if (buyerId != null) 'buyer_id': buyerId,
      if (info != null) 'info': info,
      if (debtSum != null) 'debt_sum': debtSum,
      if (orderSum != null) 'order_sum': orderSum,
      if (needReceipt != null) 'need_receipt': needReceipt,
      if (dateUntil != null) 'date_until': dateUntil,
      if (overdue != null) 'overdue': overdue,
    });
  }

  DebtsCompanion copyWith(
      {Value<int>? id,
      Value<DateTime>? date,
      Value<int>? buyerId,
      Value<String?>? info,
      Value<double>? debtSum,
      Value<double>? orderSum,
      Value<bool>? needReceipt,
      Value<DateTime>? dateUntil,
      Value<bool>? overdue}) {
    return DebtsCompanion(
      id: id ?? this.id,
      date: date ?? this.date,
      buyerId: buyerId ?? this.buyerId,
      info: info ?? this.info,
      debtSum: debtSum ?? this.debtSum,
      orderSum: orderSum ?? this.orderSum,
      needReceipt: needReceipt ?? this.needReceipt,
      dateUntil: dateUntil ?? this.dateUntil,
      overdue: overdue ?? this.overdue,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (buyerId.present) {
      map['buyer_id'] = Variable<int>(buyerId.value);
    }
    if (info.present) {
      map['info'] = Variable<String>(info.value);
    }
    if (debtSum.present) {
      map['debt_sum'] = Variable<double>(debtSum.value);
    }
    if (orderSum.present) {
      map['order_sum'] = Variable<double>(orderSum.value);
    }
    if (needReceipt.present) {
      map['need_receipt'] = Variable<bool>(needReceipt.value);
    }
    if (dateUntil.present) {
      map['date_until'] = Variable<DateTime>(dateUntil.value);
    }
    if (overdue.present) {
      map['overdue'] = Variable<bool>(overdue.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DebtsCompanion(')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('buyerId: $buyerId, ')
          ..write('info: $info, ')
          ..write('debtSum: $debtSum, ')
          ..write('orderSum: $orderSum, ')
          ..write('needReceipt: $needReceipt, ')
          ..write('dateUntil: $dateUntil, ')
          ..write('overdue: $overdue')
          ..write(')'))
        .toString();
  }
}

class $DepositsTable extends Deposits with TableInfo<$DepositsTable, Deposit> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DepositsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
      'date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _totalSumMeta =
      const VerificationMeta('totalSum');
  @override
  late final GeneratedColumn<double> totalSum = GeneratedColumn<double>(
      'total_sum', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _checkTotalSumMeta =
      const VerificationMeta('checkTotalSum');
  @override
  late final GeneratedColumn<double> checkTotalSum = GeneratedColumn<double>(
      'check_total_sum', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [id, date, totalSum, checkTotalSum];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'deposits';
  @override
  VerificationContext validateIntegrity(Insertable<Deposit> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('date')) {
      context.handle(
          _dateMeta, date.isAcceptableOrUnknown(data['date']!, _dateMeta));
    } else if (isInserting) {
      context.missing(_dateMeta);
    }
    if (data.containsKey('total_sum')) {
      context.handle(_totalSumMeta,
          totalSum.isAcceptableOrUnknown(data['total_sum']!, _totalSumMeta));
    } else if (isInserting) {
      context.missing(_totalSumMeta);
    }
    if (data.containsKey('check_total_sum')) {
      context.handle(
          _checkTotalSumMeta,
          checkTotalSum.isAcceptableOrUnknown(
              data['check_total_sum']!, _checkTotalSumMeta));
    } else if (isInserting) {
      context.missing(_checkTotalSumMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => const {};
  @override
  Deposit map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Deposit(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      date: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}date'])!,
      totalSum: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}total_sum'])!,
      checkTotalSum: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}check_total_sum'])!,
    );
  }

  @override
  $DepositsTable createAlias(String alias) {
    return $DepositsTable(attachedDatabase, alias);
  }
}

class Deposit extends DataClass implements Insertable<Deposit> {
  final int id;
  final DateTime date;
  final double totalSum;
  final double checkTotalSum;
  const Deposit(
      {required this.id,
      required this.date,
      required this.totalSum,
      required this.checkTotalSum});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['date'] = Variable<DateTime>(date);
    map['total_sum'] = Variable<double>(totalSum);
    map['check_total_sum'] = Variable<double>(checkTotalSum);
    return map;
  }

  DepositsCompanion toCompanion(bool nullToAbsent) {
    return DepositsCompanion(
      id: Value(id),
      date: Value(date),
      totalSum: Value(totalSum),
      checkTotalSum: Value(checkTotalSum),
    );
  }

  factory Deposit.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Deposit(
      id: serializer.fromJson<int>(json['id']),
      date: serializer.fromJson<DateTime>(json['date']),
      totalSum: serializer.fromJson<double>(json['totalSum']),
      checkTotalSum: serializer.fromJson<double>(json['checkTotalSum']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'date': serializer.toJson<DateTime>(date),
      'totalSum': serializer.toJson<double>(totalSum),
      'checkTotalSum': serializer.toJson<double>(checkTotalSum),
    };
  }

  Deposit copyWith(
          {int? id, DateTime? date, double? totalSum, double? checkTotalSum}) =>
      Deposit(
        id: id ?? this.id,
        date: date ?? this.date,
        totalSum: totalSum ?? this.totalSum,
        checkTotalSum: checkTotalSum ?? this.checkTotalSum,
      );
  Deposit copyWithCompanion(DepositsCompanion data) {
    return Deposit(
      id: data.id.present ? data.id.value : this.id,
      date: data.date.present ? data.date.value : this.date,
      totalSum: data.totalSum.present ? data.totalSum.value : this.totalSum,
      checkTotalSum: data.checkTotalSum.present
          ? data.checkTotalSum.value
          : this.checkTotalSum,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Deposit(')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('totalSum: $totalSum, ')
          ..write('checkTotalSum: $checkTotalSum')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, date, totalSum, checkTotalSum);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Deposit &&
          other.id == this.id &&
          other.date == this.date &&
          other.totalSum == this.totalSum &&
          other.checkTotalSum == this.checkTotalSum);
}

class DepositsCompanion extends UpdateCompanion<Deposit> {
  final Value<int> id;
  final Value<DateTime> date;
  final Value<double> totalSum;
  final Value<double> checkTotalSum;
  final Value<int> rowid;
  const DepositsCompanion({
    this.id = const Value.absent(),
    this.date = const Value.absent(),
    this.totalSum = const Value.absent(),
    this.checkTotalSum = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  DepositsCompanion.insert({
    required int id,
    required DateTime date,
    required double totalSum,
    required double checkTotalSum,
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        date = Value(date),
        totalSum = Value(totalSum),
        checkTotalSum = Value(checkTotalSum);
  static Insertable<Deposit> custom({
    Expression<int>? id,
    Expression<DateTime>? date,
    Expression<double>? totalSum,
    Expression<double>? checkTotalSum,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (date != null) 'date': date,
      if (totalSum != null) 'total_sum': totalSum,
      if (checkTotalSum != null) 'check_total_sum': checkTotalSum,
      if (rowid != null) 'rowid': rowid,
    });
  }

  DepositsCompanion copyWith(
      {Value<int>? id,
      Value<DateTime>? date,
      Value<double>? totalSum,
      Value<double>? checkTotalSum,
      Value<int>? rowid}) {
    return DepositsCompanion(
      id: id ?? this.id,
      date: date ?? this.date,
      totalSum: totalSum ?? this.totalSum,
      checkTotalSum: checkTotalSum ?? this.checkTotalSum,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (totalSum.present) {
      map['total_sum'] = Variable<double>(totalSum.value);
    }
    if (checkTotalSum.present) {
      map['check_total_sum'] = Variable<double>(checkTotalSum.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DepositsCompanion(')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('totalSum: $totalSum, ')
          ..write('checkTotalSum: $checkTotalSum, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ShipmentsTable extends Shipments
    with TableInfo<$ShipmentsTable, Shipment> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ShipmentsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
      'date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _ndocMeta = const VerificationMeta('ndoc');
  @override
  late final GeneratedColumn<String> ndoc = GeneratedColumn<String>(
      'ndoc', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _infoMeta = const VerificationMeta('info');
  @override
  late final GeneratedColumn<String> info = GeneratedColumn<String>(
      'info', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _debtSumMeta =
      const VerificationMeta('debtSum');
  @override
  late final GeneratedColumn<double> debtSum = GeneratedColumn<double>(
      'debt_sum', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _shipmentSumMeta =
      const VerificationMeta('shipmentSum');
  @override
  late final GeneratedColumn<double> shipmentSum = GeneratedColumn<double>(
      'shipment_sum', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _buyerIdMeta =
      const VerificationMeta('buyerId');
  @override
  late final GeneratedColumn<int> buyerId = GeneratedColumn<int>(
      'buyer_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [id, date, ndoc, info, status, debtSum, shipmentSum, buyerId];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'shipments';
  @override
  VerificationContext validateIntegrity(Insertable<Shipment> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('date')) {
      context.handle(
          _dateMeta, date.isAcceptableOrUnknown(data['date']!, _dateMeta));
    } else if (isInserting) {
      context.missing(_dateMeta);
    }
    if (data.containsKey('ndoc')) {
      context.handle(
          _ndocMeta, ndoc.isAcceptableOrUnknown(data['ndoc']!, _ndocMeta));
    } else if (isInserting) {
      context.missing(_ndocMeta);
    }
    if (data.containsKey('info')) {
      context.handle(
          _infoMeta, info.isAcceptableOrUnknown(data['info']!, _infoMeta));
    } else if (isInserting) {
      context.missing(_infoMeta);
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    } else if (isInserting) {
      context.missing(_statusMeta);
    }
    if (data.containsKey('debt_sum')) {
      context.handle(_debtSumMeta,
          debtSum.isAcceptableOrUnknown(data['debt_sum']!, _debtSumMeta));
    }
    if (data.containsKey('shipment_sum')) {
      context.handle(
          _shipmentSumMeta,
          shipmentSum.isAcceptableOrUnknown(
              data['shipment_sum']!, _shipmentSumMeta));
    } else if (isInserting) {
      context.missing(_shipmentSumMeta);
    }
    if (data.containsKey('buyer_id')) {
      context.handle(_buyerIdMeta,
          buyerId.isAcceptableOrUnknown(data['buyer_id']!, _buyerIdMeta));
    } else if (isInserting) {
      context.missing(_buyerIdMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Shipment map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Shipment(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      date: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}date'])!,
      ndoc: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}ndoc'])!,
      info: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}info'])!,
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      debtSum: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}debt_sum']),
      shipmentSum: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}shipment_sum'])!,
      buyerId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}buyer_id'])!,
    );
  }

  @override
  $ShipmentsTable createAlias(String alias) {
    return $ShipmentsTable(attachedDatabase, alias);
  }
}

class Shipment extends DataClass implements Insertable<Shipment> {
  final int id;
  final DateTime date;
  final String ndoc;
  final String info;
  final String status;
  final double? debtSum;
  final double shipmentSum;
  final int buyerId;
  const Shipment(
      {required this.id,
      required this.date,
      required this.ndoc,
      required this.info,
      required this.status,
      this.debtSum,
      required this.shipmentSum,
      required this.buyerId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['date'] = Variable<DateTime>(date);
    map['ndoc'] = Variable<String>(ndoc);
    map['info'] = Variable<String>(info);
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || debtSum != null) {
      map['debt_sum'] = Variable<double>(debtSum);
    }
    map['shipment_sum'] = Variable<double>(shipmentSum);
    map['buyer_id'] = Variable<int>(buyerId);
    return map;
  }

  ShipmentsCompanion toCompanion(bool nullToAbsent) {
    return ShipmentsCompanion(
      id: Value(id),
      date: Value(date),
      ndoc: Value(ndoc),
      info: Value(info),
      status: Value(status),
      debtSum: debtSum == null && nullToAbsent
          ? const Value.absent()
          : Value(debtSum),
      shipmentSum: Value(shipmentSum),
      buyerId: Value(buyerId),
    );
  }

  factory Shipment.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Shipment(
      id: serializer.fromJson<int>(json['id']),
      date: serializer.fromJson<DateTime>(json['date']),
      ndoc: serializer.fromJson<String>(json['ndoc']),
      info: serializer.fromJson<String>(json['info']),
      status: serializer.fromJson<String>(json['status']),
      debtSum: serializer.fromJson<double?>(json['debtSum']),
      shipmentSum: serializer.fromJson<double>(json['shipmentSum']),
      buyerId: serializer.fromJson<int>(json['buyerId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'date': serializer.toJson<DateTime>(date),
      'ndoc': serializer.toJson<String>(ndoc),
      'info': serializer.toJson<String>(info),
      'status': serializer.toJson<String>(status),
      'debtSum': serializer.toJson<double?>(debtSum),
      'shipmentSum': serializer.toJson<double>(shipmentSum),
      'buyerId': serializer.toJson<int>(buyerId),
    };
  }

  Shipment copyWith(
          {int? id,
          DateTime? date,
          String? ndoc,
          String? info,
          String? status,
          Value<double?> debtSum = const Value.absent(),
          double? shipmentSum,
          int? buyerId}) =>
      Shipment(
        id: id ?? this.id,
        date: date ?? this.date,
        ndoc: ndoc ?? this.ndoc,
        info: info ?? this.info,
        status: status ?? this.status,
        debtSum: debtSum.present ? debtSum.value : this.debtSum,
        shipmentSum: shipmentSum ?? this.shipmentSum,
        buyerId: buyerId ?? this.buyerId,
      );
  Shipment copyWithCompanion(ShipmentsCompanion data) {
    return Shipment(
      id: data.id.present ? data.id.value : this.id,
      date: data.date.present ? data.date.value : this.date,
      ndoc: data.ndoc.present ? data.ndoc.value : this.ndoc,
      info: data.info.present ? data.info.value : this.info,
      status: data.status.present ? data.status.value : this.status,
      debtSum: data.debtSum.present ? data.debtSum.value : this.debtSum,
      shipmentSum:
          data.shipmentSum.present ? data.shipmentSum.value : this.shipmentSum,
      buyerId: data.buyerId.present ? data.buyerId.value : this.buyerId,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Shipment(')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('ndoc: $ndoc, ')
          ..write('info: $info, ')
          ..write('status: $status, ')
          ..write('debtSum: $debtSum, ')
          ..write('shipmentSum: $shipmentSum, ')
          ..write('buyerId: $buyerId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, date, ndoc, info, status, debtSum, shipmentSum, buyerId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Shipment &&
          other.id == this.id &&
          other.date == this.date &&
          other.ndoc == this.ndoc &&
          other.info == this.info &&
          other.status == this.status &&
          other.debtSum == this.debtSum &&
          other.shipmentSum == this.shipmentSum &&
          other.buyerId == this.buyerId);
}

class ShipmentsCompanion extends UpdateCompanion<Shipment> {
  final Value<int> id;
  final Value<DateTime> date;
  final Value<String> ndoc;
  final Value<String> info;
  final Value<String> status;
  final Value<double?> debtSum;
  final Value<double> shipmentSum;
  final Value<int> buyerId;
  const ShipmentsCompanion({
    this.id = const Value.absent(),
    this.date = const Value.absent(),
    this.ndoc = const Value.absent(),
    this.info = const Value.absent(),
    this.status = const Value.absent(),
    this.debtSum = const Value.absent(),
    this.shipmentSum = const Value.absent(),
    this.buyerId = const Value.absent(),
  });
  ShipmentsCompanion.insert({
    this.id = const Value.absent(),
    required DateTime date,
    required String ndoc,
    required String info,
    required String status,
    this.debtSum = const Value.absent(),
    required double shipmentSum,
    required int buyerId,
  })  : date = Value(date),
        ndoc = Value(ndoc),
        info = Value(info),
        status = Value(status),
        shipmentSum = Value(shipmentSum),
        buyerId = Value(buyerId);
  static Insertable<Shipment> custom({
    Expression<int>? id,
    Expression<DateTime>? date,
    Expression<String>? ndoc,
    Expression<String>? info,
    Expression<String>? status,
    Expression<double>? debtSum,
    Expression<double>? shipmentSum,
    Expression<int>? buyerId,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (date != null) 'date': date,
      if (ndoc != null) 'ndoc': ndoc,
      if (info != null) 'info': info,
      if (status != null) 'status': status,
      if (debtSum != null) 'debt_sum': debtSum,
      if (shipmentSum != null) 'shipment_sum': shipmentSum,
      if (buyerId != null) 'buyer_id': buyerId,
    });
  }

  ShipmentsCompanion copyWith(
      {Value<int>? id,
      Value<DateTime>? date,
      Value<String>? ndoc,
      Value<String>? info,
      Value<String>? status,
      Value<double?>? debtSum,
      Value<double>? shipmentSum,
      Value<int>? buyerId}) {
    return ShipmentsCompanion(
      id: id ?? this.id,
      date: date ?? this.date,
      ndoc: ndoc ?? this.ndoc,
      info: info ?? this.info,
      status: status ?? this.status,
      debtSum: debtSum ?? this.debtSum,
      shipmentSum: shipmentSum ?? this.shipmentSum,
      buyerId: buyerId ?? this.buyerId,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (ndoc.present) {
      map['ndoc'] = Variable<String>(ndoc.value);
    }
    if (info.present) {
      map['info'] = Variable<String>(info.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (debtSum.present) {
      map['debt_sum'] = Variable<double>(debtSum.value);
    }
    if (shipmentSum.present) {
      map['shipment_sum'] = Variable<double>(shipmentSum.value);
    }
    if (buyerId.present) {
      map['buyer_id'] = Variable<int>(buyerId.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ShipmentsCompanion(')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('ndoc: $ndoc, ')
          ..write('info: $info, ')
          ..write('status: $status, ')
          ..write('debtSum: $debtSum, ')
          ..write('shipmentSum: $shipmentSum, ')
          ..write('buyerId: $buyerId')
          ..write(')'))
        .toString();
  }
}

class $ShipmentLinesTable extends ShipmentLines
    with TableInfo<$ShipmentLinesTable, ShipmentLine> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ShipmentLinesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _shipmentIdMeta =
      const VerificationMeta('shipmentId');
  @override
  late final GeneratedColumn<int> shipmentId = GeneratedColumn<int>(
      'shipment_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _goodsIdMeta =
      const VerificationMeta('goodsId');
  @override
  late final GeneratedColumn<int> goodsId = GeneratedColumn<int>(
      'goods_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _volMeta = const VerificationMeta('vol');
  @override
  late final GeneratedColumn<double> vol = GeneratedColumn<double>(
      'vol', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  @override
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
      'price', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [id, shipmentId, goodsId, vol, price];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'shipment_lines';
  @override
  VerificationContext validateIntegrity(Insertable<ShipmentLine> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('shipment_id')) {
      context.handle(
          _shipmentIdMeta,
          shipmentId.isAcceptableOrUnknown(
              data['shipment_id']!, _shipmentIdMeta));
    } else if (isInserting) {
      context.missing(_shipmentIdMeta);
    }
    if (data.containsKey('goods_id')) {
      context.handle(_goodsIdMeta,
          goodsId.isAcceptableOrUnknown(data['goods_id']!, _goodsIdMeta));
    } else if (isInserting) {
      context.missing(_goodsIdMeta);
    }
    if (data.containsKey('vol')) {
      context.handle(
          _volMeta, vol.isAcceptableOrUnknown(data['vol']!, _volMeta));
    } else if (isInserting) {
      context.missing(_volMeta);
    }
    if (data.containsKey('price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['price']!, _priceMeta));
    } else if (isInserting) {
      context.missing(_priceMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ShipmentLine map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ShipmentLine(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      shipmentId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}shipment_id'])!,
      goodsId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}goods_id'])!,
      vol: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}vol'])!,
      price: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}price'])!,
    );
  }

  @override
  $ShipmentLinesTable createAlias(String alias) {
    return $ShipmentLinesTable(attachedDatabase, alias);
  }
}

class ShipmentLine extends DataClass implements Insertable<ShipmentLine> {
  final int id;
  final int shipmentId;
  final int goodsId;
  final double vol;
  final double price;
  const ShipmentLine(
      {required this.id,
      required this.shipmentId,
      required this.goodsId,
      required this.vol,
      required this.price});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['shipment_id'] = Variable<int>(shipmentId);
    map['goods_id'] = Variable<int>(goodsId);
    map['vol'] = Variable<double>(vol);
    map['price'] = Variable<double>(price);
    return map;
  }

  ShipmentLinesCompanion toCompanion(bool nullToAbsent) {
    return ShipmentLinesCompanion(
      id: Value(id),
      shipmentId: Value(shipmentId),
      goodsId: Value(goodsId),
      vol: Value(vol),
      price: Value(price),
    );
  }

  factory ShipmentLine.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ShipmentLine(
      id: serializer.fromJson<int>(json['id']),
      shipmentId: serializer.fromJson<int>(json['shipmentId']),
      goodsId: serializer.fromJson<int>(json['goodsId']),
      vol: serializer.fromJson<double>(json['vol']),
      price: serializer.fromJson<double>(json['price']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'shipmentId': serializer.toJson<int>(shipmentId),
      'goodsId': serializer.toJson<int>(goodsId),
      'vol': serializer.toJson<double>(vol),
      'price': serializer.toJson<double>(price),
    };
  }

  ShipmentLine copyWith(
          {int? id,
          int? shipmentId,
          int? goodsId,
          double? vol,
          double? price}) =>
      ShipmentLine(
        id: id ?? this.id,
        shipmentId: shipmentId ?? this.shipmentId,
        goodsId: goodsId ?? this.goodsId,
        vol: vol ?? this.vol,
        price: price ?? this.price,
      );
  ShipmentLine copyWithCompanion(ShipmentLinesCompanion data) {
    return ShipmentLine(
      id: data.id.present ? data.id.value : this.id,
      shipmentId:
          data.shipmentId.present ? data.shipmentId.value : this.shipmentId,
      goodsId: data.goodsId.present ? data.goodsId.value : this.goodsId,
      vol: data.vol.present ? data.vol.value : this.vol,
      price: data.price.present ? data.price.value : this.price,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ShipmentLine(')
          ..write('id: $id, ')
          ..write('shipmentId: $shipmentId, ')
          ..write('goodsId: $goodsId, ')
          ..write('vol: $vol, ')
          ..write('price: $price')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, shipmentId, goodsId, vol, price);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ShipmentLine &&
          other.id == this.id &&
          other.shipmentId == this.shipmentId &&
          other.goodsId == this.goodsId &&
          other.vol == this.vol &&
          other.price == this.price);
}

class ShipmentLinesCompanion extends UpdateCompanion<ShipmentLine> {
  final Value<int> id;
  final Value<int> shipmentId;
  final Value<int> goodsId;
  final Value<double> vol;
  final Value<double> price;
  const ShipmentLinesCompanion({
    this.id = const Value.absent(),
    this.shipmentId = const Value.absent(),
    this.goodsId = const Value.absent(),
    this.vol = const Value.absent(),
    this.price = const Value.absent(),
  });
  ShipmentLinesCompanion.insert({
    this.id = const Value.absent(),
    required int shipmentId,
    required int goodsId,
    required double vol,
    required double price,
  })  : shipmentId = Value(shipmentId),
        goodsId = Value(goodsId),
        vol = Value(vol),
        price = Value(price);
  static Insertable<ShipmentLine> custom({
    Expression<int>? id,
    Expression<int>? shipmentId,
    Expression<int>? goodsId,
    Expression<double>? vol,
    Expression<double>? price,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (shipmentId != null) 'shipment_id': shipmentId,
      if (goodsId != null) 'goods_id': goodsId,
      if (vol != null) 'vol': vol,
      if (price != null) 'price': price,
    });
  }

  ShipmentLinesCompanion copyWith(
      {Value<int>? id,
      Value<int>? shipmentId,
      Value<int>? goodsId,
      Value<double>? vol,
      Value<double>? price}) {
    return ShipmentLinesCompanion(
      id: id ?? this.id,
      shipmentId: shipmentId ?? this.shipmentId,
      goodsId: goodsId ?? this.goodsId,
      vol: vol ?? this.vol,
      price: price ?? this.price,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (shipmentId.present) {
      map['shipment_id'] = Variable<int>(shipmentId.value);
    }
    if (goodsId.present) {
      map['goods_id'] = Variable<int>(goodsId.value);
    }
    if (vol.present) {
      map['vol'] = Variable<double>(vol.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ShipmentLinesCompanion(')
          ..write('id: $id, ')
          ..write('shipmentId: $shipmentId, ')
          ..write('goodsId: $goodsId, ')
          ..write('vol: $vol, ')
          ..write('price: $price')
          ..write(')'))
        .toString();
  }
}

class $IncRequestsTable extends IncRequests
    with TableInfo<$IncRequestsTable, IncRequest> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $IncRequestsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _guidMeta = const VerificationMeta('guid');
  @override
  late final GeneratedColumn<String> guid = GeneratedColumn<String>(
      'guid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _timestampMeta =
      const VerificationMeta('timestamp');
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
      'timestamp', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _currentTimestampMeta =
      const VerificationMeta('currentTimestamp');
  @override
  late final GeneratedColumn<DateTime> currentTimestamp =
      GeneratedColumn<DateTime>('current_timestamp', aliasedName, false,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          defaultValue: currentDateAndTime);
  static const VerificationMeta _lastSyncTimeMeta =
      const VerificationMeta('lastSyncTime');
  @override
  late final GeneratedColumn<DateTime> lastSyncTime = GeneratedColumn<DateTime>(
      'last_sync_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _needSyncMeta =
      const VerificationMeta('needSync');
  @override
  late final GeneratedColumn<bool> needSync = GeneratedColumn<bool>(
      'need_sync', aliasedName, false,
      generatedAs: GeneratedAs(
          (isNew & BooleanExpressionOperators(isDeleted).not()) |
              (BooleanExpressionOperators(isNew).not() &
                  ComparableExpr(lastSyncTime).isSmallerThan(timestamp)),
          true),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("need_sync" IN (0, 1))'));
  static const VerificationMeta _isNewMeta = const VerificationMeta('isNew');
  @override
  late final GeneratedColumn<bool> isNew = GeneratedColumn<bool>(
      'is_new', aliasedName, false,
      generatedAs: GeneratedAs(lastSyncTime.isNull(), false),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_new" IN (0, 1))'));
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
      'date', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _buyerIdMeta =
      const VerificationMeta('buyerId');
  @override
  late final GeneratedColumn<int> buyerId = GeneratedColumn<int>(
      'buyer_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _incSumMeta = const VerificationMeta('incSum');
  @override
  late final GeneratedColumn<double> incSum = GeneratedColumn<double>(
      'inc_sum', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _infoMeta = const VerificationMeta('info');
  @override
  late final GeneratedColumn<String> info = GeneratedColumn<String>(
      'info', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        guid,
        isDeleted,
        timestamp,
        currentTimestamp,
        lastSyncTime,
        needSync,
        isNew,
        id,
        date,
        buyerId,
        incSum,
        info,
        status
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'inc_requests';
  @override
  VerificationContext validateIntegrity(Insertable<IncRequest> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('guid')) {
      context.handle(
          _guidMeta, guid.isAcceptableOrUnknown(data['guid']!, _guidMeta));
    } else if (isInserting) {
      context.missing(_guidMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('timestamp')) {
      context.handle(_timestampMeta,
          timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta));
    }
    if (data.containsKey('current_timestamp')) {
      context.handle(
          _currentTimestampMeta,
          currentTimestamp.isAcceptableOrUnknown(
              data['current_timestamp']!, _currentTimestampMeta));
    }
    if (data.containsKey('last_sync_time')) {
      context.handle(
          _lastSyncTimeMeta,
          lastSyncTime.isAcceptableOrUnknown(
              data['last_sync_time']!, _lastSyncTimeMeta));
    }
    if (data.containsKey('need_sync')) {
      context.handle(_needSyncMeta,
          needSync.isAcceptableOrUnknown(data['need_sync']!, _needSyncMeta));
    }
    if (data.containsKey('is_new')) {
      context.handle(
          _isNewMeta, isNew.isAcceptableOrUnknown(data['is_new']!, _isNewMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('date')) {
      context.handle(
          _dateMeta, date.isAcceptableOrUnknown(data['date']!, _dateMeta));
    }
    if (data.containsKey('buyer_id')) {
      context.handle(_buyerIdMeta,
          buyerId.isAcceptableOrUnknown(data['buyer_id']!, _buyerIdMeta));
    }
    if (data.containsKey('inc_sum')) {
      context.handle(_incSumMeta,
          incSum.isAcceptableOrUnknown(data['inc_sum']!, _incSumMeta));
    }
    if (data.containsKey('info')) {
      context.handle(
          _infoMeta, info.isAcceptableOrUnknown(data['info']!, _infoMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    } else if (isInserting) {
      context.missing(_statusMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {guid};
  @override
  IncRequest map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return IncRequest(
      guid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}guid'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      timestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}timestamp'])!,
      currentTimestamp: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}current_timestamp'])!,
      lastSyncTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_sync_time']),
      needSync: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_sync'])!,
      isNew: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_new'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id']),
      date: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}date']),
      buyerId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}buyer_id']),
      incSum: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}inc_sum']),
      info: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}info']),
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
    );
  }

  @override
  $IncRequestsTable createAlias(String alias) {
    return $IncRequestsTable(attachedDatabase, alias);
  }
}

class IncRequest extends DataClass implements Insertable<IncRequest> {
  final String guid;
  final bool isDeleted;
  final DateTime timestamp;
  final DateTime currentTimestamp;
  final DateTime? lastSyncTime;
  final bool needSync;
  final bool isNew;
  final int? id;
  final DateTime? date;
  final int? buyerId;
  final double? incSum;
  final String? info;
  final String status;
  const IncRequest(
      {required this.guid,
      required this.isDeleted,
      required this.timestamp,
      required this.currentTimestamp,
      this.lastSyncTime,
      required this.needSync,
      required this.isNew,
      this.id,
      this.date,
      this.buyerId,
      this.incSum,
      this.info,
      required this.status});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['guid'] = Variable<String>(guid);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['timestamp'] = Variable<DateTime>(timestamp);
    map['current_timestamp'] = Variable<DateTime>(currentTimestamp);
    if (!nullToAbsent || lastSyncTime != null) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || date != null) {
      map['date'] = Variable<DateTime>(date);
    }
    if (!nullToAbsent || buyerId != null) {
      map['buyer_id'] = Variable<int>(buyerId);
    }
    if (!nullToAbsent || incSum != null) {
      map['inc_sum'] = Variable<double>(incSum);
    }
    if (!nullToAbsent || info != null) {
      map['info'] = Variable<String>(info);
    }
    map['status'] = Variable<String>(status);
    return map;
  }

  IncRequestsCompanion toCompanion(bool nullToAbsent) {
    return IncRequestsCompanion(
      guid: Value(guid),
      isDeleted: Value(isDeleted),
      timestamp: Value(timestamp),
      currentTimestamp: Value(currentTimestamp),
      lastSyncTime: lastSyncTime == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncTime),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      date: date == null && nullToAbsent ? const Value.absent() : Value(date),
      buyerId: buyerId == null && nullToAbsent
          ? const Value.absent()
          : Value(buyerId),
      incSum:
          incSum == null && nullToAbsent ? const Value.absent() : Value(incSum),
      info: info == null && nullToAbsent ? const Value.absent() : Value(info),
      status: Value(status),
    );
  }

  factory IncRequest.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return IncRequest(
      guid: serializer.fromJson<String>(json['guid']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      currentTimestamp: serializer.fromJson<DateTime>(json['currentTimestamp']),
      lastSyncTime: serializer.fromJson<DateTime?>(json['lastSyncTime']),
      needSync: serializer.fromJson<bool>(json['needSync']),
      isNew: serializer.fromJson<bool>(json['isNew']),
      id: serializer.fromJson<int?>(json['id']),
      date: serializer.fromJson<DateTime?>(json['date']),
      buyerId: serializer.fromJson<int?>(json['buyerId']),
      incSum: serializer.fromJson<double?>(json['incSum']),
      info: serializer.fromJson<String?>(json['info']),
      status: serializer.fromJson<String>(json['status']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'guid': serializer.toJson<String>(guid),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'currentTimestamp': serializer.toJson<DateTime>(currentTimestamp),
      'lastSyncTime': serializer.toJson<DateTime?>(lastSyncTime),
      'needSync': serializer.toJson<bool>(needSync),
      'isNew': serializer.toJson<bool>(isNew),
      'id': serializer.toJson<int?>(id),
      'date': serializer.toJson<DateTime?>(date),
      'buyerId': serializer.toJson<int?>(buyerId),
      'incSum': serializer.toJson<double?>(incSum),
      'info': serializer.toJson<String?>(info),
      'status': serializer.toJson<String>(status),
    };
  }

  IncRequest copyWith(
          {String? guid,
          bool? isDeleted,
          DateTime? timestamp,
          DateTime? currentTimestamp,
          Value<DateTime?> lastSyncTime = const Value.absent(),
          bool? needSync,
          bool? isNew,
          Value<int?> id = const Value.absent(),
          Value<DateTime?> date = const Value.absent(),
          Value<int?> buyerId = const Value.absent(),
          Value<double?> incSum = const Value.absent(),
          Value<String?> info = const Value.absent(),
          String? status}) =>
      IncRequest(
        guid: guid ?? this.guid,
        isDeleted: isDeleted ?? this.isDeleted,
        timestamp: timestamp ?? this.timestamp,
        currentTimestamp: currentTimestamp ?? this.currentTimestamp,
        lastSyncTime:
            lastSyncTime.present ? lastSyncTime.value : this.lastSyncTime,
        needSync: needSync ?? this.needSync,
        isNew: isNew ?? this.isNew,
        id: id.present ? id.value : this.id,
        date: date.present ? date.value : this.date,
        buyerId: buyerId.present ? buyerId.value : this.buyerId,
        incSum: incSum.present ? incSum.value : this.incSum,
        info: info.present ? info.value : this.info,
        status: status ?? this.status,
      );
  @override
  String toString() {
    return (StringBuffer('IncRequest(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('needSync: $needSync, ')
          ..write('isNew: $isNew, ')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('buyerId: $buyerId, ')
          ..write('incSum: $incSum, ')
          ..write('info: $info, ')
          ..write('status: $status')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(guid, isDeleted, timestamp, currentTimestamp,
      lastSyncTime, needSync, isNew, id, date, buyerId, incSum, info, status);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is IncRequest &&
          other.guid == this.guid &&
          other.isDeleted == this.isDeleted &&
          other.timestamp == this.timestamp &&
          other.currentTimestamp == this.currentTimestamp &&
          other.lastSyncTime == this.lastSyncTime &&
          other.needSync == this.needSync &&
          other.isNew == this.isNew &&
          other.id == this.id &&
          other.date == this.date &&
          other.buyerId == this.buyerId &&
          other.incSum == this.incSum &&
          other.info == this.info &&
          other.status == this.status);
}

class IncRequestsCompanion extends UpdateCompanion<IncRequest> {
  final Value<String> guid;
  final Value<bool> isDeleted;
  final Value<DateTime> timestamp;
  final Value<DateTime> currentTimestamp;
  final Value<DateTime?> lastSyncTime;
  final Value<int?> id;
  final Value<DateTime?> date;
  final Value<int?> buyerId;
  final Value<double?> incSum;
  final Value<String?> info;
  final Value<String> status;
  final Value<int> rowid;
  const IncRequestsCompanion({
    this.guid = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    this.date = const Value.absent(),
    this.buyerId = const Value.absent(),
    this.incSum = const Value.absent(),
    this.info = const Value.absent(),
    this.status = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  IncRequestsCompanion.insert({
    required String guid,
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    this.date = const Value.absent(),
    this.buyerId = const Value.absent(),
    this.incSum = const Value.absent(),
    this.info = const Value.absent(),
    required String status,
    this.rowid = const Value.absent(),
  })  : guid = Value(guid),
        status = Value(status);
  static Insertable<IncRequest> custom({
    Expression<String>? guid,
    Expression<bool>? isDeleted,
    Expression<DateTime>? timestamp,
    Expression<DateTime>? currentTimestamp,
    Expression<DateTime>? lastSyncTime,
    Expression<int>? id,
    Expression<DateTime>? date,
    Expression<int>? buyerId,
    Expression<double>? incSum,
    Expression<String>? info,
    Expression<String>? status,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (guid != null) 'guid': guid,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (timestamp != null) 'timestamp': timestamp,
      if (currentTimestamp != null) 'current_timestamp': currentTimestamp,
      if (lastSyncTime != null) 'last_sync_time': lastSyncTime,
      if (id != null) 'id': id,
      if (date != null) 'date': date,
      if (buyerId != null) 'buyer_id': buyerId,
      if (incSum != null) 'inc_sum': incSum,
      if (info != null) 'info': info,
      if (status != null) 'status': status,
      if (rowid != null) 'rowid': rowid,
    });
  }

  IncRequestsCompanion copyWith(
      {Value<String>? guid,
      Value<bool>? isDeleted,
      Value<DateTime>? timestamp,
      Value<DateTime>? currentTimestamp,
      Value<DateTime?>? lastSyncTime,
      Value<int?>? id,
      Value<DateTime?>? date,
      Value<int?>? buyerId,
      Value<double?>? incSum,
      Value<String?>? info,
      Value<String>? status,
      Value<int>? rowid}) {
    return IncRequestsCompanion(
      guid: guid ?? this.guid,
      isDeleted: isDeleted ?? this.isDeleted,
      timestamp: timestamp ?? this.timestamp,
      currentTimestamp: currentTimestamp ?? this.currentTimestamp,
      lastSyncTime: lastSyncTime ?? this.lastSyncTime,
      id: id ?? this.id,
      date: date ?? this.date,
      buyerId: buyerId ?? this.buyerId,
      incSum: incSum ?? this.incSum,
      info: info ?? this.info,
      status: status ?? this.status,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (guid.present) {
      map['guid'] = Variable<String>(guid.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (currentTimestamp.present) {
      map['current_timestamp'] = Variable<DateTime>(currentTimestamp.value);
    }
    if (lastSyncTime.present) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (buyerId.present) {
      map['buyer_id'] = Variable<int>(buyerId.value);
    }
    if (incSum.present) {
      map['inc_sum'] = Variable<double>(incSum.value);
    }
    if (info.present) {
      map['info'] = Variable<String>(info.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('IncRequestsCompanion(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('buyerId: $buyerId, ')
          ..write('incSum: $incSum, ')
          ..write('info: $info, ')
          ..write('status: $status, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AllGoodsTable extends AllGoods with TableInfo<$AllGoodsTable, Goods> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AllGoodsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _imageUrlMeta =
      const VerificationMeta('imageUrl');
  @override
  late final GeneratedColumn<String> imageUrl = GeneratedColumn<String>(
      'image_url', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _imageKeyMeta =
      const VerificationMeta('imageKey');
  @override
  late final GeneratedColumn<String> imageKey = GeneratedColumn<String>(
      'image_key', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _categoryIdMeta =
      const VerificationMeta('categoryId');
  @override
  late final GeneratedColumn<int> categoryId = GeneratedColumn<int>(
      'category_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _manufacturerMeta =
      const VerificationMeta('manufacturer');
  @override
  late final GeneratedColumn<String> manufacturer = GeneratedColumn<String>(
      'manufacturer', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isLatestMeta =
      const VerificationMeta('isLatest');
  @override
  late final GeneratedColumn<bool> isLatest = GeneratedColumn<bool>(
      'is_latest', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_latest" IN (0, 1))'));
  static const VerificationMeta _isOrderableMeta =
      const VerificationMeta('isOrderable');
  @override
  late final GeneratedColumn<bool> isOrderable = GeneratedColumn<bool>(
      'is_orderable', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_orderable" IN (0, 1))'));
  static const VerificationMeta _pricelistSetIdMeta =
      const VerificationMeta('pricelistSetId');
  @override
  late final GeneratedColumn<int> pricelistSetId = GeneratedColumn<int>(
      'pricelist_set_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _costMeta = const VerificationMeta('cost');
  @override
  late final GeneratedColumn<double> cost = GeneratedColumn<double>(
      'cost', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _minPriceMeta =
      const VerificationMeta('minPrice');
  @override
  late final GeneratedColumn<double> minPrice = GeneratedColumn<double>(
      'min_price', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _extraLabelMeta =
      const VerificationMeta('extraLabel');
  @override
  late final GeneratedColumn<String> extraLabel = GeneratedColumn<String>(
      'extra_label', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _orderRelMeta =
      const VerificationMeta('orderRel');
  @override
  late final GeneratedColumn<int> orderRel = GeneratedColumn<int>(
      'order_rel', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _orderPackageMeta =
      const VerificationMeta('orderPackage');
  @override
  late final GeneratedColumn<int> orderPackage = GeneratedColumn<int>(
      'order_package', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _categoryBoxRelMeta =
      const VerificationMeta('categoryBoxRel');
  @override
  late final GeneratedColumn<int> categoryBoxRel = GeneratedColumn<int>(
      'category_box_rel', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _categoryBlockRelMeta =
      const VerificationMeta('categoryBlockRel');
  @override
  late final GeneratedColumn<int> categoryBlockRel = GeneratedColumn<int>(
      'category_block_rel', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _weightMeta = const VerificationMeta('weight');
  @override
  late final GeneratedColumn<double> weight = GeneratedColumn<double>(
      'weight', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _volumeMeta = const VerificationMeta('volume');
  @override
  late final GeneratedColumn<double> volume = GeneratedColumn<double>(
      'volume', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _forPhysicalMeta =
      const VerificationMeta('forPhysical');
  @override
  late final GeneratedColumn<bool> forPhysical = GeneratedColumn<bool>(
      'for_physical', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("for_physical" IN (0, 1))'));
  static const VerificationMeta _onlyWithDocsMeta =
      const VerificationMeta('onlyWithDocs');
  @override
  late final GeneratedColumn<bool> onlyWithDocs = GeneratedColumn<bool>(
      'only_with_docs', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("only_with_docs" IN (0, 1))'));
  static const VerificationMeta _shelfLifeMeta =
      const VerificationMeta('shelfLife');
  @override
  late final GeneratedColumn<int> shelfLife = GeneratedColumn<int>(
      'shelf_life', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _shelfLifeTypeNameMeta =
      const VerificationMeta('shelfLifeTypeName');
  @override
  late final GeneratedColumn<String> shelfLifeTypeName =
      GeneratedColumn<String>('shelf_life_type_name', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _barcodesMeta =
      const VerificationMeta('barcodes');
  @override
  late final GeneratedColumnWithTypeConverter<EqualList<String>, String>
      barcodes = GeneratedColumn<String>('barcodes', aliasedName, false,
              type: DriftSqlType.string, requiredDuringInsert: true)
          .withConverter<EqualList<String>>($AllGoodsTable.$converterbarcodes);
  @override
  List<GeneratedColumn> get $columns => [
        imageUrl,
        imageKey,
        id,
        name,
        categoryId,
        manufacturer,
        isLatest,
        isOrderable,
        pricelistSetId,
        cost,
        minPrice,
        extraLabel,
        orderRel,
        orderPackage,
        categoryBoxRel,
        categoryBlockRel,
        weight,
        volume,
        forPhysical,
        onlyWithDocs,
        shelfLife,
        shelfLifeTypeName,
        barcodes
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'goods';
  @override
  VerificationContext validateIntegrity(Insertable<Goods> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('image_url')) {
      context.handle(_imageUrlMeta,
          imageUrl.isAcceptableOrUnknown(data['image_url']!, _imageUrlMeta));
    } else if (isInserting) {
      context.missing(_imageUrlMeta);
    }
    if (data.containsKey('image_key')) {
      context.handle(_imageKeyMeta,
          imageKey.isAcceptableOrUnknown(data['image_key']!, _imageKeyMeta));
    } else if (isInserting) {
      context.missing(_imageKeyMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('category_id')) {
      context.handle(
          _categoryIdMeta,
          categoryId.isAcceptableOrUnknown(
              data['category_id']!, _categoryIdMeta));
    } else if (isInserting) {
      context.missing(_categoryIdMeta);
    }
    if (data.containsKey('manufacturer')) {
      context.handle(
          _manufacturerMeta,
          manufacturer.isAcceptableOrUnknown(
              data['manufacturer']!, _manufacturerMeta));
    }
    if (data.containsKey('is_latest')) {
      context.handle(_isLatestMeta,
          isLatest.isAcceptableOrUnknown(data['is_latest']!, _isLatestMeta));
    } else if (isInserting) {
      context.missing(_isLatestMeta);
    }
    if (data.containsKey('is_orderable')) {
      context.handle(
          _isOrderableMeta,
          isOrderable.isAcceptableOrUnknown(
              data['is_orderable']!, _isOrderableMeta));
    } else if (isInserting) {
      context.missing(_isOrderableMeta);
    }
    if (data.containsKey('pricelist_set_id')) {
      context.handle(
          _pricelistSetIdMeta,
          pricelistSetId.isAcceptableOrUnknown(
              data['pricelist_set_id']!, _pricelistSetIdMeta));
    } else if (isInserting) {
      context.missing(_pricelistSetIdMeta);
    }
    if (data.containsKey('cost')) {
      context.handle(
          _costMeta, cost.isAcceptableOrUnknown(data['cost']!, _costMeta));
    } else if (isInserting) {
      context.missing(_costMeta);
    }
    if (data.containsKey('min_price')) {
      context.handle(_minPriceMeta,
          minPrice.isAcceptableOrUnknown(data['min_price']!, _minPriceMeta));
    } else if (isInserting) {
      context.missing(_minPriceMeta);
    }
    if (data.containsKey('extra_label')) {
      context.handle(
          _extraLabelMeta,
          extraLabel.isAcceptableOrUnknown(
              data['extra_label']!, _extraLabelMeta));
    } else if (isInserting) {
      context.missing(_extraLabelMeta);
    }
    if (data.containsKey('order_rel')) {
      context.handle(_orderRelMeta,
          orderRel.isAcceptableOrUnknown(data['order_rel']!, _orderRelMeta));
    } else if (isInserting) {
      context.missing(_orderRelMeta);
    }
    if (data.containsKey('order_package')) {
      context.handle(
          _orderPackageMeta,
          orderPackage.isAcceptableOrUnknown(
              data['order_package']!, _orderPackageMeta));
    } else if (isInserting) {
      context.missing(_orderPackageMeta);
    }
    if (data.containsKey('category_box_rel')) {
      context.handle(
          _categoryBoxRelMeta,
          categoryBoxRel.isAcceptableOrUnknown(
              data['category_box_rel']!, _categoryBoxRelMeta));
    } else if (isInserting) {
      context.missing(_categoryBoxRelMeta);
    }
    if (data.containsKey('category_block_rel')) {
      context.handle(
          _categoryBlockRelMeta,
          categoryBlockRel.isAcceptableOrUnknown(
              data['category_block_rel']!, _categoryBlockRelMeta));
    } else if (isInserting) {
      context.missing(_categoryBlockRelMeta);
    }
    if (data.containsKey('weight')) {
      context.handle(_weightMeta,
          weight.isAcceptableOrUnknown(data['weight']!, _weightMeta));
    } else if (isInserting) {
      context.missing(_weightMeta);
    }
    if (data.containsKey('volume')) {
      context.handle(_volumeMeta,
          volume.isAcceptableOrUnknown(data['volume']!, _volumeMeta));
    } else if (isInserting) {
      context.missing(_volumeMeta);
    }
    if (data.containsKey('for_physical')) {
      context.handle(
          _forPhysicalMeta,
          forPhysical.isAcceptableOrUnknown(
              data['for_physical']!, _forPhysicalMeta));
    } else if (isInserting) {
      context.missing(_forPhysicalMeta);
    }
    if (data.containsKey('only_with_docs')) {
      context.handle(
          _onlyWithDocsMeta,
          onlyWithDocs.isAcceptableOrUnknown(
              data['only_with_docs']!, _onlyWithDocsMeta));
    } else if (isInserting) {
      context.missing(_onlyWithDocsMeta);
    }
    if (data.containsKey('shelf_life')) {
      context.handle(_shelfLifeMeta,
          shelfLife.isAcceptableOrUnknown(data['shelf_life']!, _shelfLifeMeta));
    } else if (isInserting) {
      context.missing(_shelfLifeMeta);
    }
    if (data.containsKey('shelf_life_type_name')) {
      context.handle(
          _shelfLifeTypeNameMeta,
          shelfLifeTypeName.isAcceptableOrUnknown(
              data['shelf_life_type_name']!, _shelfLifeTypeNameMeta));
    } else if (isInserting) {
      context.missing(_shelfLifeTypeNameMeta);
    }
    context.handle(_barcodesMeta, const VerificationResult.success());
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Goods map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Goods(
      imageUrl: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}image_url'])!,
      imageKey: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}image_key'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      categoryId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}category_id'])!,
      manufacturer: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}manufacturer']),
      isLatest: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_latest'])!,
      isOrderable: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_orderable'])!,
      pricelistSetId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}pricelist_set_id'])!,
      cost: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}cost'])!,
      minPrice: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}min_price'])!,
      extraLabel: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}extra_label'])!,
      orderRel: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}order_rel'])!,
      orderPackage: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}order_package'])!,
      categoryBoxRel: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}category_box_rel'])!,
      categoryBlockRel: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}category_block_rel'])!,
      weight: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}weight'])!,
      volume: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}volume'])!,
      forPhysical: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}for_physical'])!,
      onlyWithDocs: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}only_with_docs'])!,
      shelfLife: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}shelf_life'])!,
      shelfLifeTypeName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}shelf_life_type_name'])!,
      barcodes: $AllGoodsTable.$converterbarcodes.fromSql(attachedDatabase
          .typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}barcodes'])!),
    );
  }

  @override
  $AllGoodsTable createAlias(String alias) {
    return $AllGoodsTable(attachedDatabase, alias);
  }

  static TypeConverter<EqualList<String>, String> $converterbarcodes =
      const JsonListConverter<String>();
}

class Goods extends DataClass implements Insertable<Goods> {
  final String imageUrl;
  final String imageKey;
  final int id;
  final String name;
  final int categoryId;
  final String? manufacturer;
  final bool isLatest;
  final bool isOrderable;
  final int pricelistSetId;
  final double cost;
  final double minPrice;
  final String extraLabel;
  final int orderRel;
  final int orderPackage;
  final int categoryBoxRel;
  final int categoryBlockRel;
  final double weight;
  final double volume;
  final bool forPhysical;
  final bool onlyWithDocs;
  final int shelfLife;
  final String shelfLifeTypeName;
  final EqualList<String> barcodes;
  const Goods(
      {required this.imageUrl,
      required this.imageKey,
      required this.id,
      required this.name,
      required this.categoryId,
      this.manufacturer,
      required this.isLatest,
      required this.isOrderable,
      required this.pricelistSetId,
      required this.cost,
      required this.minPrice,
      required this.extraLabel,
      required this.orderRel,
      required this.orderPackage,
      required this.categoryBoxRel,
      required this.categoryBlockRel,
      required this.weight,
      required this.volume,
      required this.forPhysical,
      required this.onlyWithDocs,
      required this.shelfLife,
      required this.shelfLifeTypeName,
      required this.barcodes});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['image_url'] = Variable<String>(imageUrl);
    map['image_key'] = Variable<String>(imageKey);
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    map['category_id'] = Variable<int>(categoryId);
    if (!nullToAbsent || manufacturer != null) {
      map['manufacturer'] = Variable<String>(manufacturer);
    }
    map['is_latest'] = Variable<bool>(isLatest);
    map['is_orderable'] = Variable<bool>(isOrderable);
    map['pricelist_set_id'] = Variable<int>(pricelistSetId);
    map['cost'] = Variable<double>(cost);
    map['min_price'] = Variable<double>(minPrice);
    map['extra_label'] = Variable<String>(extraLabel);
    map['order_rel'] = Variable<int>(orderRel);
    map['order_package'] = Variable<int>(orderPackage);
    map['category_box_rel'] = Variable<int>(categoryBoxRel);
    map['category_block_rel'] = Variable<int>(categoryBlockRel);
    map['weight'] = Variable<double>(weight);
    map['volume'] = Variable<double>(volume);
    map['for_physical'] = Variable<bool>(forPhysical);
    map['only_with_docs'] = Variable<bool>(onlyWithDocs);
    map['shelf_life'] = Variable<int>(shelfLife);
    map['shelf_life_type_name'] = Variable<String>(shelfLifeTypeName);
    {
      map['barcodes'] =
          Variable<String>($AllGoodsTable.$converterbarcodes.toSql(barcodes));
    }
    return map;
  }

  AllGoodsCompanion toCompanion(bool nullToAbsent) {
    return AllGoodsCompanion(
      imageUrl: Value(imageUrl),
      imageKey: Value(imageKey),
      id: Value(id),
      name: Value(name),
      categoryId: Value(categoryId),
      manufacturer: manufacturer == null && nullToAbsent
          ? const Value.absent()
          : Value(manufacturer),
      isLatest: Value(isLatest),
      isOrderable: Value(isOrderable),
      pricelistSetId: Value(pricelistSetId),
      cost: Value(cost),
      minPrice: Value(minPrice),
      extraLabel: Value(extraLabel),
      orderRel: Value(orderRel),
      orderPackage: Value(orderPackage),
      categoryBoxRel: Value(categoryBoxRel),
      categoryBlockRel: Value(categoryBlockRel),
      weight: Value(weight),
      volume: Value(volume),
      forPhysical: Value(forPhysical),
      onlyWithDocs: Value(onlyWithDocs),
      shelfLife: Value(shelfLife),
      shelfLifeTypeName: Value(shelfLifeTypeName),
      barcodes: Value(barcodes),
    );
  }

  factory Goods.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Goods(
      imageUrl: serializer.fromJson<String>(json['imageUrl']),
      imageKey: serializer.fromJson<String>(json['imageKey']),
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      categoryId: serializer.fromJson<int>(json['categoryId']),
      manufacturer: serializer.fromJson<String?>(json['manufacturer']),
      isLatest: serializer.fromJson<bool>(json['isLatest']),
      isOrderable: serializer.fromJson<bool>(json['isOrderable']),
      pricelistSetId: serializer.fromJson<int>(json['pricelistSetId']),
      cost: serializer.fromJson<double>(json['cost']),
      minPrice: serializer.fromJson<double>(json['minPrice']),
      extraLabel: serializer.fromJson<String>(json['extraLabel']),
      orderRel: serializer.fromJson<int>(json['orderRel']),
      orderPackage: serializer.fromJson<int>(json['orderPackage']),
      categoryBoxRel: serializer.fromJson<int>(json['categoryBoxRel']),
      categoryBlockRel: serializer.fromJson<int>(json['categoryBlockRel']),
      weight: serializer.fromJson<double>(json['weight']),
      volume: serializer.fromJson<double>(json['volume']),
      forPhysical: serializer.fromJson<bool>(json['forPhysical']),
      onlyWithDocs: serializer.fromJson<bool>(json['onlyWithDocs']),
      shelfLife: serializer.fromJson<int>(json['shelfLife']),
      shelfLifeTypeName: serializer.fromJson<String>(json['shelfLifeTypeName']),
      barcodes: serializer.fromJson<EqualList<String>>(json['barcodes']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'imageUrl': serializer.toJson<String>(imageUrl),
      'imageKey': serializer.toJson<String>(imageKey),
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
      'categoryId': serializer.toJson<int>(categoryId),
      'manufacturer': serializer.toJson<String?>(manufacturer),
      'isLatest': serializer.toJson<bool>(isLatest),
      'isOrderable': serializer.toJson<bool>(isOrderable),
      'pricelistSetId': serializer.toJson<int>(pricelistSetId),
      'cost': serializer.toJson<double>(cost),
      'minPrice': serializer.toJson<double>(minPrice),
      'extraLabel': serializer.toJson<String>(extraLabel),
      'orderRel': serializer.toJson<int>(orderRel),
      'orderPackage': serializer.toJson<int>(orderPackage),
      'categoryBoxRel': serializer.toJson<int>(categoryBoxRel),
      'categoryBlockRel': serializer.toJson<int>(categoryBlockRel),
      'weight': serializer.toJson<double>(weight),
      'volume': serializer.toJson<double>(volume),
      'forPhysical': serializer.toJson<bool>(forPhysical),
      'onlyWithDocs': serializer.toJson<bool>(onlyWithDocs),
      'shelfLife': serializer.toJson<int>(shelfLife),
      'shelfLifeTypeName': serializer.toJson<String>(shelfLifeTypeName),
      'barcodes': serializer.toJson<EqualList<String>>(barcodes),
    };
  }

  Goods copyWith(
          {String? imageUrl,
          String? imageKey,
          int? id,
          String? name,
          int? categoryId,
          Value<String?> manufacturer = const Value.absent(),
          bool? isLatest,
          bool? isOrderable,
          int? pricelistSetId,
          double? cost,
          double? minPrice,
          String? extraLabel,
          int? orderRel,
          int? orderPackage,
          int? categoryBoxRel,
          int? categoryBlockRel,
          double? weight,
          double? volume,
          bool? forPhysical,
          bool? onlyWithDocs,
          int? shelfLife,
          String? shelfLifeTypeName,
          EqualList<String>? barcodes}) =>
      Goods(
        imageUrl: imageUrl ?? this.imageUrl,
        imageKey: imageKey ?? this.imageKey,
        id: id ?? this.id,
        name: name ?? this.name,
        categoryId: categoryId ?? this.categoryId,
        manufacturer:
            manufacturer.present ? manufacturer.value : this.manufacturer,
        isLatest: isLatest ?? this.isLatest,
        isOrderable: isOrderable ?? this.isOrderable,
        pricelistSetId: pricelistSetId ?? this.pricelistSetId,
        cost: cost ?? this.cost,
        minPrice: minPrice ?? this.minPrice,
        extraLabel: extraLabel ?? this.extraLabel,
        orderRel: orderRel ?? this.orderRel,
        orderPackage: orderPackage ?? this.orderPackage,
        categoryBoxRel: categoryBoxRel ?? this.categoryBoxRel,
        categoryBlockRel: categoryBlockRel ?? this.categoryBlockRel,
        weight: weight ?? this.weight,
        volume: volume ?? this.volume,
        forPhysical: forPhysical ?? this.forPhysical,
        onlyWithDocs: onlyWithDocs ?? this.onlyWithDocs,
        shelfLife: shelfLife ?? this.shelfLife,
        shelfLifeTypeName: shelfLifeTypeName ?? this.shelfLifeTypeName,
        barcodes: barcodes ?? this.barcodes,
      );
  Goods copyWithCompanion(AllGoodsCompanion data) {
    return Goods(
      imageUrl: data.imageUrl.present ? data.imageUrl.value : this.imageUrl,
      imageKey: data.imageKey.present ? data.imageKey.value : this.imageKey,
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      categoryId:
          data.categoryId.present ? data.categoryId.value : this.categoryId,
      manufacturer: data.manufacturer.present
          ? data.manufacturer.value
          : this.manufacturer,
      isLatest: data.isLatest.present ? data.isLatest.value : this.isLatest,
      isOrderable:
          data.isOrderable.present ? data.isOrderable.value : this.isOrderable,
      pricelistSetId: data.pricelistSetId.present
          ? data.pricelistSetId.value
          : this.pricelistSetId,
      cost: data.cost.present ? data.cost.value : this.cost,
      minPrice: data.minPrice.present ? data.minPrice.value : this.minPrice,
      extraLabel:
          data.extraLabel.present ? data.extraLabel.value : this.extraLabel,
      orderRel: data.orderRel.present ? data.orderRel.value : this.orderRel,
      orderPackage: data.orderPackage.present
          ? data.orderPackage.value
          : this.orderPackage,
      categoryBoxRel: data.categoryBoxRel.present
          ? data.categoryBoxRel.value
          : this.categoryBoxRel,
      categoryBlockRel: data.categoryBlockRel.present
          ? data.categoryBlockRel.value
          : this.categoryBlockRel,
      weight: data.weight.present ? data.weight.value : this.weight,
      volume: data.volume.present ? data.volume.value : this.volume,
      forPhysical:
          data.forPhysical.present ? data.forPhysical.value : this.forPhysical,
      onlyWithDocs: data.onlyWithDocs.present
          ? data.onlyWithDocs.value
          : this.onlyWithDocs,
      shelfLife: data.shelfLife.present ? data.shelfLife.value : this.shelfLife,
      shelfLifeTypeName: data.shelfLifeTypeName.present
          ? data.shelfLifeTypeName.value
          : this.shelfLifeTypeName,
      barcodes: data.barcodes.present ? data.barcodes.value : this.barcodes,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Goods(')
          ..write('imageUrl: $imageUrl, ')
          ..write('imageKey: $imageKey, ')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('categoryId: $categoryId, ')
          ..write('manufacturer: $manufacturer, ')
          ..write('isLatest: $isLatest, ')
          ..write('isOrderable: $isOrderable, ')
          ..write('pricelistSetId: $pricelistSetId, ')
          ..write('cost: $cost, ')
          ..write('minPrice: $minPrice, ')
          ..write('extraLabel: $extraLabel, ')
          ..write('orderRel: $orderRel, ')
          ..write('orderPackage: $orderPackage, ')
          ..write('categoryBoxRel: $categoryBoxRel, ')
          ..write('categoryBlockRel: $categoryBlockRel, ')
          ..write('weight: $weight, ')
          ..write('volume: $volume, ')
          ..write('forPhysical: $forPhysical, ')
          ..write('onlyWithDocs: $onlyWithDocs, ')
          ..write('shelfLife: $shelfLife, ')
          ..write('shelfLifeTypeName: $shelfLifeTypeName, ')
          ..write('barcodes: $barcodes')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        imageUrl,
        imageKey,
        id,
        name,
        categoryId,
        manufacturer,
        isLatest,
        isOrderable,
        pricelistSetId,
        cost,
        minPrice,
        extraLabel,
        orderRel,
        orderPackage,
        categoryBoxRel,
        categoryBlockRel,
        weight,
        volume,
        forPhysical,
        onlyWithDocs,
        shelfLife,
        shelfLifeTypeName,
        barcodes
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Goods &&
          other.imageUrl == this.imageUrl &&
          other.imageKey == this.imageKey &&
          other.id == this.id &&
          other.name == this.name &&
          other.categoryId == this.categoryId &&
          other.manufacturer == this.manufacturer &&
          other.isLatest == this.isLatest &&
          other.isOrderable == this.isOrderable &&
          other.pricelistSetId == this.pricelistSetId &&
          other.cost == this.cost &&
          other.minPrice == this.minPrice &&
          other.extraLabel == this.extraLabel &&
          other.orderRel == this.orderRel &&
          other.orderPackage == this.orderPackage &&
          other.categoryBoxRel == this.categoryBoxRel &&
          other.categoryBlockRel == this.categoryBlockRel &&
          other.weight == this.weight &&
          other.volume == this.volume &&
          other.forPhysical == this.forPhysical &&
          other.onlyWithDocs == this.onlyWithDocs &&
          other.shelfLife == this.shelfLife &&
          other.shelfLifeTypeName == this.shelfLifeTypeName &&
          other.barcodes == this.barcodes);
}

class AllGoodsCompanion extends UpdateCompanion<Goods> {
  final Value<String> imageUrl;
  final Value<String> imageKey;
  final Value<int> id;
  final Value<String> name;
  final Value<int> categoryId;
  final Value<String?> manufacturer;
  final Value<bool> isLatest;
  final Value<bool> isOrderable;
  final Value<int> pricelistSetId;
  final Value<double> cost;
  final Value<double> minPrice;
  final Value<String> extraLabel;
  final Value<int> orderRel;
  final Value<int> orderPackage;
  final Value<int> categoryBoxRel;
  final Value<int> categoryBlockRel;
  final Value<double> weight;
  final Value<double> volume;
  final Value<bool> forPhysical;
  final Value<bool> onlyWithDocs;
  final Value<int> shelfLife;
  final Value<String> shelfLifeTypeName;
  final Value<EqualList<String>> barcodes;
  const AllGoodsCompanion({
    this.imageUrl = const Value.absent(),
    this.imageKey = const Value.absent(),
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.categoryId = const Value.absent(),
    this.manufacturer = const Value.absent(),
    this.isLatest = const Value.absent(),
    this.isOrderable = const Value.absent(),
    this.pricelistSetId = const Value.absent(),
    this.cost = const Value.absent(),
    this.minPrice = const Value.absent(),
    this.extraLabel = const Value.absent(),
    this.orderRel = const Value.absent(),
    this.orderPackage = const Value.absent(),
    this.categoryBoxRel = const Value.absent(),
    this.categoryBlockRel = const Value.absent(),
    this.weight = const Value.absent(),
    this.volume = const Value.absent(),
    this.forPhysical = const Value.absent(),
    this.onlyWithDocs = const Value.absent(),
    this.shelfLife = const Value.absent(),
    this.shelfLifeTypeName = const Value.absent(),
    this.barcodes = const Value.absent(),
  });
  AllGoodsCompanion.insert({
    required String imageUrl,
    required String imageKey,
    this.id = const Value.absent(),
    required String name,
    required int categoryId,
    this.manufacturer = const Value.absent(),
    required bool isLatest,
    required bool isOrderable,
    required int pricelistSetId,
    required double cost,
    required double minPrice,
    required String extraLabel,
    required int orderRel,
    required int orderPackage,
    required int categoryBoxRel,
    required int categoryBlockRel,
    required double weight,
    required double volume,
    required bool forPhysical,
    required bool onlyWithDocs,
    required int shelfLife,
    required String shelfLifeTypeName,
    required EqualList<String> barcodes,
  })  : imageUrl = Value(imageUrl),
        imageKey = Value(imageKey),
        name = Value(name),
        categoryId = Value(categoryId),
        isLatest = Value(isLatest),
        isOrderable = Value(isOrderable),
        pricelistSetId = Value(pricelistSetId),
        cost = Value(cost),
        minPrice = Value(minPrice),
        extraLabel = Value(extraLabel),
        orderRel = Value(orderRel),
        orderPackage = Value(orderPackage),
        categoryBoxRel = Value(categoryBoxRel),
        categoryBlockRel = Value(categoryBlockRel),
        weight = Value(weight),
        volume = Value(volume),
        forPhysical = Value(forPhysical),
        onlyWithDocs = Value(onlyWithDocs),
        shelfLife = Value(shelfLife),
        shelfLifeTypeName = Value(shelfLifeTypeName),
        barcodes = Value(barcodes);
  static Insertable<Goods> custom({
    Expression<String>? imageUrl,
    Expression<String>? imageKey,
    Expression<int>? id,
    Expression<String>? name,
    Expression<int>? categoryId,
    Expression<String>? manufacturer,
    Expression<bool>? isLatest,
    Expression<bool>? isOrderable,
    Expression<int>? pricelistSetId,
    Expression<double>? cost,
    Expression<double>? minPrice,
    Expression<String>? extraLabel,
    Expression<int>? orderRel,
    Expression<int>? orderPackage,
    Expression<int>? categoryBoxRel,
    Expression<int>? categoryBlockRel,
    Expression<double>? weight,
    Expression<double>? volume,
    Expression<bool>? forPhysical,
    Expression<bool>? onlyWithDocs,
    Expression<int>? shelfLife,
    Expression<String>? shelfLifeTypeName,
    Expression<String>? barcodes,
  }) {
    return RawValuesInsertable({
      if (imageUrl != null) 'image_url': imageUrl,
      if (imageKey != null) 'image_key': imageKey,
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (categoryId != null) 'category_id': categoryId,
      if (manufacturer != null) 'manufacturer': manufacturer,
      if (isLatest != null) 'is_latest': isLatest,
      if (isOrderable != null) 'is_orderable': isOrderable,
      if (pricelistSetId != null) 'pricelist_set_id': pricelistSetId,
      if (cost != null) 'cost': cost,
      if (minPrice != null) 'min_price': minPrice,
      if (extraLabel != null) 'extra_label': extraLabel,
      if (orderRel != null) 'order_rel': orderRel,
      if (orderPackage != null) 'order_package': orderPackage,
      if (categoryBoxRel != null) 'category_box_rel': categoryBoxRel,
      if (categoryBlockRel != null) 'category_block_rel': categoryBlockRel,
      if (weight != null) 'weight': weight,
      if (volume != null) 'volume': volume,
      if (forPhysical != null) 'for_physical': forPhysical,
      if (onlyWithDocs != null) 'only_with_docs': onlyWithDocs,
      if (shelfLife != null) 'shelf_life': shelfLife,
      if (shelfLifeTypeName != null) 'shelf_life_type_name': shelfLifeTypeName,
      if (barcodes != null) 'barcodes': barcodes,
    });
  }

  AllGoodsCompanion copyWith(
      {Value<String>? imageUrl,
      Value<String>? imageKey,
      Value<int>? id,
      Value<String>? name,
      Value<int>? categoryId,
      Value<String?>? manufacturer,
      Value<bool>? isLatest,
      Value<bool>? isOrderable,
      Value<int>? pricelistSetId,
      Value<double>? cost,
      Value<double>? minPrice,
      Value<String>? extraLabel,
      Value<int>? orderRel,
      Value<int>? orderPackage,
      Value<int>? categoryBoxRel,
      Value<int>? categoryBlockRel,
      Value<double>? weight,
      Value<double>? volume,
      Value<bool>? forPhysical,
      Value<bool>? onlyWithDocs,
      Value<int>? shelfLife,
      Value<String>? shelfLifeTypeName,
      Value<EqualList<String>>? barcodes}) {
    return AllGoodsCompanion(
      imageUrl: imageUrl ?? this.imageUrl,
      imageKey: imageKey ?? this.imageKey,
      id: id ?? this.id,
      name: name ?? this.name,
      categoryId: categoryId ?? this.categoryId,
      manufacturer: manufacturer ?? this.manufacturer,
      isLatest: isLatest ?? this.isLatest,
      isOrderable: isOrderable ?? this.isOrderable,
      pricelistSetId: pricelistSetId ?? this.pricelistSetId,
      cost: cost ?? this.cost,
      minPrice: minPrice ?? this.minPrice,
      extraLabel: extraLabel ?? this.extraLabel,
      orderRel: orderRel ?? this.orderRel,
      orderPackage: orderPackage ?? this.orderPackage,
      categoryBoxRel: categoryBoxRel ?? this.categoryBoxRel,
      categoryBlockRel: categoryBlockRel ?? this.categoryBlockRel,
      weight: weight ?? this.weight,
      volume: volume ?? this.volume,
      forPhysical: forPhysical ?? this.forPhysical,
      onlyWithDocs: onlyWithDocs ?? this.onlyWithDocs,
      shelfLife: shelfLife ?? this.shelfLife,
      shelfLifeTypeName: shelfLifeTypeName ?? this.shelfLifeTypeName,
      barcodes: barcodes ?? this.barcodes,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (imageUrl.present) {
      map['image_url'] = Variable<String>(imageUrl.value);
    }
    if (imageKey.present) {
      map['image_key'] = Variable<String>(imageKey.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (categoryId.present) {
      map['category_id'] = Variable<int>(categoryId.value);
    }
    if (manufacturer.present) {
      map['manufacturer'] = Variable<String>(manufacturer.value);
    }
    if (isLatest.present) {
      map['is_latest'] = Variable<bool>(isLatest.value);
    }
    if (isOrderable.present) {
      map['is_orderable'] = Variable<bool>(isOrderable.value);
    }
    if (pricelistSetId.present) {
      map['pricelist_set_id'] = Variable<int>(pricelistSetId.value);
    }
    if (cost.present) {
      map['cost'] = Variable<double>(cost.value);
    }
    if (minPrice.present) {
      map['min_price'] = Variable<double>(minPrice.value);
    }
    if (extraLabel.present) {
      map['extra_label'] = Variable<String>(extraLabel.value);
    }
    if (orderRel.present) {
      map['order_rel'] = Variable<int>(orderRel.value);
    }
    if (orderPackage.present) {
      map['order_package'] = Variable<int>(orderPackage.value);
    }
    if (categoryBoxRel.present) {
      map['category_box_rel'] = Variable<int>(categoryBoxRel.value);
    }
    if (categoryBlockRel.present) {
      map['category_block_rel'] = Variable<int>(categoryBlockRel.value);
    }
    if (weight.present) {
      map['weight'] = Variable<double>(weight.value);
    }
    if (volume.present) {
      map['volume'] = Variable<double>(volume.value);
    }
    if (forPhysical.present) {
      map['for_physical'] = Variable<bool>(forPhysical.value);
    }
    if (onlyWithDocs.present) {
      map['only_with_docs'] = Variable<bool>(onlyWithDocs.value);
    }
    if (shelfLife.present) {
      map['shelf_life'] = Variable<int>(shelfLife.value);
    }
    if (shelfLifeTypeName.present) {
      map['shelf_life_type_name'] = Variable<String>(shelfLifeTypeName.value);
    }
    if (barcodes.present) {
      map['barcodes'] = Variable<String>(
          $AllGoodsTable.$converterbarcodes.toSql(barcodes.value));
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AllGoodsCompanion(')
          ..write('imageUrl: $imageUrl, ')
          ..write('imageKey: $imageKey, ')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('categoryId: $categoryId, ')
          ..write('manufacturer: $manufacturer, ')
          ..write('isLatest: $isLatest, ')
          ..write('isOrderable: $isOrderable, ')
          ..write('pricelistSetId: $pricelistSetId, ')
          ..write('cost: $cost, ')
          ..write('minPrice: $minPrice, ')
          ..write('extraLabel: $extraLabel, ')
          ..write('orderRel: $orderRel, ')
          ..write('orderPackage: $orderPackage, ')
          ..write('categoryBoxRel: $categoryBoxRel, ')
          ..write('categoryBlockRel: $categoryBlockRel, ')
          ..write('weight: $weight, ')
          ..write('volume: $volume, ')
          ..write('forPhysical: $forPhysical, ')
          ..write('onlyWithDocs: $onlyWithDocs, ')
          ..write('shelfLife: $shelfLife, ')
          ..write('shelfLifeTypeName: $shelfLifeTypeName, ')
          ..write('barcodes: $barcodes')
          ..write(')'))
        .toString();
  }
}

class $WorkdatesTable extends Workdates
    with TableInfo<$WorkdatesTable, Workdate> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $WorkdatesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
      'date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [date];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'workdates';
  @override
  VerificationContext validateIntegrity(Insertable<Workdate> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('date')) {
      context.handle(
          _dateMeta, date.isAcceptableOrUnknown(data['date']!, _dateMeta));
    } else if (isInserting) {
      context.missing(_dateMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {date};
  @override
  Workdate map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Workdate(
      date: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}date'])!,
    );
  }

  @override
  $WorkdatesTable createAlias(String alias) {
    return $WorkdatesTable(attachedDatabase, alias);
  }
}

class Workdate extends DataClass implements Insertable<Workdate> {
  final DateTime date;
  const Workdate({required this.date});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['date'] = Variable<DateTime>(date);
    return map;
  }

  WorkdatesCompanion toCompanion(bool nullToAbsent) {
    return WorkdatesCompanion(
      date: Value(date),
    );
  }

  factory Workdate.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Workdate(
      date: serializer.fromJson<DateTime>(json['date']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'date': serializer.toJson<DateTime>(date),
    };
  }

  Workdate copyWith({DateTime? date}) => Workdate(
        date: date ?? this.date,
      );
  Workdate copyWithCompanion(WorkdatesCompanion data) {
    return Workdate(
      date: data.date.present ? data.date.value : this.date,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Workdate(')
          ..write('date: $date')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => date.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) || (other is Workdate && other.date == this.date);
}

class WorkdatesCompanion extends UpdateCompanion<Workdate> {
  final Value<DateTime> date;
  final Value<int> rowid;
  const WorkdatesCompanion({
    this.date = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  WorkdatesCompanion.insert({
    required DateTime date,
    this.rowid = const Value.absent(),
  }) : date = Value(date);
  static Insertable<Workdate> custom({
    Expression<DateTime>? date,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (date != null) 'date': date,
      if (rowid != null) 'rowid': rowid,
    });
  }

  WorkdatesCompanion copyWith({Value<DateTime>? date, Value<int>? rowid}) {
    return WorkdatesCompanion(
      date: date ?? this.date,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('WorkdatesCompanion(')
          ..write('date: $date, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ShopDepartmentsTable extends ShopDepartments
    with TableInfo<$ShopDepartmentsTable, ShopDepartment> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ShopDepartmentsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _ordMeta = const VerificationMeta('ord');
  @override
  late final GeneratedColumn<int> ord = GeneratedColumn<int>(
      'ord', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [id, name, ord];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'shop_departments';
  @override
  VerificationContext validateIntegrity(Insertable<ShopDepartment> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('ord')) {
      context.handle(
          _ordMeta, ord.isAcceptableOrUnknown(data['ord']!, _ordMeta));
    } else if (isInserting) {
      context.missing(_ordMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ShopDepartment map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ShopDepartment(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      ord: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}ord'])!,
    );
  }

  @override
  $ShopDepartmentsTable createAlias(String alias) {
    return $ShopDepartmentsTable(attachedDatabase, alias);
  }
}

class ShopDepartment extends DataClass implements Insertable<ShopDepartment> {
  final int id;
  final String name;
  final int ord;
  const ShopDepartment(
      {required this.id, required this.name, required this.ord});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    map['ord'] = Variable<int>(ord);
    return map;
  }

  ShopDepartmentsCompanion toCompanion(bool nullToAbsent) {
    return ShopDepartmentsCompanion(
      id: Value(id),
      name: Value(name),
      ord: Value(ord),
    );
  }

  factory ShopDepartment.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ShopDepartment(
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      ord: serializer.fromJson<int>(json['ord']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
      'ord': serializer.toJson<int>(ord),
    };
  }

  ShopDepartment copyWith({int? id, String? name, int? ord}) => ShopDepartment(
        id: id ?? this.id,
        name: name ?? this.name,
        ord: ord ?? this.ord,
      );
  ShopDepartment copyWithCompanion(ShopDepartmentsCompanion data) {
    return ShopDepartment(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      ord: data.ord.present ? data.ord.value : this.ord,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ShopDepartment(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('ord: $ord')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name, ord);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ShopDepartment &&
          other.id == this.id &&
          other.name == this.name &&
          other.ord == this.ord);
}

class ShopDepartmentsCompanion extends UpdateCompanion<ShopDepartment> {
  final Value<int> id;
  final Value<String> name;
  final Value<int> ord;
  const ShopDepartmentsCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.ord = const Value.absent(),
  });
  ShopDepartmentsCompanion.insert({
    this.id = const Value.absent(),
    required String name,
    required int ord,
  })  : name = Value(name),
        ord = Value(ord);
  static Insertable<ShopDepartment> custom({
    Expression<int>? id,
    Expression<String>? name,
    Expression<int>? ord,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (ord != null) 'ord': ord,
    });
  }

  ShopDepartmentsCompanion copyWith(
      {Value<int>? id, Value<String>? name, Value<int>? ord}) {
    return ShopDepartmentsCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      ord: ord ?? this.ord,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (ord.present) {
      map['ord'] = Variable<int>(ord.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ShopDepartmentsCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('ord: $ord')
          ..write(')'))
        .toString();
  }
}

class $CategoriesTable extends Categories
    with TableInfo<$CategoriesTable, Category> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CategoriesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _ordMeta = const VerificationMeta('ord');
  @override
  late final GeneratedColumn<int> ord = GeneratedColumn<int>(
      'ord', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _shopDepartmentIdMeta =
      const VerificationMeta('shopDepartmentId');
  @override
  late final GeneratedColumn<int> shopDepartmentId = GeneratedColumn<int>(
      'shop_department_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [id, name, ord, shopDepartmentId];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'categories';
  @override
  VerificationContext validateIntegrity(Insertable<Category> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('ord')) {
      context.handle(
          _ordMeta, ord.isAcceptableOrUnknown(data['ord']!, _ordMeta));
    } else if (isInserting) {
      context.missing(_ordMeta);
    }
    if (data.containsKey('shop_department_id')) {
      context.handle(
          _shopDepartmentIdMeta,
          shopDepartmentId.isAcceptableOrUnknown(
              data['shop_department_id']!, _shopDepartmentIdMeta));
    } else if (isInserting) {
      context.missing(_shopDepartmentIdMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Category map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Category(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      ord: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}ord'])!,
      shopDepartmentId: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}shop_department_id'])!,
    );
  }

  @override
  $CategoriesTable createAlias(String alias) {
    return $CategoriesTable(attachedDatabase, alias);
  }
}

class Category extends DataClass implements Insertable<Category> {
  final int id;
  final String name;
  final int ord;
  final int shopDepartmentId;
  const Category(
      {required this.id,
      required this.name,
      required this.ord,
      required this.shopDepartmentId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    map['ord'] = Variable<int>(ord);
    map['shop_department_id'] = Variable<int>(shopDepartmentId);
    return map;
  }

  CategoriesCompanion toCompanion(bool nullToAbsent) {
    return CategoriesCompanion(
      id: Value(id),
      name: Value(name),
      ord: Value(ord),
      shopDepartmentId: Value(shopDepartmentId),
    );
  }

  factory Category.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Category(
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      ord: serializer.fromJson<int>(json['ord']),
      shopDepartmentId: serializer.fromJson<int>(json['shopDepartmentId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
      'ord': serializer.toJson<int>(ord),
      'shopDepartmentId': serializer.toJson<int>(shopDepartmentId),
    };
  }

  Category copyWith({int? id, String? name, int? ord, int? shopDepartmentId}) =>
      Category(
        id: id ?? this.id,
        name: name ?? this.name,
        ord: ord ?? this.ord,
        shopDepartmentId: shopDepartmentId ?? this.shopDepartmentId,
      );
  Category copyWithCompanion(CategoriesCompanion data) {
    return Category(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      ord: data.ord.present ? data.ord.value : this.ord,
      shopDepartmentId: data.shopDepartmentId.present
          ? data.shopDepartmentId.value
          : this.shopDepartmentId,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Category(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('ord: $ord, ')
          ..write('shopDepartmentId: $shopDepartmentId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name, ord, shopDepartmentId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Category &&
          other.id == this.id &&
          other.name == this.name &&
          other.ord == this.ord &&
          other.shopDepartmentId == this.shopDepartmentId);
}

class CategoriesCompanion extends UpdateCompanion<Category> {
  final Value<int> id;
  final Value<String> name;
  final Value<int> ord;
  final Value<int> shopDepartmentId;
  const CategoriesCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.ord = const Value.absent(),
    this.shopDepartmentId = const Value.absent(),
  });
  CategoriesCompanion.insert({
    this.id = const Value.absent(),
    required String name,
    required int ord,
    required int shopDepartmentId,
  })  : name = Value(name),
        ord = Value(ord),
        shopDepartmentId = Value(shopDepartmentId);
  static Insertable<Category> custom({
    Expression<int>? id,
    Expression<String>? name,
    Expression<int>? ord,
    Expression<int>? shopDepartmentId,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (ord != null) 'ord': ord,
      if (shopDepartmentId != null) 'shop_department_id': shopDepartmentId,
    });
  }

  CategoriesCompanion copyWith(
      {Value<int>? id,
      Value<String>? name,
      Value<int>? ord,
      Value<int>? shopDepartmentId}) {
    return CategoriesCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      ord: ord ?? this.ord,
      shopDepartmentId: shopDepartmentId ?? this.shopDepartmentId,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (ord.present) {
      map['ord'] = Variable<int>(ord.value);
    }
    if (shopDepartmentId.present) {
      map['shop_department_id'] = Variable<int>(shopDepartmentId.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CategoriesCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('ord: $ord, ')
          ..write('shopDepartmentId: $shopDepartmentId')
          ..write(')'))
        .toString();
  }
}

class $GoodsFiltersTable extends GoodsFilters
    with TableInfo<$GoodsFiltersTable, GoodsFilter> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GoodsFiltersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _valueMeta = const VerificationMeta('value');
  @override
  late final GeneratedColumn<String> value = GeneratedColumn<String>(
      'value', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [id, name, value];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'goods_filters';
  @override
  VerificationContext validateIntegrity(Insertable<GoodsFilter> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('value')) {
      context.handle(
          _valueMeta, value.isAcceptableOrUnknown(data['value']!, _valueMeta));
    } else if (isInserting) {
      context.missing(_valueMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  GoodsFilter map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GoodsFilter(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      value: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}value'])!,
    );
  }

  @override
  $GoodsFiltersTable createAlias(String alias) {
    return $GoodsFiltersTable(attachedDatabase, alias);
  }
}

class GoodsFilter extends DataClass implements Insertable<GoodsFilter> {
  final int id;
  final String name;
  final String value;
  const GoodsFilter(
      {required this.id, required this.name, required this.value});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    map['value'] = Variable<String>(value);
    return map;
  }

  GoodsFiltersCompanion toCompanion(bool nullToAbsent) {
    return GoodsFiltersCompanion(
      id: Value(id),
      name: Value(name),
      value: Value(value),
    );
  }

  factory GoodsFilter.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return GoodsFilter(
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      value: serializer.fromJson<String>(json['value']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
      'value': serializer.toJson<String>(value),
    };
  }

  GoodsFilter copyWith({int? id, String? name, String? value}) => GoodsFilter(
        id: id ?? this.id,
        name: name ?? this.name,
        value: value ?? this.value,
      );
  GoodsFilter copyWithCompanion(GoodsFiltersCompanion data) {
    return GoodsFilter(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      value: data.value.present ? data.value.value : this.value,
    );
  }

  @override
  String toString() {
    return (StringBuffer('GoodsFilter(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('value: $value')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name, value);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GoodsFilter &&
          other.id == this.id &&
          other.name == this.name &&
          other.value == this.value);
}

class GoodsFiltersCompanion extends UpdateCompanion<GoodsFilter> {
  final Value<int> id;
  final Value<String> name;
  final Value<String> value;
  const GoodsFiltersCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.value = const Value.absent(),
  });
  GoodsFiltersCompanion.insert({
    this.id = const Value.absent(),
    required String name,
    required String value,
  })  : name = Value(name),
        value = Value(value);
  static Insertable<GoodsFilter> custom({
    Expression<int>? id,
    Expression<String>? name,
    Expression<String>? value,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (value != null) 'value': value,
    });
  }

  GoodsFiltersCompanion copyWith(
      {Value<int>? id, Value<String>? name, Value<String>? value}) {
    return GoodsFiltersCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      value: value ?? this.value,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (value.present) {
      map['value'] = Variable<String>(value.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GoodsFiltersCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('value: $value')
          ..write(')'))
        .toString();
  }
}

class $OrdersTable extends Orders with TableInfo<$OrdersTable, Order> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OrdersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _guidMeta = const VerificationMeta('guid');
  @override
  late final GeneratedColumn<String> guid = GeneratedColumn<String>(
      'guid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _timestampMeta =
      const VerificationMeta('timestamp');
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
      'timestamp', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _currentTimestampMeta =
      const VerificationMeta('currentTimestamp');
  @override
  late final GeneratedColumn<DateTime> currentTimestamp =
      GeneratedColumn<DateTime>('current_timestamp', aliasedName, false,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          defaultValue: currentDateAndTime);
  static const VerificationMeta _lastSyncTimeMeta =
      const VerificationMeta('lastSyncTime');
  @override
  late final GeneratedColumn<DateTime> lastSyncTime = GeneratedColumn<DateTime>(
      'last_sync_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _needSyncMeta =
      const VerificationMeta('needSync');
  @override
  late final GeneratedColumn<bool> needSync = GeneratedColumn<bool>(
      'need_sync', aliasedName, false,
      generatedAs: GeneratedAs(
          (isNew & BooleanExpressionOperators(isDeleted).not()) |
              (BooleanExpressionOperators(isNew).not() &
                  ComparableExpr(lastSyncTime).isSmallerThan(timestamp)),
          true),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("need_sync" IN (0, 1))'));
  static const VerificationMeta _isNewMeta = const VerificationMeta('isNew');
  @override
  late final GeneratedColumn<bool> isNew = GeneratedColumn<bool>(
      'is_new', aliasedName, false,
      generatedAs: GeneratedAs(lastSyncTime.isNull(), false),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_new" IN (0, 1))'));
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
      'date', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _preOrderIdMeta =
      const VerificationMeta('preOrderId');
  @override
  late final GeneratedColumn<int> preOrderId = GeneratedColumn<int>(
      'pre_order_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _needDocsMeta =
      const VerificationMeta('needDocs');
  @override
  late final GeneratedColumn<bool> needDocs = GeneratedColumn<bool>(
      'need_docs', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("need_docs" IN (0, 1))'));
  static const VerificationMeta _needIncMeta =
      const VerificationMeta('needInc');
  @override
  late final GeneratedColumn<bool> needInc = GeneratedColumn<bool>(
      'need_inc', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("need_inc" IN (0, 1))'));
  static const VerificationMeta _isPhysicalMeta =
      const VerificationMeta('isPhysical');
  @override
  late final GeneratedColumn<bool> isPhysical = GeneratedColumn<bool>(
      'is_physical', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_physical" IN (0, 1))'));
  static const VerificationMeta _buyerIdMeta =
      const VerificationMeta('buyerId');
  @override
  late final GeneratedColumn<int> buyerId = GeneratedColumn<int>(
      'buyer_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _infoMeta = const VerificationMeta('info');
  @override
  late final GeneratedColumn<String> info = GeneratedColumn<String>(
      'info', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _needProcessingMeta =
      const VerificationMeta('needProcessing');
  @override
  late final GeneratedColumn<bool> needProcessing = GeneratedColumn<bool>(
      'need_processing', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("need_processing" IN (0, 1))'));
  static const VerificationMeta _isEditableMeta =
      const VerificationMeta('isEditable');
  @override
  late final GeneratedColumn<bool> isEditable = GeneratedColumn<bool>(
      'is_editable', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_editable" IN (0, 1))'));
  @override
  List<GeneratedColumn> get $columns => [
        guid,
        isDeleted,
        timestamp,
        currentTimestamp,
        lastSyncTime,
        needSync,
        isNew,
        id,
        date,
        status,
        preOrderId,
        needDocs,
        needInc,
        isPhysical,
        buyerId,
        info,
        needProcessing,
        isEditable
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'orders';
  @override
  VerificationContext validateIntegrity(Insertable<Order> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('guid')) {
      context.handle(
          _guidMeta, guid.isAcceptableOrUnknown(data['guid']!, _guidMeta));
    } else if (isInserting) {
      context.missing(_guidMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('timestamp')) {
      context.handle(_timestampMeta,
          timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta));
    }
    if (data.containsKey('current_timestamp')) {
      context.handle(
          _currentTimestampMeta,
          currentTimestamp.isAcceptableOrUnknown(
              data['current_timestamp']!, _currentTimestampMeta));
    }
    if (data.containsKey('last_sync_time')) {
      context.handle(
          _lastSyncTimeMeta,
          lastSyncTime.isAcceptableOrUnknown(
              data['last_sync_time']!, _lastSyncTimeMeta));
    }
    if (data.containsKey('need_sync')) {
      context.handle(_needSyncMeta,
          needSync.isAcceptableOrUnknown(data['need_sync']!, _needSyncMeta));
    }
    if (data.containsKey('is_new')) {
      context.handle(
          _isNewMeta, isNew.isAcceptableOrUnknown(data['is_new']!, _isNewMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('date')) {
      context.handle(
          _dateMeta, date.isAcceptableOrUnknown(data['date']!, _dateMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    } else if (isInserting) {
      context.missing(_statusMeta);
    }
    if (data.containsKey('pre_order_id')) {
      context.handle(
          _preOrderIdMeta,
          preOrderId.isAcceptableOrUnknown(
              data['pre_order_id']!, _preOrderIdMeta));
    }
    if (data.containsKey('need_docs')) {
      context.handle(_needDocsMeta,
          needDocs.isAcceptableOrUnknown(data['need_docs']!, _needDocsMeta));
    } else if (isInserting) {
      context.missing(_needDocsMeta);
    }
    if (data.containsKey('need_inc')) {
      context.handle(_needIncMeta,
          needInc.isAcceptableOrUnknown(data['need_inc']!, _needIncMeta));
    } else if (isInserting) {
      context.missing(_needIncMeta);
    }
    if (data.containsKey('is_physical')) {
      context.handle(
          _isPhysicalMeta,
          isPhysical.isAcceptableOrUnknown(
              data['is_physical']!, _isPhysicalMeta));
    } else if (isInserting) {
      context.missing(_isPhysicalMeta);
    }
    if (data.containsKey('buyer_id')) {
      context.handle(_buyerIdMeta,
          buyerId.isAcceptableOrUnknown(data['buyer_id']!, _buyerIdMeta));
    }
    if (data.containsKey('info')) {
      context.handle(
          _infoMeta, info.isAcceptableOrUnknown(data['info']!, _infoMeta));
    }
    if (data.containsKey('need_processing')) {
      context.handle(
          _needProcessingMeta,
          needProcessing.isAcceptableOrUnknown(
              data['need_processing']!, _needProcessingMeta));
    } else if (isInserting) {
      context.missing(_needProcessingMeta);
    }
    if (data.containsKey('is_editable')) {
      context.handle(
          _isEditableMeta,
          isEditable.isAcceptableOrUnknown(
              data['is_editable']!, _isEditableMeta));
    } else if (isInserting) {
      context.missing(_isEditableMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {guid};
  @override
  Order map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Order(
      guid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}guid'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      timestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}timestamp'])!,
      currentTimestamp: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}current_timestamp'])!,
      lastSyncTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_sync_time']),
      needSync: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_sync'])!,
      isNew: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_new'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id']),
      date: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}date']),
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      preOrderId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}pre_order_id']),
      needDocs: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_docs'])!,
      needInc: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_inc'])!,
      isPhysical: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_physical'])!,
      buyerId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}buyer_id']),
      info: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}info']),
      needProcessing: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_processing'])!,
      isEditable: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_editable'])!,
    );
  }

  @override
  $OrdersTable createAlias(String alias) {
    return $OrdersTable(attachedDatabase, alias);
  }
}

class Order extends DataClass implements Insertable<Order> {
  final String guid;
  final bool isDeleted;
  final DateTime timestamp;
  final DateTime currentTimestamp;
  final DateTime? lastSyncTime;
  final bool needSync;
  final bool isNew;
  final int? id;
  final DateTime? date;
  final String status;
  final int? preOrderId;
  final bool needDocs;
  final bool needInc;
  final bool isPhysical;
  final int? buyerId;
  final String? info;
  final bool needProcessing;
  final bool isEditable;
  const Order(
      {required this.guid,
      required this.isDeleted,
      required this.timestamp,
      required this.currentTimestamp,
      this.lastSyncTime,
      required this.needSync,
      required this.isNew,
      this.id,
      this.date,
      required this.status,
      this.preOrderId,
      required this.needDocs,
      required this.needInc,
      required this.isPhysical,
      this.buyerId,
      this.info,
      required this.needProcessing,
      required this.isEditable});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['guid'] = Variable<String>(guid);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['timestamp'] = Variable<DateTime>(timestamp);
    map['current_timestamp'] = Variable<DateTime>(currentTimestamp);
    if (!nullToAbsent || lastSyncTime != null) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || date != null) {
      map['date'] = Variable<DateTime>(date);
    }
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || preOrderId != null) {
      map['pre_order_id'] = Variable<int>(preOrderId);
    }
    map['need_docs'] = Variable<bool>(needDocs);
    map['need_inc'] = Variable<bool>(needInc);
    map['is_physical'] = Variable<bool>(isPhysical);
    if (!nullToAbsent || buyerId != null) {
      map['buyer_id'] = Variable<int>(buyerId);
    }
    if (!nullToAbsent || info != null) {
      map['info'] = Variable<String>(info);
    }
    map['need_processing'] = Variable<bool>(needProcessing);
    map['is_editable'] = Variable<bool>(isEditable);
    return map;
  }

  OrdersCompanion toCompanion(bool nullToAbsent) {
    return OrdersCompanion(
      guid: Value(guid),
      isDeleted: Value(isDeleted),
      timestamp: Value(timestamp),
      currentTimestamp: Value(currentTimestamp),
      lastSyncTime: lastSyncTime == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncTime),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      date: date == null && nullToAbsent ? const Value.absent() : Value(date),
      status: Value(status),
      preOrderId: preOrderId == null && nullToAbsent
          ? const Value.absent()
          : Value(preOrderId),
      needDocs: Value(needDocs),
      needInc: Value(needInc),
      isPhysical: Value(isPhysical),
      buyerId: buyerId == null && nullToAbsent
          ? const Value.absent()
          : Value(buyerId),
      info: info == null && nullToAbsent ? const Value.absent() : Value(info),
      needProcessing: Value(needProcessing),
      isEditable: Value(isEditable),
    );
  }

  factory Order.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Order(
      guid: serializer.fromJson<String>(json['guid']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      currentTimestamp: serializer.fromJson<DateTime>(json['currentTimestamp']),
      lastSyncTime: serializer.fromJson<DateTime?>(json['lastSyncTime']),
      needSync: serializer.fromJson<bool>(json['needSync']),
      isNew: serializer.fromJson<bool>(json['isNew']),
      id: serializer.fromJson<int?>(json['id']),
      date: serializer.fromJson<DateTime?>(json['date']),
      status: serializer.fromJson<String>(json['status']),
      preOrderId: serializer.fromJson<int?>(json['preOrderId']),
      needDocs: serializer.fromJson<bool>(json['needDocs']),
      needInc: serializer.fromJson<bool>(json['needInc']),
      isPhysical: serializer.fromJson<bool>(json['isPhysical']),
      buyerId: serializer.fromJson<int?>(json['buyerId']),
      info: serializer.fromJson<String?>(json['info']),
      needProcessing: serializer.fromJson<bool>(json['needProcessing']),
      isEditable: serializer.fromJson<bool>(json['isEditable']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'guid': serializer.toJson<String>(guid),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'currentTimestamp': serializer.toJson<DateTime>(currentTimestamp),
      'lastSyncTime': serializer.toJson<DateTime?>(lastSyncTime),
      'needSync': serializer.toJson<bool>(needSync),
      'isNew': serializer.toJson<bool>(isNew),
      'id': serializer.toJson<int?>(id),
      'date': serializer.toJson<DateTime?>(date),
      'status': serializer.toJson<String>(status),
      'preOrderId': serializer.toJson<int?>(preOrderId),
      'needDocs': serializer.toJson<bool>(needDocs),
      'needInc': serializer.toJson<bool>(needInc),
      'isPhysical': serializer.toJson<bool>(isPhysical),
      'buyerId': serializer.toJson<int?>(buyerId),
      'info': serializer.toJson<String?>(info),
      'needProcessing': serializer.toJson<bool>(needProcessing),
      'isEditable': serializer.toJson<bool>(isEditable),
    };
  }

  Order copyWith(
          {String? guid,
          bool? isDeleted,
          DateTime? timestamp,
          DateTime? currentTimestamp,
          Value<DateTime?> lastSyncTime = const Value.absent(),
          bool? needSync,
          bool? isNew,
          Value<int?> id = const Value.absent(),
          Value<DateTime?> date = const Value.absent(),
          String? status,
          Value<int?> preOrderId = const Value.absent(),
          bool? needDocs,
          bool? needInc,
          bool? isPhysical,
          Value<int?> buyerId = const Value.absent(),
          Value<String?> info = const Value.absent(),
          bool? needProcessing,
          bool? isEditable}) =>
      Order(
        guid: guid ?? this.guid,
        isDeleted: isDeleted ?? this.isDeleted,
        timestamp: timestamp ?? this.timestamp,
        currentTimestamp: currentTimestamp ?? this.currentTimestamp,
        lastSyncTime:
            lastSyncTime.present ? lastSyncTime.value : this.lastSyncTime,
        needSync: needSync ?? this.needSync,
        isNew: isNew ?? this.isNew,
        id: id.present ? id.value : this.id,
        date: date.present ? date.value : this.date,
        status: status ?? this.status,
        preOrderId: preOrderId.present ? preOrderId.value : this.preOrderId,
        needDocs: needDocs ?? this.needDocs,
        needInc: needInc ?? this.needInc,
        isPhysical: isPhysical ?? this.isPhysical,
        buyerId: buyerId.present ? buyerId.value : this.buyerId,
        info: info.present ? info.value : this.info,
        needProcessing: needProcessing ?? this.needProcessing,
        isEditable: isEditable ?? this.isEditable,
      );
  @override
  String toString() {
    return (StringBuffer('Order(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('needSync: $needSync, ')
          ..write('isNew: $isNew, ')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('status: $status, ')
          ..write('preOrderId: $preOrderId, ')
          ..write('needDocs: $needDocs, ')
          ..write('needInc: $needInc, ')
          ..write('isPhysical: $isPhysical, ')
          ..write('buyerId: $buyerId, ')
          ..write('info: $info, ')
          ..write('needProcessing: $needProcessing, ')
          ..write('isEditable: $isEditable')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      guid,
      isDeleted,
      timestamp,
      currentTimestamp,
      lastSyncTime,
      needSync,
      isNew,
      id,
      date,
      status,
      preOrderId,
      needDocs,
      needInc,
      isPhysical,
      buyerId,
      info,
      needProcessing,
      isEditable);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Order &&
          other.guid == this.guid &&
          other.isDeleted == this.isDeleted &&
          other.timestamp == this.timestamp &&
          other.currentTimestamp == this.currentTimestamp &&
          other.lastSyncTime == this.lastSyncTime &&
          other.needSync == this.needSync &&
          other.isNew == this.isNew &&
          other.id == this.id &&
          other.date == this.date &&
          other.status == this.status &&
          other.preOrderId == this.preOrderId &&
          other.needDocs == this.needDocs &&
          other.needInc == this.needInc &&
          other.isPhysical == this.isPhysical &&
          other.buyerId == this.buyerId &&
          other.info == this.info &&
          other.needProcessing == this.needProcessing &&
          other.isEditable == this.isEditable);
}

class OrdersCompanion extends UpdateCompanion<Order> {
  final Value<String> guid;
  final Value<bool> isDeleted;
  final Value<DateTime> timestamp;
  final Value<DateTime> currentTimestamp;
  final Value<DateTime?> lastSyncTime;
  final Value<int?> id;
  final Value<DateTime?> date;
  final Value<String> status;
  final Value<int?> preOrderId;
  final Value<bool> needDocs;
  final Value<bool> needInc;
  final Value<bool> isPhysical;
  final Value<int?> buyerId;
  final Value<String?> info;
  final Value<bool> needProcessing;
  final Value<bool> isEditable;
  final Value<int> rowid;
  const OrdersCompanion({
    this.guid = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    this.date = const Value.absent(),
    this.status = const Value.absent(),
    this.preOrderId = const Value.absent(),
    this.needDocs = const Value.absent(),
    this.needInc = const Value.absent(),
    this.isPhysical = const Value.absent(),
    this.buyerId = const Value.absent(),
    this.info = const Value.absent(),
    this.needProcessing = const Value.absent(),
    this.isEditable = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  OrdersCompanion.insert({
    required String guid,
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    this.date = const Value.absent(),
    required String status,
    this.preOrderId = const Value.absent(),
    required bool needDocs,
    required bool needInc,
    required bool isPhysical,
    this.buyerId = const Value.absent(),
    this.info = const Value.absent(),
    required bool needProcessing,
    required bool isEditable,
    this.rowid = const Value.absent(),
  })  : guid = Value(guid),
        status = Value(status),
        needDocs = Value(needDocs),
        needInc = Value(needInc),
        isPhysical = Value(isPhysical),
        needProcessing = Value(needProcessing),
        isEditable = Value(isEditable);
  static Insertable<Order> custom({
    Expression<String>? guid,
    Expression<bool>? isDeleted,
    Expression<DateTime>? timestamp,
    Expression<DateTime>? currentTimestamp,
    Expression<DateTime>? lastSyncTime,
    Expression<int>? id,
    Expression<DateTime>? date,
    Expression<String>? status,
    Expression<int>? preOrderId,
    Expression<bool>? needDocs,
    Expression<bool>? needInc,
    Expression<bool>? isPhysical,
    Expression<int>? buyerId,
    Expression<String>? info,
    Expression<bool>? needProcessing,
    Expression<bool>? isEditable,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (guid != null) 'guid': guid,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (timestamp != null) 'timestamp': timestamp,
      if (currentTimestamp != null) 'current_timestamp': currentTimestamp,
      if (lastSyncTime != null) 'last_sync_time': lastSyncTime,
      if (id != null) 'id': id,
      if (date != null) 'date': date,
      if (status != null) 'status': status,
      if (preOrderId != null) 'pre_order_id': preOrderId,
      if (needDocs != null) 'need_docs': needDocs,
      if (needInc != null) 'need_inc': needInc,
      if (isPhysical != null) 'is_physical': isPhysical,
      if (buyerId != null) 'buyer_id': buyerId,
      if (info != null) 'info': info,
      if (needProcessing != null) 'need_processing': needProcessing,
      if (isEditable != null) 'is_editable': isEditable,
      if (rowid != null) 'rowid': rowid,
    });
  }

  OrdersCompanion copyWith(
      {Value<String>? guid,
      Value<bool>? isDeleted,
      Value<DateTime>? timestamp,
      Value<DateTime>? currentTimestamp,
      Value<DateTime?>? lastSyncTime,
      Value<int?>? id,
      Value<DateTime?>? date,
      Value<String>? status,
      Value<int?>? preOrderId,
      Value<bool>? needDocs,
      Value<bool>? needInc,
      Value<bool>? isPhysical,
      Value<int?>? buyerId,
      Value<String?>? info,
      Value<bool>? needProcessing,
      Value<bool>? isEditable,
      Value<int>? rowid}) {
    return OrdersCompanion(
      guid: guid ?? this.guid,
      isDeleted: isDeleted ?? this.isDeleted,
      timestamp: timestamp ?? this.timestamp,
      currentTimestamp: currentTimestamp ?? this.currentTimestamp,
      lastSyncTime: lastSyncTime ?? this.lastSyncTime,
      id: id ?? this.id,
      date: date ?? this.date,
      status: status ?? this.status,
      preOrderId: preOrderId ?? this.preOrderId,
      needDocs: needDocs ?? this.needDocs,
      needInc: needInc ?? this.needInc,
      isPhysical: isPhysical ?? this.isPhysical,
      buyerId: buyerId ?? this.buyerId,
      info: info ?? this.info,
      needProcessing: needProcessing ?? this.needProcessing,
      isEditable: isEditable ?? this.isEditable,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (guid.present) {
      map['guid'] = Variable<String>(guid.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (currentTimestamp.present) {
      map['current_timestamp'] = Variable<DateTime>(currentTimestamp.value);
    }
    if (lastSyncTime.present) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (preOrderId.present) {
      map['pre_order_id'] = Variable<int>(preOrderId.value);
    }
    if (needDocs.present) {
      map['need_docs'] = Variable<bool>(needDocs.value);
    }
    if (needInc.present) {
      map['need_inc'] = Variable<bool>(needInc.value);
    }
    if (isPhysical.present) {
      map['is_physical'] = Variable<bool>(isPhysical.value);
    }
    if (buyerId.present) {
      map['buyer_id'] = Variable<int>(buyerId.value);
    }
    if (info.present) {
      map['info'] = Variable<String>(info.value);
    }
    if (needProcessing.present) {
      map['need_processing'] = Variable<bool>(needProcessing.value);
    }
    if (isEditable.present) {
      map['is_editable'] = Variable<bool>(isEditable.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OrdersCompanion(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('status: $status, ')
          ..write('preOrderId: $preOrderId, ')
          ..write('needDocs: $needDocs, ')
          ..write('needInc: $needInc, ')
          ..write('isPhysical: $isPhysical, ')
          ..write('buyerId: $buyerId, ')
          ..write('info: $info, ')
          ..write('needProcessing: $needProcessing, ')
          ..write('isEditable: $isEditable, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $OrderLinesTable extends OrderLines
    with TableInfo<$OrderLinesTable, OrderLine> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OrderLinesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _guidMeta = const VerificationMeta('guid');
  @override
  late final GeneratedColumn<String> guid = GeneratedColumn<String>(
      'guid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _timestampMeta =
      const VerificationMeta('timestamp');
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
      'timestamp', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _currentTimestampMeta =
      const VerificationMeta('currentTimestamp');
  @override
  late final GeneratedColumn<DateTime> currentTimestamp =
      GeneratedColumn<DateTime>('current_timestamp', aliasedName, false,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          defaultValue: currentDateAndTime);
  static const VerificationMeta _lastSyncTimeMeta =
      const VerificationMeta('lastSyncTime');
  @override
  late final GeneratedColumn<DateTime> lastSyncTime = GeneratedColumn<DateTime>(
      'last_sync_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _needSyncMeta =
      const VerificationMeta('needSync');
  @override
  late final GeneratedColumn<bool> needSync = GeneratedColumn<bool>(
      'need_sync', aliasedName, false,
      generatedAs: GeneratedAs(
          (isNew & BooleanExpressionOperators(isDeleted).not()) |
              (BooleanExpressionOperators(isNew).not() &
                  ComparableExpr(lastSyncTime).isSmallerThan(timestamp)),
          true),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("need_sync" IN (0, 1))'));
  static const VerificationMeta _isNewMeta = const VerificationMeta('isNew');
  @override
  late final GeneratedColumn<bool> isNew = GeneratedColumn<bool>(
      'is_new', aliasedName, false,
      generatedAs: GeneratedAs(lastSyncTime.isNull(), false),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_new" IN (0, 1))'));
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _orderGuidMeta =
      const VerificationMeta('orderGuid');
  @override
  late final GeneratedColumn<String> orderGuid = GeneratedColumn<String>(
      'order_guid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES orders (guid) ON UPDATE CASCADE ON DELETE CASCADE'));
  static const VerificationMeta _goodsIdMeta =
      const VerificationMeta('goodsId');
  @override
  late final GeneratedColumn<int> goodsId = GeneratedColumn<int>(
      'goods_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _volMeta = const VerificationMeta('vol');
  @override
  late final GeneratedColumn<double> vol = GeneratedColumn<double>(
      'vol', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  @override
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
      'price', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _priceOriginalMeta =
      const VerificationMeta('priceOriginal');
  @override
  late final GeneratedColumn<double> priceOriginal = GeneratedColumn<double>(
      'price_original', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _packageMeta =
      const VerificationMeta('package');
  @override
  late final GeneratedColumn<int> package = GeneratedColumn<int>(
      'package', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _relMeta = const VerificationMeta('rel');
  @override
  late final GeneratedColumn<int> rel = GeneratedColumn<int>(
      'rel', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        guid,
        isDeleted,
        timestamp,
        currentTimestamp,
        lastSyncTime,
        needSync,
        isNew,
        id,
        orderGuid,
        goodsId,
        vol,
        price,
        priceOriginal,
        package,
        rel
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'order_lines';
  @override
  VerificationContext validateIntegrity(Insertable<OrderLine> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('guid')) {
      context.handle(
          _guidMeta, guid.isAcceptableOrUnknown(data['guid']!, _guidMeta));
    } else if (isInserting) {
      context.missing(_guidMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('timestamp')) {
      context.handle(_timestampMeta,
          timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta));
    }
    if (data.containsKey('current_timestamp')) {
      context.handle(
          _currentTimestampMeta,
          currentTimestamp.isAcceptableOrUnknown(
              data['current_timestamp']!, _currentTimestampMeta));
    }
    if (data.containsKey('last_sync_time')) {
      context.handle(
          _lastSyncTimeMeta,
          lastSyncTime.isAcceptableOrUnknown(
              data['last_sync_time']!, _lastSyncTimeMeta));
    }
    if (data.containsKey('need_sync')) {
      context.handle(_needSyncMeta,
          needSync.isAcceptableOrUnknown(data['need_sync']!, _needSyncMeta));
    }
    if (data.containsKey('is_new')) {
      context.handle(
          _isNewMeta, isNew.isAcceptableOrUnknown(data['is_new']!, _isNewMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('order_guid')) {
      context.handle(_orderGuidMeta,
          orderGuid.isAcceptableOrUnknown(data['order_guid']!, _orderGuidMeta));
    } else if (isInserting) {
      context.missing(_orderGuidMeta);
    }
    if (data.containsKey('goods_id')) {
      context.handle(_goodsIdMeta,
          goodsId.isAcceptableOrUnknown(data['goods_id']!, _goodsIdMeta));
    } else if (isInserting) {
      context.missing(_goodsIdMeta);
    }
    if (data.containsKey('vol')) {
      context.handle(
          _volMeta, vol.isAcceptableOrUnknown(data['vol']!, _volMeta));
    } else if (isInserting) {
      context.missing(_volMeta);
    }
    if (data.containsKey('price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['price']!, _priceMeta));
    } else if (isInserting) {
      context.missing(_priceMeta);
    }
    if (data.containsKey('price_original')) {
      context.handle(
          _priceOriginalMeta,
          priceOriginal.isAcceptableOrUnknown(
              data['price_original']!, _priceOriginalMeta));
    } else if (isInserting) {
      context.missing(_priceOriginalMeta);
    }
    if (data.containsKey('package')) {
      context.handle(_packageMeta,
          package.isAcceptableOrUnknown(data['package']!, _packageMeta));
    } else if (isInserting) {
      context.missing(_packageMeta);
    }
    if (data.containsKey('rel')) {
      context.handle(
          _relMeta, rel.isAcceptableOrUnknown(data['rel']!, _relMeta));
    } else if (isInserting) {
      context.missing(_relMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {guid};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
        {orderGuid, goodsId},
      ];
  @override
  OrderLine map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OrderLine(
      guid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}guid'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      timestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}timestamp'])!,
      currentTimestamp: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}current_timestamp'])!,
      lastSyncTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_sync_time']),
      needSync: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_sync'])!,
      isNew: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_new'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id']),
      orderGuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}order_guid'])!,
      goodsId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}goods_id'])!,
      vol: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}vol'])!,
      price: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}price'])!,
      priceOriginal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}price_original'])!,
      package: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}package'])!,
      rel: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}rel'])!,
    );
  }

  @override
  $OrderLinesTable createAlias(String alias) {
    return $OrderLinesTable(attachedDatabase, alias);
  }
}

class OrderLine extends DataClass implements Insertable<OrderLine> {
  final String guid;
  final bool isDeleted;
  final DateTime timestamp;
  final DateTime currentTimestamp;
  final DateTime? lastSyncTime;
  final bool needSync;
  final bool isNew;
  final int? id;
  final String orderGuid;
  final int goodsId;
  final double vol;
  final double price;
  final double priceOriginal;
  final int package;
  final int rel;
  const OrderLine(
      {required this.guid,
      required this.isDeleted,
      required this.timestamp,
      required this.currentTimestamp,
      this.lastSyncTime,
      required this.needSync,
      required this.isNew,
      this.id,
      required this.orderGuid,
      required this.goodsId,
      required this.vol,
      required this.price,
      required this.priceOriginal,
      required this.package,
      required this.rel});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['guid'] = Variable<String>(guid);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['timestamp'] = Variable<DateTime>(timestamp);
    map['current_timestamp'] = Variable<DateTime>(currentTimestamp);
    if (!nullToAbsent || lastSyncTime != null) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    map['order_guid'] = Variable<String>(orderGuid);
    map['goods_id'] = Variable<int>(goodsId);
    map['vol'] = Variable<double>(vol);
    map['price'] = Variable<double>(price);
    map['price_original'] = Variable<double>(priceOriginal);
    map['package'] = Variable<int>(package);
    map['rel'] = Variable<int>(rel);
    return map;
  }

  OrderLinesCompanion toCompanion(bool nullToAbsent) {
    return OrderLinesCompanion(
      guid: Value(guid),
      isDeleted: Value(isDeleted),
      timestamp: Value(timestamp),
      currentTimestamp: Value(currentTimestamp),
      lastSyncTime: lastSyncTime == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncTime),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      orderGuid: Value(orderGuid),
      goodsId: Value(goodsId),
      vol: Value(vol),
      price: Value(price),
      priceOriginal: Value(priceOriginal),
      package: Value(package),
      rel: Value(rel),
    );
  }

  factory OrderLine.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OrderLine(
      guid: serializer.fromJson<String>(json['guid']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      currentTimestamp: serializer.fromJson<DateTime>(json['currentTimestamp']),
      lastSyncTime: serializer.fromJson<DateTime?>(json['lastSyncTime']),
      needSync: serializer.fromJson<bool>(json['needSync']),
      isNew: serializer.fromJson<bool>(json['isNew']),
      id: serializer.fromJson<int?>(json['id']),
      orderGuid: serializer.fromJson<String>(json['orderGuid']),
      goodsId: serializer.fromJson<int>(json['goodsId']),
      vol: serializer.fromJson<double>(json['vol']),
      price: serializer.fromJson<double>(json['price']),
      priceOriginal: serializer.fromJson<double>(json['priceOriginal']),
      package: serializer.fromJson<int>(json['package']),
      rel: serializer.fromJson<int>(json['rel']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'guid': serializer.toJson<String>(guid),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'currentTimestamp': serializer.toJson<DateTime>(currentTimestamp),
      'lastSyncTime': serializer.toJson<DateTime?>(lastSyncTime),
      'needSync': serializer.toJson<bool>(needSync),
      'isNew': serializer.toJson<bool>(isNew),
      'id': serializer.toJson<int?>(id),
      'orderGuid': serializer.toJson<String>(orderGuid),
      'goodsId': serializer.toJson<int>(goodsId),
      'vol': serializer.toJson<double>(vol),
      'price': serializer.toJson<double>(price),
      'priceOriginal': serializer.toJson<double>(priceOriginal),
      'package': serializer.toJson<int>(package),
      'rel': serializer.toJson<int>(rel),
    };
  }

  OrderLine copyWith(
          {String? guid,
          bool? isDeleted,
          DateTime? timestamp,
          DateTime? currentTimestamp,
          Value<DateTime?> lastSyncTime = const Value.absent(),
          bool? needSync,
          bool? isNew,
          Value<int?> id = const Value.absent(),
          String? orderGuid,
          int? goodsId,
          double? vol,
          double? price,
          double? priceOriginal,
          int? package,
          int? rel}) =>
      OrderLine(
        guid: guid ?? this.guid,
        isDeleted: isDeleted ?? this.isDeleted,
        timestamp: timestamp ?? this.timestamp,
        currentTimestamp: currentTimestamp ?? this.currentTimestamp,
        lastSyncTime:
            lastSyncTime.present ? lastSyncTime.value : this.lastSyncTime,
        needSync: needSync ?? this.needSync,
        isNew: isNew ?? this.isNew,
        id: id.present ? id.value : this.id,
        orderGuid: orderGuid ?? this.orderGuid,
        goodsId: goodsId ?? this.goodsId,
        vol: vol ?? this.vol,
        price: price ?? this.price,
        priceOriginal: priceOriginal ?? this.priceOriginal,
        package: package ?? this.package,
        rel: rel ?? this.rel,
      );
  @override
  String toString() {
    return (StringBuffer('OrderLine(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('needSync: $needSync, ')
          ..write('isNew: $isNew, ')
          ..write('id: $id, ')
          ..write('orderGuid: $orderGuid, ')
          ..write('goodsId: $goodsId, ')
          ..write('vol: $vol, ')
          ..write('price: $price, ')
          ..write('priceOriginal: $priceOriginal, ')
          ..write('package: $package, ')
          ..write('rel: $rel')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      guid,
      isDeleted,
      timestamp,
      currentTimestamp,
      lastSyncTime,
      needSync,
      isNew,
      id,
      orderGuid,
      goodsId,
      vol,
      price,
      priceOriginal,
      package,
      rel);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OrderLine &&
          other.guid == this.guid &&
          other.isDeleted == this.isDeleted &&
          other.timestamp == this.timestamp &&
          other.currentTimestamp == this.currentTimestamp &&
          other.lastSyncTime == this.lastSyncTime &&
          other.needSync == this.needSync &&
          other.isNew == this.isNew &&
          other.id == this.id &&
          other.orderGuid == this.orderGuid &&
          other.goodsId == this.goodsId &&
          other.vol == this.vol &&
          other.price == this.price &&
          other.priceOriginal == this.priceOriginal &&
          other.package == this.package &&
          other.rel == this.rel);
}

class OrderLinesCompanion extends UpdateCompanion<OrderLine> {
  final Value<String> guid;
  final Value<bool> isDeleted;
  final Value<DateTime> timestamp;
  final Value<DateTime> currentTimestamp;
  final Value<DateTime?> lastSyncTime;
  final Value<int?> id;
  final Value<String> orderGuid;
  final Value<int> goodsId;
  final Value<double> vol;
  final Value<double> price;
  final Value<double> priceOriginal;
  final Value<int> package;
  final Value<int> rel;
  final Value<int> rowid;
  const OrderLinesCompanion({
    this.guid = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    this.orderGuid = const Value.absent(),
    this.goodsId = const Value.absent(),
    this.vol = const Value.absent(),
    this.price = const Value.absent(),
    this.priceOriginal = const Value.absent(),
    this.package = const Value.absent(),
    this.rel = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  OrderLinesCompanion.insert({
    required String guid,
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    required String orderGuid,
    required int goodsId,
    required double vol,
    required double price,
    required double priceOriginal,
    required int package,
    required int rel,
    this.rowid = const Value.absent(),
  })  : guid = Value(guid),
        orderGuid = Value(orderGuid),
        goodsId = Value(goodsId),
        vol = Value(vol),
        price = Value(price),
        priceOriginal = Value(priceOriginal),
        package = Value(package),
        rel = Value(rel);
  static Insertable<OrderLine> custom({
    Expression<String>? guid,
    Expression<bool>? isDeleted,
    Expression<DateTime>? timestamp,
    Expression<DateTime>? currentTimestamp,
    Expression<DateTime>? lastSyncTime,
    Expression<int>? id,
    Expression<String>? orderGuid,
    Expression<int>? goodsId,
    Expression<double>? vol,
    Expression<double>? price,
    Expression<double>? priceOriginal,
    Expression<int>? package,
    Expression<int>? rel,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (guid != null) 'guid': guid,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (timestamp != null) 'timestamp': timestamp,
      if (currentTimestamp != null) 'current_timestamp': currentTimestamp,
      if (lastSyncTime != null) 'last_sync_time': lastSyncTime,
      if (id != null) 'id': id,
      if (orderGuid != null) 'order_guid': orderGuid,
      if (goodsId != null) 'goods_id': goodsId,
      if (vol != null) 'vol': vol,
      if (price != null) 'price': price,
      if (priceOriginal != null) 'price_original': priceOriginal,
      if (package != null) 'package': package,
      if (rel != null) 'rel': rel,
      if (rowid != null) 'rowid': rowid,
    });
  }

  OrderLinesCompanion copyWith(
      {Value<String>? guid,
      Value<bool>? isDeleted,
      Value<DateTime>? timestamp,
      Value<DateTime>? currentTimestamp,
      Value<DateTime?>? lastSyncTime,
      Value<int?>? id,
      Value<String>? orderGuid,
      Value<int>? goodsId,
      Value<double>? vol,
      Value<double>? price,
      Value<double>? priceOriginal,
      Value<int>? package,
      Value<int>? rel,
      Value<int>? rowid}) {
    return OrderLinesCompanion(
      guid: guid ?? this.guid,
      isDeleted: isDeleted ?? this.isDeleted,
      timestamp: timestamp ?? this.timestamp,
      currentTimestamp: currentTimestamp ?? this.currentTimestamp,
      lastSyncTime: lastSyncTime ?? this.lastSyncTime,
      id: id ?? this.id,
      orderGuid: orderGuid ?? this.orderGuid,
      goodsId: goodsId ?? this.goodsId,
      vol: vol ?? this.vol,
      price: price ?? this.price,
      priceOriginal: priceOriginal ?? this.priceOriginal,
      package: package ?? this.package,
      rel: rel ?? this.rel,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (guid.present) {
      map['guid'] = Variable<String>(guid.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (currentTimestamp.present) {
      map['current_timestamp'] = Variable<DateTime>(currentTimestamp.value);
    }
    if (lastSyncTime.present) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (orderGuid.present) {
      map['order_guid'] = Variable<String>(orderGuid.value);
    }
    if (goodsId.present) {
      map['goods_id'] = Variable<int>(goodsId.value);
    }
    if (vol.present) {
      map['vol'] = Variable<double>(vol.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (priceOriginal.present) {
      map['price_original'] = Variable<double>(priceOriginal.value);
    }
    if (package.present) {
      map['package'] = Variable<int>(package.value);
    }
    if (rel.present) {
      map['rel'] = Variable<int>(rel.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OrderLinesCompanion(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('id: $id, ')
          ..write('orderGuid: $orderGuid, ')
          ..write('goodsId: $goodsId, ')
          ..write('vol: $vol, ')
          ..write('price: $price, ')
          ..write('priceOriginal: $priceOriginal, ')
          ..write('package: $package, ')
          ..write('rel: $rel, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PreOrdersTable extends PreOrders
    with TableInfo<$PreOrdersTable, PreOrder> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PreOrdersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
      'date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _buyerIdMeta =
      const VerificationMeta('buyerId');
  @override
  late final GeneratedColumn<int> buyerId = GeneratedColumn<int>(
      'buyer_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _needDocsMeta =
      const VerificationMeta('needDocs');
  @override
  late final GeneratedColumn<bool> needDocs = GeneratedColumn<bool>(
      'need_docs', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("need_docs" IN (0, 1))'));
  static const VerificationMeta _infoMeta = const VerificationMeta('info');
  @override
  late final GeneratedColumn<String> info = GeneratedColumn<String>(
      'info', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [id, date, buyerId, needDocs, info];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'pre_orders';
  @override
  VerificationContext validateIntegrity(Insertable<PreOrder> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('date')) {
      context.handle(
          _dateMeta, date.isAcceptableOrUnknown(data['date']!, _dateMeta));
    } else if (isInserting) {
      context.missing(_dateMeta);
    }
    if (data.containsKey('buyer_id')) {
      context.handle(_buyerIdMeta,
          buyerId.isAcceptableOrUnknown(data['buyer_id']!, _buyerIdMeta));
    } else if (isInserting) {
      context.missing(_buyerIdMeta);
    }
    if (data.containsKey('need_docs')) {
      context.handle(_needDocsMeta,
          needDocs.isAcceptableOrUnknown(data['need_docs']!, _needDocsMeta));
    } else if (isInserting) {
      context.missing(_needDocsMeta);
    }
    if (data.containsKey('info')) {
      context.handle(
          _infoMeta, info.isAcceptableOrUnknown(data['info']!, _infoMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  PreOrder map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PreOrder(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      date: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}date'])!,
      buyerId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}buyer_id'])!,
      needDocs: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_docs'])!,
      info: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}info']),
    );
  }

  @override
  $PreOrdersTable createAlias(String alias) {
    return $PreOrdersTable(attachedDatabase, alias);
  }
}

class PreOrder extends DataClass implements Insertable<PreOrder> {
  final int id;
  final DateTime date;
  final int buyerId;
  final bool needDocs;
  final String? info;
  const PreOrder(
      {required this.id,
      required this.date,
      required this.buyerId,
      required this.needDocs,
      this.info});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['date'] = Variable<DateTime>(date);
    map['buyer_id'] = Variable<int>(buyerId);
    map['need_docs'] = Variable<bool>(needDocs);
    if (!nullToAbsent || info != null) {
      map['info'] = Variable<String>(info);
    }
    return map;
  }

  PreOrdersCompanion toCompanion(bool nullToAbsent) {
    return PreOrdersCompanion(
      id: Value(id),
      date: Value(date),
      buyerId: Value(buyerId),
      needDocs: Value(needDocs),
      info: info == null && nullToAbsent ? const Value.absent() : Value(info),
    );
  }

  factory PreOrder.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PreOrder(
      id: serializer.fromJson<int>(json['id']),
      date: serializer.fromJson<DateTime>(json['date']),
      buyerId: serializer.fromJson<int>(json['buyerId']),
      needDocs: serializer.fromJson<bool>(json['needDocs']),
      info: serializer.fromJson<String?>(json['info']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'date': serializer.toJson<DateTime>(date),
      'buyerId': serializer.toJson<int>(buyerId),
      'needDocs': serializer.toJson<bool>(needDocs),
      'info': serializer.toJson<String?>(info),
    };
  }

  PreOrder copyWith(
          {int? id,
          DateTime? date,
          int? buyerId,
          bool? needDocs,
          Value<String?> info = const Value.absent()}) =>
      PreOrder(
        id: id ?? this.id,
        date: date ?? this.date,
        buyerId: buyerId ?? this.buyerId,
        needDocs: needDocs ?? this.needDocs,
        info: info.present ? info.value : this.info,
      );
  PreOrder copyWithCompanion(PreOrdersCompanion data) {
    return PreOrder(
      id: data.id.present ? data.id.value : this.id,
      date: data.date.present ? data.date.value : this.date,
      buyerId: data.buyerId.present ? data.buyerId.value : this.buyerId,
      needDocs: data.needDocs.present ? data.needDocs.value : this.needDocs,
      info: data.info.present ? data.info.value : this.info,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PreOrder(')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('buyerId: $buyerId, ')
          ..write('needDocs: $needDocs, ')
          ..write('info: $info')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, date, buyerId, needDocs, info);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PreOrder &&
          other.id == this.id &&
          other.date == this.date &&
          other.buyerId == this.buyerId &&
          other.needDocs == this.needDocs &&
          other.info == this.info);
}

class PreOrdersCompanion extends UpdateCompanion<PreOrder> {
  final Value<int> id;
  final Value<DateTime> date;
  final Value<int> buyerId;
  final Value<bool> needDocs;
  final Value<String?> info;
  const PreOrdersCompanion({
    this.id = const Value.absent(),
    this.date = const Value.absent(),
    this.buyerId = const Value.absent(),
    this.needDocs = const Value.absent(),
    this.info = const Value.absent(),
  });
  PreOrdersCompanion.insert({
    this.id = const Value.absent(),
    required DateTime date,
    required int buyerId,
    required bool needDocs,
    this.info = const Value.absent(),
  })  : date = Value(date),
        buyerId = Value(buyerId),
        needDocs = Value(needDocs);
  static Insertable<PreOrder> custom({
    Expression<int>? id,
    Expression<DateTime>? date,
    Expression<int>? buyerId,
    Expression<bool>? needDocs,
    Expression<String>? info,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (date != null) 'date': date,
      if (buyerId != null) 'buyer_id': buyerId,
      if (needDocs != null) 'need_docs': needDocs,
      if (info != null) 'info': info,
    });
  }

  PreOrdersCompanion copyWith(
      {Value<int>? id,
      Value<DateTime>? date,
      Value<int>? buyerId,
      Value<bool>? needDocs,
      Value<String?>? info}) {
    return PreOrdersCompanion(
      id: id ?? this.id,
      date: date ?? this.date,
      buyerId: buyerId ?? this.buyerId,
      needDocs: needDocs ?? this.needDocs,
      info: info ?? this.info,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (buyerId.present) {
      map['buyer_id'] = Variable<int>(buyerId.value);
    }
    if (needDocs.present) {
      map['need_docs'] = Variable<bool>(needDocs.value);
    }
    if (info.present) {
      map['info'] = Variable<String>(info.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PreOrdersCompanion(')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('buyerId: $buyerId, ')
          ..write('needDocs: $needDocs, ')
          ..write('info: $info')
          ..write(')'))
        .toString();
  }
}

class $PreOrderLinesTable extends PreOrderLines
    with TableInfo<$PreOrderLinesTable, PreOrderLine> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PreOrderLinesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _preOrderIdMeta =
      const VerificationMeta('preOrderId');
  @override
  late final GeneratedColumn<int> preOrderId = GeneratedColumn<int>(
      'pre_order_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _goodsIdMeta =
      const VerificationMeta('goodsId');
  @override
  late final GeneratedColumn<int> goodsId = GeneratedColumn<int>(
      'goods_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _volMeta = const VerificationMeta('vol');
  @override
  late final GeneratedColumn<double> vol = GeneratedColumn<double>(
      'vol', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  @override
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
      'price', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _packageMeta =
      const VerificationMeta('package');
  @override
  late final GeneratedColumn<int> package = GeneratedColumn<int>(
      'package', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _relMeta = const VerificationMeta('rel');
  @override
  late final GeneratedColumn<int> rel = GeneratedColumn<int>(
      'rel', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [id, preOrderId, goodsId, vol, price, package, rel];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'pre_order_lines';
  @override
  VerificationContext validateIntegrity(Insertable<PreOrderLine> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('pre_order_id')) {
      context.handle(
          _preOrderIdMeta,
          preOrderId.isAcceptableOrUnknown(
              data['pre_order_id']!, _preOrderIdMeta));
    } else if (isInserting) {
      context.missing(_preOrderIdMeta);
    }
    if (data.containsKey('goods_id')) {
      context.handle(_goodsIdMeta,
          goodsId.isAcceptableOrUnknown(data['goods_id']!, _goodsIdMeta));
    } else if (isInserting) {
      context.missing(_goodsIdMeta);
    }
    if (data.containsKey('vol')) {
      context.handle(
          _volMeta, vol.isAcceptableOrUnknown(data['vol']!, _volMeta));
    } else if (isInserting) {
      context.missing(_volMeta);
    }
    if (data.containsKey('price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['price']!, _priceMeta));
    } else if (isInserting) {
      context.missing(_priceMeta);
    }
    if (data.containsKey('package')) {
      context.handle(_packageMeta,
          package.isAcceptableOrUnknown(data['package']!, _packageMeta));
    } else if (isInserting) {
      context.missing(_packageMeta);
    }
    if (data.containsKey('rel')) {
      context.handle(
          _relMeta, rel.isAcceptableOrUnknown(data['rel']!, _relMeta));
    } else if (isInserting) {
      context.missing(_relMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  PreOrderLine map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PreOrderLine(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      preOrderId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}pre_order_id'])!,
      goodsId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}goods_id'])!,
      vol: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}vol'])!,
      price: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}price'])!,
      package: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}package'])!,
      rel: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}rel'])!,
    );
  }

  @override
  $PreOrderLinesTable createAlias(String alias) {
    return $PreOrderLinesTable(attachedDatabase, alias);
  }
}

class PreOrderLine extends DataClass implements Insertable<PreOrderLine> {
  final int id;
  final int preOrderId;
  final int goodsId;
  final double vol;
  final double price;
  final int package;
  final int rel;
  const PreOrderLine(
      {required this.id,
      required this.preOrderId,
      required this.goodsId,
      required this.vol,
      required this.price,
      required this.package,
      required this.rel});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['pre_order_id'] = Variable<int>(preOrderId);
    map['goods_id'] = Variable<int>(goodsId);
    map['vol'] = Variable<double>(vol);
    map['price'] = Variable<double>(price);
    map['package'] = Variable<int>(package);
    map['rel'] = Variable<int>(rel);
    return map;
  }

  PreOrderLinesCompanion toCompanion(bool nullToAbsent) {
    return PreOrderLinesCompanion(
      id: Value(id),
      preOrderId: Value(preOrderId),
      goodsId: Value(goodsId),
      vol: Value(vol),
      price: Value(price),
      package: Value(package),
      rel: Value(rel),
    );
  }

  factory PreOrderLine.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PreOrderLine(
      id: serializer.fromJson<int>(json['id']),
      preOrderId: serializer.fromJson<int>(json['preOrderId']),
      goodsId: serializer.fromJson<int>(json['goodsId']),
      vol: serializer.fromJson<double>(json['vol']),
      price: serializer.fromJson<double>(json['price']),
      package: serializer.fromJson<int>(json['package']),
      rel: serializer.fromJson<int>(json['rel']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'preOrderId': serializer.toJson<int>(preOrderId),
      'goodsId': serializer.toJson<int>(goodsId),
      'vol': serializer.toJson<double>(vol),
      'price': serializer.toJson<double>(price),
      'package': serializer.toJson<int>(package),
      'rel': serializer.toJson<int>(rel),
    };
  }

  PreOrderLine copyWith(
          {int? id,
          int? preOrderId,
          int? goodsId,
          double? vol,
          double? price,
          int? package,
          int? rel}) =>
      PreOrderLine(
        id: id ?? this.id,
        preOrderId: preOrderId ?? this.preOrderId,
        goodsId: goodsId ?? this.goodsId,
        vol: vol ?? this.vol,
        price: price ?? this.price,
        package: package ?? this.package,
        rel: rel ?? this.rel,
      );
  PreOrderLine copyWithCompanion(PreOrderLinesCompanion data) {
    return PreOrderLine(
      id: data.id.present ? data.id.value : this.id,
      preOrderId:
          data.preOrderId.present ? data.preOrderId.value : this.preOrderId,
      goodsId: data.goodsId.present ? data.goodsId.value : this.goodsId,
      vol: data.vol.present ? data.vol.value : this.vol,
      price: data.price.present ? data.price.value : this.price,
      package: data.package.present ? data.package.value : this.package,
      rel: data.rel.present ? data.rel.value : this.rel,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PreOrderLine(')
          ..write('id: $id, ')
          ..write('preOrderId: $preOrderId, ')
          ..write('goodsId: $goodsId, ')
          ..write('vol: $vol, ')
          ..write('price: $price, ')
          ..write('package: $package, ')
          ..write('rel: $rel')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, preOrderId, goodsId, vol, price, package, rel);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PreOrderLine &&
          other.id == this.id &&
          other.preOrderId == this.preOrderId &&
          other.goodsId == this.goodsId &&
          other.vol == this.vol &&
          other.price == this.price &&
          other.package == this.package &&
          other.rel == this.rel);
}

class PreOrderLinesCompanion extends UpdateCompanion<PreOrderLine> {
  final Value<int> id;
  final Value<int> preOrderId;
  final Value<int> goodsId;
  final Value<double> vol;
  final Value<double> price;
  final Value<int> package;
  final Value<int> rel;
  const PreOrderLinesCompanion({
    this.id = const Value.absent(),
    this.preOrderId = const Value.absent(),
    this.goodsId = const Value.absent(),
    this.vol = const Value.absent(),
    this.price = const Value.absent(),
    this.package = const Value.absent(),
    this.rel = const Value.absent(),
  });
  PreOrderLinesCompanion.insert({
    this.id = const Value.absent(),
    required int preOrderId,
    required int goodsId,
    required double vol,
    required double price,
    required int package,
    required int rel,
  })  : preOrderId = Value(preOrderId),
        goodsId = Value(goodsId),
        vol = Value(vol),
        price = Value(price),
        package = Value(package),
        rel = Value(rel);
  static Insertable<PreOrderLine> custom({
    Expression<int>? id,
    Expression<int>? preOrderId,
    Expression<int>? goodsId,
    Expression<double>? vol,
    Expression<double>? price,
    Expression<int>? package,
    Expression<int>? rel,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (preOrderId != null) 'pre_order_id': preOrderId,
      if (goodsId != null) 'goods_id': goodsId,
      if (vol != null) 'vol': vol,
      if (price != null) 'price': price,
      if (package != null) 'package': package,
      if (rel != null) 'rel': rel,
    });
  }

  PreOrderLinesCompanion copyWith(
      {Value<int>? id,
      Value<int>? preOrderId,
      Value<int>? goodsId,
      Value<double>? vol,
      Value<double>? price,
      Value<int>? package,
      Value<int>? rel}) {
    return PreOrderLinesCompanion(
      id: id ?? this.id,
      preOrderId: preOrderId ?? this.preOrderId,
      goodsId: goodsId ?? this.goodsId,
      vol: vol ?? this.vol,
      price: price ?? this.price,
      package: package ?? this.package,
      rel: rel ?? this.rel,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (preOrderId.present) {
      map['pre_order_id'] = Variable<int>(preOrderId.value);
    }
    if (goodsId.present) {
      map['goods_id'] = Variable<int>(goodsId.value);
    }
    if (vol.present) {
      map['vol'] = Variable<double>(vol.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (package.present) {
      map['package'] = Variable<int>(package.value);
    }
    if (rel.present) {
      map['rel'] = Variable<int>(rel.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PreOrderLinesCompanion(')
          ..write('id: $id, ')
          ..write('preOrderId: $preOrderId, ')
          ..write('goodsId: $goodsId, ')
          ..write('vol: $vol, ')
          ..write('price: $price, ')
          ..write('package: $package, ')
          ..write('rel: $rel')
          ..write(')'))
        .toString();
  }
}

class $SeenPreOrdersTable extends SeenPreOrders
    with TableInfo<$SeenPreOrdersTable, SeenPreOrder> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SeenPreOrdersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  @override
  List<GeneratedColumn> get $columns => [id];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'seen_pre_orders';
  @override
  VerificationContext validateIntegrity(Insertable<SeenPreOrder> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SeenPreOrder map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SeenPreOrder(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
    );
  }

  @override
  $SeenPreOrdersTable createAlias(String alias) {
    return $SeenPreOrdersTable(attachedDatabase, alias);
  }
}

class SeenPreOrder extends DataClass implements Insertable<SeenPreOrder> {
  final int id;
  const SeenPreOrder({required this.id});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    return map;
  }

  SeenPreOrdersCompanion toCompanion(bool nullToAbsent) {
    return SeenPreOrdersCompanion(
      id: Value(id),
    );
  }

  factory SeenPreOrder.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SeenPreOrder(
      id: serializer.fromJson<int>(json['id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
    };
  }

  SeenPreOrder copyWith({int? id}) => SeenPreOrder(
        id: id ?? this.id,
      );
  SeenPreOrder copyWithCompanion(SeenPreOrdersCompanion data) {
    return SeenPreOrder(
      id: data.id.present ? data.id.value : this.id,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SeenPreOrder(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => id.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) || (other is SeenPreOrder && other.id == this.id);
}

class SeenPreOrdersCompanion extends UpdateCompanion<SeenPreOrder> {
  final Value<int> id;
  const SeenPreOrdersCompanion({
    this.id = const Value.absent(),
  });
  SeenPreOrdersCompanion.insert({
    this.id = const Value.absent(),
  });
  static Insertable<SeenPreOrder> custom({
    Expression<int>? id,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
    });
  }

  SeenPreOrdersCompanion copyWith({Value<int>? id}) {
    return SeenPreOrdersCompanion(
      id: id ?? this.id,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SeenPreOrdersCompanion(')
          ..write('id: $id')
          ..write(')'))
        .toString();
  }
}

class $BonusProgramGroupsTable extends BonusProgramGroups
    with TableInfo<$BonusProgramGroupsTable, BonusProgramGroup> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BonusProgramGroupsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [id, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'bonus_program_groups';
  @override
  VerificationContext validateIntegrity(Insertable<BonusProgramGroup> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  BonusProgramGroup map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BonusProgramGroup(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $BonusProgramGroupsTable createAlias(String alias) {
    return $BonusProgramGroupsTable(attachedDatabase, alias);
  }
}

class BonusProgramGroup extends DataClass
    implements Insertable<BonusProgramGroup> {
  final int id;
  final String name;
  const BonusProgramGroup({required this.id, required this.name});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    return map;
  }

  BonusProgramGroupsCompanion toCompanion(bool nullToAbsent) {
    return BonusProgramGroupsCompanion(
      id: Value(id),
      name: Value(name),
    );
  }

  factory BonusProgramGroup.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BonusProgramGroup(
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
    };
  }

  BonusProgramGroup copyWith({int? id, String? name}) => BonusProgramGroup(
        id: id ?? this.id,
        name: name ?? this.name,
      );
  BonusProgramGroup copyWithCompanion(BonusProgramGroupsCompanion data) {
    return BonusProgramGroup(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BonusProgramGroup(')
          ..write('id: $id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BonusProgramGroup &&
          other.id == this.id &&
          other.name == this.name);
}

class BonusProgramGroupsCompanion extends UpdateCompanion<BonusProgramGroup> {
  final Value<int> id;
  final Value<String> name;
  const BonusProgramGroupsCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
  });
  BonusProgramGroupsCompanion.insert({
    this.id = const Value.absent(),
    required String name,
  }) : name = Value(name);
  static Insertable<BonusProgramGroup> custom({
    Expression<int>? id,
    Expression<String>? name,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
    });
  }

  BonusProgramGroupsCompanion copyWith({Value<int>? id, Value<String>? name}) {
    return BonusProgramGroupsCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BonusProgramGroupsCompanion(')
          ..write('id: $id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class $BonusProgramsTable extends BonusPrograms
    with TableInfo<$BonusProgramsTable, BonusProgram> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BonusProgramsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _dateFromMeta =
      const VerificationMeta('dateFrom');
  @override
  late final GeneratedColumn<DateTime> dateFrom = GeneratedColumn<DateTime>(
      'date_from', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _dateToMeta = const VerificationMeta('dateTo');
  @override
  late final GeneratedColumn<DateTime> dateTo = GeneratedColumn<DateTime>(
      'date_to', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _conditionMeta =
      const VerificationMeta('condition');
  @override
  late final GeneratedColumn<String> condition = GeneratedColumn<String>(
      'condition', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _presentMeta =
      const VerificationMeta('present');
  @override
  late final GeneratedColumn<String> present = GeneratedColumn<String>(
      'present', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tagTextMeta =
      const VerificationMeta('tagText');
  @override
  late final GeneratedColumn<String> tagText = GeneratedColumn<String>(
      'tag_text', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _discountMeta =
      const VerificationMeta('discount');
  @override
  late final GeneratedColumn<double> discount = GeneratedColumn<double>(
      'discount', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _coefMeta = const VerificationMeta('coef');
  @override
  late final GeneratedColumn<double> coef = GeneratedColumn<double>(
      'coef', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _conditionalDiscountMeta =
      const VerificationMeta('conditionalDiscount');
  @override
  late final GeneratedColumn<int> conditionalDiscount = GeneratedColumn<int>(
      'conditional_discount', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _bonusProgramGroupIdMeta =
      const VerificationMeta('bonusProgramGroupId');
  @override
  late final GeneratedColumn<int> bonusProgramGroupId = GeneratedColumn<int>(
      'bonus_program_group_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        name,
        dateFrom,
        dateTo,
        condition,
        present,
        tagText,
        discount,
        coef,
        conditionalDiscount,
        bonusProgramGroupId
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'bonus_programs';
  @override
  VerificationContext validateIntegrity(Insertable<BonusProgram> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('date_from')) {
      context.handle(_dateFromMeta,
          dateFrom.isAcceptableOrUnknown(data['date_from']!, _dateFromMeta));
    } else if (isInserting) {
      context.missing(_dateFromMeta);
    }
    if (data.containsKey('date_to')) {
      context.handle(_dateToMeta,
          dateTo.isAcceptableOrUnknown(data['date_to']!, _dateToMeta));
    } else if (isInserting) {
      context.missing(_dateToMeta);
    }
    if (data.containsKey('condition')) {
      context.handle(_conditionMeta,
          condition.isAcceptableOrUnknown(data['condition']!, _conditionMeta));
    } else if (isInserting) {
      context.missing(_conditionMeta);
    }
    if (data.containsKey('present')) {
      context.handle(_presentMeta,
          present.isAcceptableOrUnknown(data['present']!, _presentMeta));
    } else if (isInserting) {
      context.missing(_presentMeta);
    }
    if (data.containsKey('tag_text')) {
      context.handle(_tagTextMeta,
          tagText.isAcceptableOrUnknown(data['tag_text']!, _tagTextMeta));
    } else if (isInserting) {
      context.missing(_tagTextMeta);
    }
    if (data.containsKey('discount')) {
      context.handle(_discountMeta,
          discount.isAcceptableOrUnknown(data['discount']!, _discountMeta));
    } else if (isInserting) {
      context.missing(_discountMeta);
    }
    if (data.containsKey('coef')) {
      context.handle(
          _coefMeta, coef.isAcceptableOrUnknown(data['coef']!, _coefMeta));
    } else if (isInserting) {
      context.missing(_coefMeta);
    }
    if (data.containsKey('conditional_discount')) {
      context.handle(
          _conditionalDiscountMeta,
          conditionalDiscount.isAcceptableOrUnknown(
              data['conditional_discount']!, _conditionalDiscountMeta));
    } else if (isInserting) {
      context.missing(_conditionalDiscountMeta);
    }
    if (data.containsKey('bonus_program_group_id')) {
      context.handle(
          _bonusProgramGroupIdMeta,
          bonusProgramGroupId.isAcceptableOrUnknown(
              data['bonus_program_group_id']!, _bonusProgramGroupIdMeta));
    } else if (isInserting) {
      context.missing(_bonusProgramGroupIdMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  BonusProgram map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BonusProgram(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      dateFrom: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}date_from'])!,
      dateTo: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}date_to'])!,
      condition: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}condition'])!,
      present: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}present'])!,
      tagText: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tag_text'])!,
      discount: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}discount'])!,
      coef: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}coef'])!,
      conditionalDiscount: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}conditional_discount'])!,
      bonusProgramGroupId: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}bonus_program_group_id'])!,
    );
  }

  @override
  $BonusProgramsTable createAlias(String alias) {
    return $BonusProgramsTable(attachedDatabase, alias);
  }
}

class BonusProgram extends DataClass implements Insertable<BonusProgram> {
  final int id;
  final String name;
  final DateTime dateFrom;
  final DateTime dateTo;
  final String condition;
  final String present;
  final String tagText;
  final double discount;
  final double coef;
  final int conditionalDiscount;
  final int bonusProgramGroupId;
  const BonusProgram(
      {required this.id,
      required this.name,
      required this.dateFrom,
      required this.dateTo,
      required this.condition,
      required this.present,
      required this.tagText,
      required this.discount,
      required this.coef,
      required this.conditionalDiscount,
      required this.bonusProgramGroupId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    map['date_from'] = Variable<DateTime>(dateFrom);
    map['date_to'] = Variable<DateTime>(dateTo);
    map['condition'] = Variable<String>(condition);
    map['present'] = Variable<String>(present);
    map['tag_text'] = Variable<String>(tagText);
    map['discount'] = Variable<double>(discount);
    map['coef'] = Variable<double>(coef);
    map['conditional_discount'] = Variable<int>(conditionalDiscount);
    map['bonus_program_group_id'] = Variable<int>(bonusProgramGroupId);
    return map;
  }

  BonusProgramsCompanion toCompanion(bool nullToAbsent) {
    return BonusProgramsCompanion(
      id: Value(id),
      name: Value(name),
      dateFrom: Value(dateFrom),
      dateTo: Value(dateTo),
      condition: Value(condition),
      present: Value(present),
      tagText: Value(tagText),
      discount: Value(discount),
      coef: Value(coef),
      conditionalDiscount: Value(conditionalDiscount),
      bonusProgramGroupId: Value(bonusProgramGroupId),
    );
  }

  factory BonusProgram.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BonusProgram(
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      dateFrom: serializer.fromJson<DateTime>(json['dateFrom']),
      dateTo: serializer.fromJson<DateTime>(json['dateTo']),
      condition: serializer.fromJson<String>(json['condition']),
      present: serializer.fromJson<String>(json['present']),
      tagText: serializer.fromJson<String>(json['tagText']),
      discount: serializer.fromJson<double>(json['discount']),
      coef: serializer.fromJson<double>(json['coef']),
      conditionalDiscount:
          serializer.fromJson<int>(json['conditionalDiscount']),
      bonusProgramGroupId:
          serializer.fromJson<int>(json['bonusProgramGroupId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
      'dateFrom': serializer.toJson<DateTime>(dateFrom),
      'dateTo': serializer.toJson<DateTime>(dateTo),
      'condition': serializer.toJson<String>(condition),
      'present': serializer.toJson<String>(present),
      'tagText': serializer.toJson<String>(tagText),
      'discount': serializer.toJson<double>(discount),
      'coef': serializer.toJson<double>(coef),
      'conditionalDiscount': serializer.toJson<int>(conditionalDiscount),
      'bonusProgramGroupId': serializer.toJson<int>(bonusProgramGroupId),
    };
  }

  BonusProgram copyWith(
          {int? id,
          String? name,
          DateTime? dateFrom,
          DateTime? dateTo,
          String? condition,
          String? present,
          String? tagText,
          double? discount,
          double? coef,
          int? conditionalDiscount,
          int? bonusProgramGroupId}) =>
      BonusProgram(
        id: id ?? this.id,
        name: name ?? this.name,
        dateFrom: dateFrom ?? this.dateFrom,
        dateTo: dateTo ?? this.dateTo,
        condition: condition ?? this.condition,
        present: present ?? this.present,
        tagText: tagText ?? this.tagText,
        discount: discount ?? this.discount,
        coef: coef ?? this.coef,
        conditionalDiscount: conditionalDiscount ?? this.conditionalDiscount,
        bonusProgramGroupId: bonusProgramGroupId ?? this.bonusProgramGroupId,
      );
  BonusProgram copyWithCompanion(BonusProgramsCompanion data) {
    return BonusProgram(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      dateFrom: data.dateFrom.present ? data.dateFrom.value : this.dateFrom,
      dateTo: data.dateTo.present ? data.dateTo.value : this.dateTo,
      condition: data.condition.present ? data.condition.value : this.condition,
      present: data.present.present ? data.present.value : this.present,
      tagText: data.tagText.present ? data.tagText.value : this.tagText,
      discount: data.discount.present ? data.discount.value : this.discount,
      coef: data.coef.present ? data.coef.value : this.coef,
      conditionalDiscount: data.conditionalDiscount.present
          ? data.conditionalDiscount.value
          : this.conditionalDiscount,
      bonusProgramGroupId: data.bonusProgramGroupId.present
          ? data.bonusProgramGroupId.value
          : this.bonusProgramGroupId,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BonusProgram(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('dateFrom: $dateFrom, ')
          ..write('dateTo: $dateTo, ')
          ..write('condition: $condition, ')
          ..write('present: $present, ')
          ..write('tagText: $tagText, ')
          ..write('discount: $discount, ')
          ..write('coef: $coef, ')
          ..write('conditionalDiscount: $conditionalDiscount, ')
          ..write('bonusProgramGroupId: $bonusProgramGroupId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      name,
      dateFrom,
      dateTo,
      condition,
      present,
      tagText,
      discount,
      coef,
      conditionalDiscount,
      bonusProgramGroupId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BonusProgram &&
          other.id == this.id &&
          other.name == this.name &&
          other.dateFrom == this.dateFrom &&
          other.dateTo == this.dateTo &&
          other.condition == this.condition &&
          other.present == this.present &&
          other.tagText == this.tagText &&
          other.discount == this.discount &&
          other.coef == this.coef &&
          other.conditionalDiscount == this.conditionalDiscount &&
          other.bonusProgramGroupId == this.bonusProgramGroupId);
}

class BonusProgramsCompanion extends UpdateCompanion<BonusProgram> {
  final Value<int> id;
  final Value<String> name;
  final Value<DateTime> dateFrom;
  final Value<DateTime> dateTo;
  final Value<String> condition;
  final Value<String> present;
  final Value<String> tagText;
  final Value<double> discount;
  final Value<double> coef;
  final Value<int> conditionalDiscount;
  final Value<int> bonusProgramGroupId;
  const BonusProgramsCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.dateFrom = const Value.absent(),
    this.dateTo = const Value.absent(),
    this.condition = const Value.absent(),
    this.present = const Value.absent(),
    this.tagText = const Value.absent(),
    this.discount = const Value.absent(),
    this.coef = const Value.absent(),
    this.conditionalDiscount = const Value.absent(),
    this.bonusProgramGroupId = const Value.absent(),
  });
  BonusProgramsCompanion.insert({
    this.id = const Value.absent(),
    required String name,
    required DateTime dateFrom,
    required DateTime dateTo,
    required String condition,
    required String present,
    required String tagText,
    required double discount,
    required double coef,
    required int conditionalDiscount,
    required int bonusProgramGroupId,
  })  : name = Value(name),
        dateFrom = Value(dateFrom),
        dateTo = Value(dateTo),
        condition = Value(condition),
        present = Value(present),
        tagText = Value(tagText),
        discount = Value(discount),
        coef = Value(coef),
        conditionalDiscount = Value(conditionalDiscount),
        bonusProgramGroupId = Value(bonusProgramGroupId);
  static Insertable<BonusProgram> custom({
    Expression<int>? id,
    Expression<String>? name,
    Expression<DateTime>? dateFrom,
    Expression<DateTime>? dateTo,
    Expression<String>? condition,
    Expression<String>? present,
    Expression<String>? tagText,
    Expression<double>? discount,
    Expression<double>? coef,
    Expression<int>? conditionalDiscount,
    Expression<int>? bonusProgramGroupId,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (dateFrom != null) 'date_from': dateFrom,
      if (dateTo != null) 'date_to': dateTo,
      if (condition != null) 'condition': condition,
      if (present != null) 'present': present,
      if (tagText != null) 'tag_text': tagText,
      if (discount != null) 'discount': discount,
      if (coef != null) 'coef': coef,
      if (conditionalDiscount != null)
        'conditional_discount': conditionalDiscount,
      if (bonusProgramGroupId != null)
        'bonus_program_group_id': bonusProgramGroupId,
    });
  }

  BonusProgramsCompanion copyWith(
      {Value<int>? id,
      Value<String>? name,
      Value<DateTime>? dateFrom,
      Value<DateTime>? dateTo,
      Value<String>? condition,
      Value<String>? present,
      Value<String>? tagText,
      Value<double>? discount,
      Value<double>? coef,
      Value<int>? conditionalDiscount,
      Value<int>? bonusProgramGroupId}) {
    return BonusProgramsCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      dateFrom: dateFrom ?? this.dateFrom,
      dateTo: dateTo ?? this.dateTo,
      condition: condition ?? this.condition,
      present: present ?? this.present,
      tagText: tagText ?? this.tagText,
      discount: discount ?? this.discount,
      coef: coef ?? this.coef,
      conditionalDiscount: conditionalDiscount ?? this.conditionalDiscount,
      bonusProgramGroupId: bonusProgramGroupId ?? this.bonusProgramGroupId,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (dateFrom.present) {
      map['date_from'] = Variable<DateTime>(dateFrom.value);
    }
    if (dateTo.present) {
      map['date_to'] = Variable<DateTime>(dateTo.value);
    }
    if (condition.present) {
      map['condition'] = Variable<String>(condition.value);
    }
    if (present.present) {
      map['present'] = Variable<String>(present.value);
    }
    if (tagText.present) {
      map['tag_text'] = Variable<String>(tagText.value);
    }
    if (discount.present) {
      map['discount'] = Variable<double>(discount.value);
    }
    if (coef.present) {
      map['coef'] = Variable<double>(coef.value);
    }
    if (conditionalDiscount.present) {
      map['conditional_discount'] = Variable<int>(conditionalDiscount.value);
    }
    if (bonusProgramGroupId.present) {
      map['bonus_program_group_id'] = Variable<int>(bonusProgramGroupId.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BonusProgramsCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('dateFrom: $dateFrom, ')
          ..write('dateTo: $dateTo, ')
          ..write('condition: $condition, ')
          ..write('present: $present, ')
          ..write('tagText: $tagText, ')
          ..write('discount: $discount, ')
          ..write('coef: $coef, ')
          ..write('conditionalDiscount: $conditionalDiscount, ')
          ..write('bonusProgramGroupId: $bonusProgramGroupId')
          ..write(')'))
        .toString();
  }
}

class $BuyersSetsTable extends BuyersSets
    with TableInfo<$BuyersSetsTable, BuyersSet> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BuyersSetsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [id, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'buyers_sets';
  @override
  VerificationContext validateIntegrity(Insertable<BuyersSet> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  BuyersSet map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BuyersSet(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $BuyersSetsTable createAlias(String alias) {
    return $BuyersSetsTable(attachedDatabase, alias);
  }
}

class BuyersSet extends DataClass implements Insertable<BuyersSet> {
  final int id;
  final String name;
  const BuyersSet({required this.id, required this.name});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    return map;
  }

  BuyersSetsCompanion toCompanion(bool nullToAbsent) {
    return BuyersSetsCompanion(
      id: Value(id),
      name: Value(name),
    );
  }

  factory BuyersSet.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BuyersSet(
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
    };
  }

  BuyersSet copyWith({int? id, String? name}) => BuyersSet(
        id: id ?? this.id,
        name: name ?? this.name,
      );
  BuyersSet copyWithCompanion(BuyersSetsCompanion data) {
    return BuyersSet(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BuyersSet(')
          ..write('id: $id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BuyersSet && other.id == this.id && other.name == this.name);
}

class BuyersSetsCompanion extends UpdateCompanion<BuyersSet> {
  final Value<int> id;
  final Value<String> name;
  const BuyersSetsCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
  });
  BuyersSetsCompanion.insert({
    this.id = const Value.absent(),
    required String name,
  }) : name = Value(name);
  static Insertable<BuyersSet> custom({
    Expression<int>? id,
    Expression<String>? name,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
    });
  }

  BuyersSetsCompanion copyWith({Value<int>? id, Value<String>? name}) {
    return BuyersSetsCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BuyersSetsCompanion(')
          ..write('id: $id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class $BuyersSetsBonusProgramsTable extends BuyersSetsBonusPrograms
    with TableInfo<$BuyersSetsBonusProgramsTable, BuyersSetsBonusProgram> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BuyersSetsBonusProgramsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _buyersSetIdMeta =
      const VerificationMeta('buyersSetId');
  @override
  late final GeneratedColumn<int> buyersSetId = GeneratedColumn<int>(
      'buyers_set_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _bonusProgramIdMeta =
      const VerificationMeta('bonusProgramId');
  @override
  late final GeneratedColumn<int> bonusProgramId = GeneratedColumn<int>(
      'bonus_program_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [buyersSetId, bonusProgramId];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'buyers_sets_bonus_programs';
  @override
  VerificationContext validateIntegrity(
      Insertable<BuyersSetsBonusProgram> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('buyers_set_id')) {
      context.handle(
          _buyersSetIdMeta,
          buyersSetId.isAcceptableOrUnknown(
              data['buyers_set_id']!, _buyersSetIdMeta));
    } else if (isInserting) {
      context.missing(_buyersSetIdMeta);
    }
    if (data.containsKey('bonus_program_id')) {
      context.handle(
          _bonusProgramIdMeta,
          bonusProgramId.isAcceptableOrUnknown(
              data['bonus_program_id']!, _bonusProgramIdMeta));
    } else if (isInserting) {
      context.missing(_bonusProgramIdMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {buyersSetId, bonusProgramId};
  @override
  BuyersSetsBonusProgram map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BuyersSetsBonusProgram(
      buyersSetId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}buyers_set_id'])!,
      bonusProgramId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}bonus_program_id'])!,
    );
  }

  @override
  $BuyersSetsBonusProgramsTable createAlias(String alias) {
    return $BuyersSetsBonusProgramsTable(attachedDatabase, alias);
  }
}

class BuyersSetsBonusProgram extends DataClass
    implements Insertable<BuyersSetsBonusProgram> {
  final int buyersSetId;
  final int bonusProgramId;
  const BuyersSetsBonusProgram(
      {required this.buyersSetId, required this.bonusProgramId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['buyers_set_id'] = Variable<int>(buyersSetId);
    map['bonus_program_id'] = Variable<int>(bonusProgramId);
    return map;
  }

  BuyersSetsBonusProgramsCompanion toCompanion(bool nullToAbsent) {
    return BuyersSetsBonusProgramsCompanion(
      buyersSetId: Value(buyersSetId),
      bonusProgramId: Value(bonusProgramId),
    );
  }

  factory BuyersSetsBonusProgram.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BuyersSetsBonusProgram(
      buyersSetId: serializer.fromJson<int>(json['buyersSetId']),
      bonusProgramId: serializer.fromJson<int>(json['bonusProgramId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'buyersSetId': serializer.toJson<int>(buyersSetId),
      'bonusProgramId': serializer.toJson<int>(bonusProgramId),
    };
  }

  BuyersSetsBonusProgram copyWith({int? buyersSetId, int? bonusProgramId}) =>
      BuyersSetsBonusProgram(
        buyersSetId: buyersSetId ?? this.buyersSetId,
        bonusProgramId: bonusProgramId ?? this.bonusProgramId,
      );
  BuyersSetsBonusProgram copyWithCompanion(
      BuyersSetsBonusProgramsCompanion data) {
    return BuyersSetsBonusProgram(
      buyersSetId:
          data.buyersSetId.present ? data.buyersSetId.value : this.buyersSetId,
      bonusProgramId: data.bonusProgramId.present
          ? data.bonusProgramId.value
          : this.bonusProgramId,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BuyersSetsBonusProgram(')
          ..write('buyersSetId: $buyersSetId, ')
          ..write('bonusProgramId: $bonusProgramId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(buyersSetId, bonusProgramId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BuyersSetsBonusProgram &&
          other.buyersSetId == this.buyersSetId &&
          other.bonusProgramId == this.bonusProgramId);
}

class BuyersSetsBonusProgramsCompanion
    extends UpdateCompanion<BuyersSetsBonusProgram> {
  final Value<int> buyersSetId;
  final Value<int> bonusProgramId;
  final Value<int> rowid;
  const BuyersSetsBonusProgramsCompanion({
    this.buyersSetId = const Value.absent(),
    this.bonusProgramId = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BuyersSetsBonusProgramsCompanion.insert({
    required int buyersSetId,
    required int bonusProgramId,
    this.rowid = const Value.absent(),
  })  : buyersSetId = Value(buyersSetId),
        bonusProgramId = Value(bonusProgramId);
  static Insertable<BuyersSetsBonusProgram> custom({
    Expression<int>? buyersSetId,
    Expression<int>? bonusProgramId,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (buyersSetId != null) 'buyers_set_id': buyersSetId,
      if (bonusProgramId != null) 'bonus_program_id': bonusProgramId,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BuyersSetsBonusProgramsCompanion copyWith(
      {Value<int>? buyersSetId,
      Value<int>? bonusProgramId,
      Value<int>? rowid}) {
    return BuyersSetsBonusProgramsCompanion(
      buyersSetId: buyersSetId ?? this.buyersSetId,
      bonusProgramId: bonusProgramId ?? this.bonusProgramId,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (buyersSetId.present) {
      map['buyers_set_id'] = Variable<int>(buyersSetId.value);
    }
    if (bonusProgramId.present) {
      map['bonus_program_id'] = Variable<int>(bonusProgramId.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BuyersSetsBonusProgramsCompanion(')
          ..write('buyersSetId: $buyersSetId, ')
          ..write('bonusProgramId: $bonusProgramId, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BuyersSetsBuyersTable extends BuyersSetsBuyers
    with TableInfo<$BuyersSetsBuyersTable, BuyersSetsBuyer> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BuyersSetsBuyersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _buyersSetIdMeta =
      const VerificationMeta('buyersSetId');
  @override
  late final GeneratedColumn<int> buyersSetId = GeneratedColumn<int>(
      'buyers_set_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _buyerIdMeta =
      const VerificationMeta('buyerId');
  @override
  late final GeneratedColumn<int> buyerId = GeneratedColumn<int>(
      'buyer_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [buyersSetId, buyerId];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'buyers_sets_buyers';
  @override
  VerificationContext validateIntegrity(Insertable<BuyersSetsBuyer> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('buyers_set_id')) {
      context.handle(
          _buyersSetIdMeta,
          buyersSetId.isAcceptableOrUnknown(
              data['buyers_set_id']!, _buyersSetIdMeta));
    } else if (isInserting) {
      context.missing(_buyersSetIdMeta);
    }
    if (data.containsKey('buyer_id')) {
      context.handle(_buyerIdMeta,
          buyerId.isAcceptableOrUnknown(data['buyer_id']!, _buyerIdMeta));
    } else if (isInserting) {
      context.missing(_buyerIdMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {buyersSetId, buyerId};
  @override
  BuyersSetsBuyer map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BuyersSetsBuyer(
      buyersSetId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}buyers_set_id'])!,
      buyerId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}buyer_id'])!,
    );
  }

  @override
  $BuyersSetsBuyersTable createAlias(String alias) {
    return $BuyersSetsBuyersTable(attachedDatabase, alias);
  }
}

class BuyersSetsBuyer extends DataClass implements Insertable<BuyersSetsBuyer> {
  final int buyersSetId;
  final int buyerId;
  const BuyersSetsBuyer({required this.buyersSetId, required this.buyerId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['buyers_set_id'] = Variable<int>(buyersSetId);
    map['buyer_id'] = Variable<int>(buyerId);
    return map;
  }

  BuyersSetsBuyersCompanion toCompanion(bool nullToAbsent) {
    return BuyersSetsBuyersCompanion(
      buyersSetId: Value(buyersSetId),
      buyerId: Value(buyerId),
    );
  }

  factory BuyersSetsBuyer.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BuyersSetsBuyer(
      buyersSetId: serializer.fromJson<int>(json['buyersSetId']),
      buyerId: serializer.fromJson<int>(json['buyerId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'buyersSetId': serializer.toJson<int>(buyersSetId),
      'buyerId': serializer.toJson<int>(buyerId),
    };
  }

  BuyersSetsBuyer copyWith({int? buyersSetId, int? buyerId}) => BuyersSetsBuyer(
        buyersSetId: buyersSetId ?? this.buyersSetId,
        buyerId: buyerId ?? this.buyerId,
      );
  BuyersSetsBuyer copyWithCompanion(BuyersSetsBuyersCompanion data) {
    return BuyersSetsBuyer(
      buyersSetId:
          data.buyersSetId.present ? data.buyersSetId.value : this.buyersSetId,
      buyerId: data.buyerId.present ? data.buyerId.value : this.buyerId,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BuyersSetsBuyer(')
          ..write('buyersSetId: $buyersSetId, ')
          ..write('buyerId: $buyerId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(buyersSetId, buyerId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BuyersSetsBuyer &&
          other.buyersSetId == this.buyersSetId &&
          other.buyerId == this.buyerId);
}

class BuyersSetsBuyersCompanion extends UpdateCompanion<BuyersSetsBuyer> {
  final Value<int> buyersSetId;
  final Value<int> buyerId;
  final Value<int> rowid;
  const BuyersSetsBuyersCompanion({
    this.buyersSetId = const Value.absent(),
    this.buyerId = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BuyersSetsBuyersCompanion.insert({
    required int buyersSetId,
    required int buyerId,
    this.rowid = const Value.absent(),
  })  : buyersSetId = Value(buyersSetId),
        buyerId = Value(buyerId);
  static Insertable<BuyersSetsBuyer> custom({
    Expression<int>? buyersSetId,
    Expression<int>? buyerId,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (buyersSetId != null) 'buyers_set_id': buyersSetId,
      if (buyerId != null) 'buyer_id': buyerId,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BuyersSetsBuyersCompanion copyWith(
      {Value<int>? buyersSetId, Value<int>? buyerId, Value<int>? rowid}) {
    return BuyersSetsBuyersCompanion(
      buyersSetId: buyersSetId ?? this.buyersSetId,
      buyerId: buyerId ?? this.buyerId,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (buyersSetId.present) {
      map['buyers_set_id'] = Variable<int>(buyersSetId.value);
    }
    if (buyerId.present) {
      map['buyer_id'] = Variable<int>(buyerId.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BuyersSetsBuyersCompanion(')
          ..write('buyersSetId: $buyersSetId, ')
          ..write('buyerId: $buyerId, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GoodsBonusProgramsTable extends GoodsBonusPrograms
    with TableInfo<$GoodsBonusProgramsTable, GoodsBonusProgram> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GoodsBonusProgramsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _bonusProgramIdMeta =
      const VerificationMeta('bonusProgramId');
  @override
  late final GeneratedColumn<int> bonusProgramId = GeneratedColumn<int>(
      'bonus_program_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _goodsIdMeta =
      const VerificationMeta('goodsId');
  @override
  late final GeneratedColumn<int> goodsId = GeneratedColumn<int>(
      'goods_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [bonusProgramId, goodsId];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'goods_bonus_programs';
  @override
  VerificationContext validateIntegrity(Insertable<GoodsBonusProgram> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('bonus_program_id')) {
      context.handle(
          _bonusProgramIdMeta,
          bonusProgramId.isAcceptableOrUnknown(
              data['bonus_program_id']!, _bonusProgramIdMeta));
    } else if (isInserting) {
      context.missing(_bonusProgramIdMeta);
    }
    if (data.containsKey('goods_id')) {
      context.handle(_goodsIdMeta,
          goodsId.isAcceptableOrUnknown(data['goods_id']!, _goodsIdMeta));
    } else if (isInserting) {
      context.missing(_goodsIdMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {bonusProgramId, goodsId};
  @override
  GoodsBonusProgram map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GoodsBonusProgram(
      bonusProgramId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}bonus_program_id'])!,
      goodsId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}goods_id'])!,
    );
  }

  @override
  $GoodsBonusProgramsTable createAlias(String alias) {
    return $GoodsBonusProgramsTable(attachedDatabase, alias);
  }
}

class GoodsBonusProgram extends DataClass
    implements Insertable<GoodsBonusProgram> {
  final int bonusProgramId;
  final int goodsId;
  const GoodsBonusProgram(
      {required this.bonusProgramId, required this.goodsId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['bonus_program_id'] = Variable<int>(bonusProgramId);
    map['goods_id'] = Variable<int>(goodsId);
    return map;
  }

  GoodsBonusProgramsCompanion toCompanion(bool nullToAbsent) {
    return GoodsBonusProgramsCompanion(
      bonusProgramId: Value(bonusProgramId),
      goodsId: Value(goodsId),
    );
  }

  factory GoodsBonusProgram.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return GoodsBonusProgram(
      bonusProgramId: serializer.fromJson<int>(json['bonusProgramId']),
      goodsId: serializer.fromJson<int>(json['goodsId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'bonusProgramId': serializer.toJson<int>(bonusProgramId),
      'goodsId': serializer.toJson<int>(goodsId),
    };
  }

  GoodsBonusProgram copyWith({int? bonusProgramId, int? goodsId}) =>
      GoodsBonusProgram(
        bonusProgramId: bonusProgramId ?? this.bonusProgramId,
        goodsId: goodsId ?? this.goodsId,
      );
  GoodsBonusProgram copyWithCompanion(GoodsBonusProgramsCompanion data) {
    return GoodsBonusProgram(
      bonusProgramId: data.bonusProgramId.present
          ? data.bonusProgramId.value
          : this.bonusProgramId,
      goodsId: data.goodsId.present ? data.goodsId.value : this.goodsId,
    );
  }

  @override
  String toString() {
    return (StringBuffer('GoodsBonusProgram(')
          ..write('bonusProgramId: $bonusProgramId, ')
          ..write('goodsId: $goodsId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(bonusProgramId, goodsId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GoodsBonusProgram &&
          other.bonusProgramId == this.bonusProgramId &&
          other.goodsId == this.goodsId);
}

class GoodsBonusProgramsCompanion extends UpdateCompanion<GoodsBonusProgram> {
  final Value<int> bonusProgramId;
  final Value<int> goodsId;
  final Value<int> rowid;
  const GoodsBonusProgramsCompanion({
    this.bonusProgramId = const Value.absent(),
    this.goodsId = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  GoodsBonusProgramsCompanion.insert({
    required int bonusProgramId,
    required int goodsId,
    this.rowid = const Value.absent(),
  })  : bonusProgramId = Value(bonusProgramId),
        goodsId = Value(goodsId);
  static Insertable<GoodsBonusProgram> custom({
    Expression<int>? bonusProgramId,
    Expression<int>? goodsId,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (bonusProgramId != null) 'bonus_program_id': bonusProgramId,
      if (goodsId != null) 'goods_id': goodsId,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GoodsBonusProgramsCompanion copyWith(
      {Value<int>? bonusProgramId, Value<int>? goodsId, Value<int>? rowid}) {
    return GoodsBonusProgramsCompanion(
      bonusProgramId: bonusProgramId ?? this.bonusProgramId,
      goodsId: goodsId ?? this.goodsId,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (bonusProgramId.present) {
      map['bonus_program_id'] = Variable<int>(bonusProgramId.value);
    }
    if (goodsId.present) {
      map['goods_id'] = Variable<int>(goodsId.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GoodsBonusProgramsCompanion(')
          ..write('bonusProgramId: $bonusProgramId, ')
          ..write('goodsId: $goodsId, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GoodsBonusProgramPricesTable extends GoodsBonusProgramPrices
    with TableInfo<$GoodsBonusProgramPricesTable, GoodsBonusProgramPrice> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GoodsBonusProgramPricesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _bonusProgramIdMeta =
      const VerificationMeta('bonusProgramId');
  @override
  late final GeneratedColumn<int> bonusProgramId = GeneratedColumn<int>(
      'bonus_program_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _goodsIdMeta =
      const VerificationMeta('goodsId');
  @override
  late final GeneratedColumn<int> goodsId = GeneratedColumn<int>(
      'goods_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  @override
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
      'price', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [bonusProgramId, goodsId, price];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'goods_bonus_program_prices';
  @override
  VerificationContext validateIntegrity(
      Insertable<GoodsBonusProgramPrice> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('bonus_program_id')) {
      context.handle(
          _bonusProgramIdMeta,
          bonusProgramId.isAcceptableOrUnknown(
              data['bonus_program_id']!, _bonusProgramIdMeta));
    } else if (isInserting) {
      context.missing(_bonusProgramIdMeta);
    }
    if (data.containsKey('goods_id')) {
      context.handle(_goodsIdMeta,
          goodsId.isAcceptableOrUnknown(data['goods_id']!, _goodsIdMeta));
    } else if (isInserting) {
      context.missing(_goodsIdMeta);
    }
    if (data.containsKey('price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['price']!, _priceMeta));
    } else if (isInserting) {
      context.missing(_priceMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {bonusProgramId, goodsId};
  @override
  GoodsBonusProgramPrice map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GoodsBonusProgramPrice(
      bonusProgramId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}bonus_program_id'])!,
      goodsId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}goods_id'])!,
      price: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}price'])!,
    );
  }

  @override
  $GoodsBonusProgramPricesTable createAlias(String alias) {
    return $GoodsBonusProgramPricesTable(attachedDatabase, alias);
  }
}

class GoodsBonusProgramPrice extends DataClass
    implements Insertable<GoodsBonusProgramPrice> {
  final int bonusProgramId;
  final int goodsId;
  final double price;
  const GoodsBonusProgramPrice(
      {required this.bonusProgramId,
      required this.goodsId,
      required this.price});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['bonus_program_id'] = Variable<int>(bonusProgramId);
    map['goods_id'] = Variable<int>(goodsId);
    map['price'] = Variable<double>(price);
    return map;
  }

  GoodsBonusProgramPricesCompanion toCompanion(bool nullToAbsent) {
    return GoodsBonusProgramPricesCompanion(
      bonusProgramId: Value(bonusProgramId),
      goodsId: Value(goodsId),
      price: Value(price),
    );
  }

  factory GoodsBonusProgramPrice.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return GoodsBonusProgramPrice(
      bonusProgramId: serializer.fromJson<int>(json['bonusProgramId']),
      goodsId: serializer.fromJson<int>(json['goodsId']),
      price: serializer.fromJson<double>(json['price']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'bonusProgramId': serializer.toJson<int>(bonusProgramId),
      'goodsId': serializer.toJson<int>(goodsId),
      'price': serializer.toJson<double>(price),
    };
  }

  GoodsBonusProgramPrice copyWith(
          {int? bonusProgramId, int? goodsId, double? price}) =>
      GoodsBonusProgramPrice(
        bonusProgramId: bonusProgramId ?? this.bonusProgramId,
        goodsId: goodsId ?? this.goodsId,
        price: price ?? this.price,
      );
  GoodsBonusProgramPrice copyWithCompanion(
      GoodsBonusProgramPricesCompanion data) {
    return GoodsBonusProgramPrice(
      bonusProgramId: data.bonusProgramId.present
          ? data.bonusProgramId.value
          : this.bonusProgramId,
      goodsId: data.goodsId.present ? data.goodsId.value : this.goodsId,
      price: data.price.present ? data.price.value : this.price,
    );
  }

  @override
  String toString() {
    return (StringBuffer('GoodsBonusProgramPrice(')
          ..write('bonusProgramId: $bonusProgramId, ')
          ..write('goodsId: $goodsId, ')
          ..write('price: $price')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(bonusProgramId, goodsId, price);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GoodsBonusProgramPrice &&
          other.bonusProgramId == this.bonusProgramId &&
          other.goodsId == this.goodsId &&
          other.price == this.price);
}

class GoodsBonusProgramPricesCompanion
    extends UpdateCompanion<GoodsBonusProgramPrice> {
  final Value<int> bonusProgramId;
  final Value<int> goodsId;
  final Value<double> price;
  final Value<int> rowid;
  const GoodsBonusProgramPricesCompanion({
    this.bonusProgramId = const Value.absent(),
    this.goodsId = const Value.absent(),
    this.price = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  GoodsBonusProgramPricesCompanion.insert({
    required int bonusProgramId,
    required int goodsId,
    required double price,
    this.rowid = const Value.absent(),
  })  : bonusProgramId = Value(bonusProgramId),
        goodsId = Value(goodsId),
        price = Value(price);
  static Insertable<GoodsBonusProgramPrice> custom({
    Expression<int>? bonusProgramId,
    Expression<int>? goodsId,
    Expression<double>? price,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (bonusProgramId != null) 'bonus_program_id': bonusProgramId,
      if (goodsId != null) 'goods_id': goodsId,
      if (price != null) 'price': price,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GoodsBonusProgramPricesCompanion copyWith(
      {Value<int>? bonusProgramId,
      Value<int>? goodsId,
      Value<double>? price,
      Value<int>? rowid}) {
    return GoodsBonusProgramPricesCompanion(
      bonusProgramId: bonusProgramId ?? this.bonusProgramId,
      goodsId: goodsId ?? this.goodsId,
      price: price ?? this.price,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (bonusProgramId.present) {
      map['bonus_program_id'] = Variable<int>(bonusProgramId.value);
    }
    if (goodsId.present) {
      map['goods_id'] = Variable<int>(goodsId.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GoodsBonusProgramPricesCompanion(')
          ..write('bonusProgramId: $bonusProgramId, ')
          ..write('goodsId: $goodsId, ')
          ..write('price: $price, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PricelistsTable extends Pricelists
    with TableInfo<$PricelistsTable, Pricelist> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PricelistsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _permitMeta = const VerificationMeta('permit');
  @override
  late final GeneratedColumn<bool> permit = GeneratedColumn<bool>(
      'permit', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("permit" IN (0, 1))'));
  @override
  List<GeneratedColumn> get $columns => [id, name, permit];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'pricelists';
  @override
  VerificationContext validateIntegrity(Insertable<Pricelist> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('permit')) {
      context.handle(_permitMeta,
          permit.isAcceptableOrUnknown(data['permit']!, _permitMeta));
    } else if (isInserting) {
      context.missing(_permitMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Pricelist map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Pricelist(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      permit: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}permit'])!,
    );
  }

  @override
  $PricelistsTable createAlias(String alias) {
    return $PricelistsTable(attachedDatabase, alias);
  }
}

class Pricelist extends DataClass implements Insertable<Pricelist> {
  final int id;
  final String name;
  final bool permit;
  const Pricelist({required this.id, required this.name, required this.permit});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    map['permit'] = Variable<bool>(permit);
    return map;
  }

  PricelistsCompanion toCompanion(bool nullToAbsent) {
    return PricelistsCompanion(
      id: Value(id),
      name: Value(name),
      permit: Value(permit),
    );
  }

  factory Pricelist.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Pricelist(
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      permit: serializer.fromJson<bool>(json['permit']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
      'permit': serializer.toJson<bool>(permit),
    };
  }

  Pricelist copyWith({int? id, String? name, bool? permit}) => Pricelist(
        id: id ?? this.id,
        name: name ?? this.name,
        permit: permit ?? this.permit,
      );
  Pricelist copyWithCompanion(PricelistsCompanion data) {
    return Pricelist(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      permit: data.permit.present ? data.permit.value : this.permit,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Pricelist(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('permit: $permit')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name, permit);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Pricelist &&
          other.id == this.id &&
          other.name == this.name &&
          other.permit == this.permit);
}

class PricelistsCompanion extends UpdateCompanion<Pricelist> {
  final Value<int> id;
  final Value<String> name;
  final Value<bool> permit;
  const PricelistsCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.permit = const Value.absent(),
  });
  PricelistsCompanion.insert({
    this.id = const Value.absent(),
    required String name,
    required bool permit,
  })  : name = Value(name),
        permit = Value(permit);
  static Insertable<Pricelist> custom({
    Expression<int>? id,
    Expression<String>? name,
    Expression<bool>? permit,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (permit != null) 'permit': permit,
    });
  }

  PricelistsCompanion copyWith(
      {Value<int>? id, Value<String>? name, Value<bool>? permit}) {
    return PricelistsCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      permit: permit ?? this.permit,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (permit.present) {
      map['permit'] = Variable<bool>(permit.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PricelistsCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('permit: $permit')
          ..write(')'))
        .toString();
  }
}

class $PricelistSetCategoriesTable extends PricelistSetCategories
    with TableInfo<$PricelistSetCategoriesTable, PricelistSetCategory> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PricelistSetCategoriesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _pricelistSetIdMeta =
      const VerificationMeta('pricelistSetId');
  @override
  late final GeneratedColumn<int> pricelistSetId = GeneratedColumn<int>(
      'pricelist_set_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _categoryIdMeta =
      const VerificationMeta('categoryId');
  @override
  late final GeneratedColumn<int> categoryId = GeneratedColumn<int>(
      'category_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [pricelistSetId, categoryId];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'pricelist_set_categories';
  @override
  VerificationContext validateIntegrity(
      Insertable<PricelistSetCategory> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('pricelist_set_id')) {
      context.handle(
          _pricelistSetIdMeta,
          pricelistSetId.isAcceptableOrUnknown(
              data['pricelist_set_id']!, _pricelistSetIdMeta));
    } else if (isInserting) {
      context.missing(_pricelistSetIdMeta);
    }
    if (data.containsKey('category_id')) {
      context.handle(
          _categoryIdMeta,
          categoryId.isAcceptableOrUnknown(
              data['category_id']!, _categoryIdMeta));
    } else if (isInserting) {
      context.missing(_categoryIdMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {pricelistSetId, categoryId};
  @override
  PricelistSetCategory map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PricelistSetCategory(
      pricelistSetId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}pricelist_set_id'])!,
      categoryId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}category_id'])!,
    );
  }

  @override
  $PricelistSetCategoriesTable createAlias(String alias) {
    return $PricelistSetCategoriesTable(attachedDatabase, alias);
  }
}

class PricelistSetCategory extends DataClass
    implements Insertable<PricelistSetCategory> {
  final int pricelistSetId;
  final int categoryId;
  const PricelistSetCategory(
      {required this.pricelistSetId, required this.categoryId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['pricelist_set_id'] = Variable<int>(pricelistSetId);
    map['category_id'] = Variable<int>(categoryId);
    return map;
  }

  PricelistSetCategoriesCompanion toCompanion(bool nullToAbsent) {
    return PricelistSetCategoriesCompanion(
      pricelistSetId: Value(pricelistSetId),
      categoryId: Value(categoryId),
    );
  }

  factory PricelistSetCategory.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PricelistSetCategory(
      pricelistSetId: serializer.fromJson<int>(json['pricelistSetId']),
      categoryId: serializer.fromJson<int>(json['categoryId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'pricelistSetId': serializer.toJson<int>(pricelistSetId),
      'categoryId': serializer.toJson<int>(categoryId),
    };
  }

  PricelistSetCategory copyWith({int? pricelistSetId, int? categoryId}) =>
      PricelistSetCategory(
        pricelistSetId: pricelistSetId ?? this.pricelistSetId,
        categoryId: categoryId ?? this.categoryId,
      );
  PricelistSetCategory copyWithCompanion(PricelistSetCategoriesCompanion data) {
    return PricelistSetCategory(
      pricelistSetId: data.pricelistSetId.present
          ? data.pricelistSetId.value
          : this.pricelistSetId,
      categoryId:
          data.categoryId.present ? data.categoryId.value : this.categoryId,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PricelistSetCategory(')
          ..write('pricelistSetId: $pricelistSetId, ')
          ..write('categoryId: $categoryId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(pricelistSetId, categoryId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PricelistSetCategory &&
          other.pricelistSetId == this.pricelistSetId &&
          other.categoryId == this.categoryId);
}

class PricelistSetCategoriesCompanion
    extends UpdateCompanion<PricelistSetCategory> {
  final Value<int> pricelistSetId;
  final Value<int> categoryId;
  final Value<int> rowid;
  const PricelistSetCategoriesCompanion({
    this.pricelistSetId = const Value.absent(),
    this.categoryId = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PricelistSetCategoriesCompanion.insert({
    required int pricelistSetId,
    required int categoryId,
    this.rowid = const Value.absent(),
  })  : pricelistSetId = Value(pricelistSetId),
        categoryId = Value(categoryId);
  static Insertable<PricelistSetCategory> custom({
    Expression<int>? pricelistSetId,
    Expression<int>? categoryId,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (pricelistSetId != null) 'pricelist_set_id': pricelistSetId,
      if (categoryId != null) 'category_id': categoryId,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PricelistSetCategoriesCompanion copyWith(
      {Value<int>? pricelistSetId, Value<int>? categoryId, Value<int>? rowid}) {
    return PricelistSetCategoriesCompanion(
      pricelistSetId: pricelistSetId ?? this.pricelistSetId,
      categoryId: categoryId ?? this.categoryId,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (pricelistSetId.present) {
      map['pricelist_set_id'] = Variable<int>(pricelistSetId.value);
    }
    if (categoryId.present) {
      map['category_id'] = Variable<int>(categoryId.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PricelistSetCategoriesCompanion(')
          ..write('pricelistSetId: $pricelistSetId, ')
          ..write('categoryId: $categoryId, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PartnersPricesTable extends PartnersPrices
    with TableInfo<$PartnersPricesTable, PartnersPrice> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PartnersPricesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _guidMeta = const VerificationMeta('guid');
  @override
  late final GeneratedColumn<String> guid = GeneratedColumn<String>(
      'guid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _timestampMeta =
      const VerificationMeta('timestamp');
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
      'timestamp', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _currentTimestampMeta =
      const VerificationMeta('currentTimestamp');
  @override
  late final GeneratedColumn<DateTime> currentTimestamp =
      GeneratedColumn<DateTime>('current_timestamp', aliasedName, false,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          defaultValue: currentDateAndTime);
  static const VerificationMeta _lastSyncTimeMeta =
      const VerificationMeta('lastSyncTime');
  @override
  late final GeneratedColumn<DateTime> lastSyncTime = GeneratedColumn<DateTime>(
      'last_sync_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _needSyncMeta =
      const VerificationMeta('needSync');
  @override
  late final GeneratedColumn<bool> needSync = GeneratedColumn<bool>(
      'need_sync', aliasedName, false,
      generatedAs: GeneratedAs(
          (isNew & BooleanExpressionOperators(isDeleted).not()) |
              (BooleanExpressionOperators(isNew).not() &
                  ComparableExpr(lastSyncTime).isSmallerThan(timestamp)),
          true),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("need_sync" IN (0, 1))'));
  static const VerificationMeta _isNewMeta = const VerificationMeta('isNew');
  @override
  late final GeneratedColumn<bool> isNew = GeneratedColumn<bool>(
      'is_new', aliasedName, false,
      generatedAs: GeneratedAs(lastSyncTime.isNull(), false),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_new" IN (0, 1))'));
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _goodsIdMeta =
      const VerificationMeta('goodsId');
  @override
  late final GeneratedColumn<int> goodsId = GeneratedColumn<int>(
      'goods_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _partnerIdMeta =
      const VerificationMeta('partnerId');
  @override
  late final GeneratedColumn<int> partnerId = GeneratedColumn<int>(
      'partner_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  @override
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
      'price', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _dateFromMeta =
      const VerificationMeta('dateFrom');
  @override
  late final GeneratedColumn<DateTime> dateFrom = GeneratedColumn<DateTime>(
      'date_from', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _dateToMeta = const VerificationMeta('dateTo');
  @override
  late final GeneratedColumn<DateTime> dateTo = GeneratedColumn<DateTime>(
      'date_to', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        guid,
        isDeleted,
        timestamp,
        currentTimestamp,
        lastSyncTime,
        needSync,
        isNew,
        id,
        goodsId,
        partnerId,
        price,
        dateFrom,
        dateTo
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'partners_prices';
  @override
  VerificationContext validateIntegrity(Insertable<PartnersPrice> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('guid')) {
      context.handle(
          _guidMeta, guid.isAcceptableOrUnknown(data['guid']!, _guidMeta));
    } else if (isInserting) {
      context.missing(_guidMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('timestamp')) {
      context.handle(_timestampMeta,
          timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta));
    }
    if (data.containsKey('current_timestamp')) {
      context.handle(
          _currentTimestampMeta,
          currentTimestamp.isAcceptableOrUnknown(
              data['current_timestamp']!, _currentTimestampMeta));
    }
    if (data.containsKey('last_sync_time')) {
      context.handle(
          _lastSyncTimeMeta,
          lastSyncTime.isAcceptableOrUnknown(
              data['last_sync_time']!, _lastSyncTimeMeta));
    }
    if (data.containsKey('need_sync')) {
      context.handle(_needSyncMeta,
          needSync.isAcceptableOrUnknown(data['need_sync']!, _needSyncMeta));
    }
    if (data.containsKey('is_new')) {
      context.handle(
          _isNewMeta, isNew.isAcceptableOrUnknown(data['is_new']!, _isNewMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('goods_id')) {
      context.handle(_goodsIdMeta,
          goodsId.isAcceptableOrUnknown(data['goods_id']!, _goodsIdMeta));
    } else if (isInserting) {
      context.missing(_goodsIdMeta);
    }
    if (data.containsKey('partner_id')) {
      context.handle(_partnerIdMeta,
          partnerId.isAcceptableOrUnknown(data['partner_id']!, _partnerIdMeta));
    } else if (isInserting) {
      context.missing(_partnerIdMeta);
    }
    if (data.containsKey('price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['price']!, _priceMeta));
    } else if (isInserting) {
      context.missing(_priceMeta);
    }
    if (data.containsKey('date_from')) {
      context.handle(_dateFromMeta,
          dateFrom.isAcceptableOrUnknown(data['date_from']!, _dateFromMeta));
    } else if (isInserting) {
      context.missing(_dateFromMeta);
    }
    if (data.containsKey('date_to')) {
      context.handle(_dateToMeta,
          dateTo.isAcceptableOrUnknown(data['date_to']!, _dateToMeta));
    } else if (isInserting) {
      context.missing(_dateToMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {guid};
  @override
  PartnersPrice map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PartnersPrice(
      guid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}guid'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      timestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}timestamp'])!,
      currentTimestamp: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}current_timestamp'])!,
      lastSyncTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_sync_time']),
      needSync: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_sync'])!,
      isNew: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_new'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id']),
      goodsId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}goods_id'])!,
      partnerId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}partner_id'])!,
      price: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}price'])!,
      dateFrom: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}date_from'])!,
      dateTo: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}date_to'])!,
    );
  }

  @override
  $PartnersPricesTable createAlias(String alias) {
    return $PartnersPricesTable(attachedDatabase, alias);
  }
}

class PartnersPrice extends DataClass implements Insertable<PartnersPrice> {
  final String guid;
  final bool isDeleted;
  final DateTime timestamp;
  final DateTime currentTimestamp;
  final DateTime? lastSyncTime;
  final bool needSync;
  final bool isNew;
  final int? id;
  final int goodsId;
  final int partnerId;
  final double price;
  final DateTime dateFrom;
  final DateTime dateTo;
  const PartnersPrice(
      {required this.guid,
      required this.isDeleted,
      required this.timestamp,
      required this.currentTimestamp,
      this.lastSyncTime,
      required this.needSync,
      required this.isNew,
      this.id,
      required this.goodsId,
      required this.partnerId,
      required this.price,
      required this.dateFrom,
      required this.dateTo});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['guid'] = Variable<String>(guid);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['timestamp'] = Variable<DateTime>(timestamp);
    map['current_timestamp'] = Variable<DateTime>(currentTimestamp);
    if (!nullToAbsent || lastSyncTime != null) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    map['goods_id'] = Variable<int>(goodsId);
    map['partner_id'] = Variable<int>(partnerId);
    map['price'] = Variable<double>(price);
    map['date_from'] = Variable<DateTime>(dateFrom);
    map['date_to'] = Variable<DateTime>(dateTo);
    return map;
  }

  PartnersPricesCompanion toCompanion(bool nullToAbsent) {
    return PartnersPricesCompanion(
      guid: Value(guid),
      isDeleted: Value(isDeleted),
      timestamp: Value(timestamp),
      currentTimestamp: Value(currentTimestamp),
      lastSyncTime: lastSyncTime == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncTime),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      goodsId: Value(goodsId),
      partnerId: Value(partnerId),
      price: Value(price),
      dateFrom: Value(dateFrom),
      dateTo: Value(dateTo),
    );
  }

  factory PartnersPrice.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PartnersPrice(
      guid: serializer.fromJson<String>(json['guid']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      currentTimestamp: serializer.fromJson<DateTime>(json['currentTimestamp']),
      lastSyncTime: serializer.fromJson<DateTime?>(json['lastSyncTime']),
      needSync: serializer.fromJson<bool>(json['needSync']),
      isNew: serializer.fromJson<bool>(json['isNew']),
      id: serializer.fromJson<int?>(json['id']),
      goodsId: serializer.fromJson<int>(json['goodsId']),
      partnerId: serializer.fromJson<int>(json['partnerId']),
      price: serializer.fromJson<double>(json['price']),
      dateFrom: serializer.fromJson<DateTime>(json['dateFrom']),
      dateTo: serializer.fromJson<DateTime>(json['dateTo']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'guid': serializer.toJson<String>(guid),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'currentTimestamp': serializer.toJson<DateTime>(currentTimestamp),
      'lastSyncTime': serializer.toJson<DateTime?>(lastSyncTime),
      'needSync': serializer.toJson<bool>(needSync),
      'isNew': serializer.toJson<bool>(isNew),
      'id': serializer.toJson<int?>(id),
      'goodsId': serializer.toJson<int>(goodsId),
      'partnerId': serializer.toJson<int>(partnerId),
      'price': serializer.toJson<double>(price),
      'dateFrom': serializer.toJson<DateTime>(dateFrom),
      'dateTo': serializer.toJson<DateTime>(dateTo),
    };
  }

  PartnersPrice copyWith(
          {String? guid,
          bool? isDeleted,
          DateTime? timestamp,
          DateTime? currentTimestamp,
          Value<DateTime?> lastSyncTime = const Value.absent(),
          bool? needSync,
          bool? isNew,
          Value<int?> id = const Value.absent(),
          int? goodsId,
          int? partnerId,
          double? price,
          DateTime? dateFrom,
          DateTime? dateTo}) =>
      PartnersPrice(
        guid: guid ?? this.guid,
        isDeleted: isDeleted ?? this.isDeleted,
        timestamp: timestamp ?? this.timestamp,
        currentTimestamp: currentTimestamp ?? this.currentTimestamp,
        lastSyncTime:
            lastSyncTime.present ? lastSyncTime.value : this.lastSyncTime,
        needSync: needSync ?? this.needSync,
        isNew: isNew ?? this.isNew,
        id: id.present ? id.value : this.id,
        goodsId: goodsId ?? this.goodsId,
        partnerId: partnerId ?? this.partnerId,
        price: price ?? this.price,
        dateFrom: dateFrom ?? this.dateFrom,
        dateTo: dateTo ?? this.dateTo,
      );
  @override
  String toString() {
    return (StringBuffer('PartnersPrice(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('needSync: $needSync, ')
          ..write('isNew: $isNew, ')
          ..write('id: $id, ')
          ..write('goodsId: $goodsId, ')
          ..write('partnerId: $partnerId, ')
          ..write('price: $price, ')
          ..write('dateFrom: $dateFrom, ')
          ..write('dateTo: $dateTo')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      guid,
      isDeleted,
      timestamp,
      currentTimestamp,
      lastSyncTime,
      needSync,
      isNew,
      id,
      goodsId,
      partnerId,
      price,
      dateFrom,
      dateTo);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PartnersPrice &&
          other.guid == this.guid &&
          other.isDeleted == this.isDeleted &&
          other.timestamp == this.timestamp &&
          other.currentTimestamp == this.currentTimestamp &&
          other.lastSyncTime == this.lastSyncTime &&
          other.needSync == this.needSync &&
          other.isNew == this.isNew &&
          other.id == this.id &&
          other.goodsId == this.goodsId &&
          other.partnerId == this.partnerId &&
          other.price == this.price &&
          other.dateFrom == this.dateFrom &&
          other.dateTo == this.dateTo);
}

class PartnersPricesCompanion extends UpdateCompanion<PartnersPrice> {
  final Value<String> guid;
  final Value<bool> isDeleted;
  final Value<DateTime> timestamp;
  final Value<DateTime> currentTimestamp;
  final Value<DateTime?> lastSyncTime;
  final Value<int?> id;
  final Value<int> goodsId;
  final Value<int> partnerId;
  final Value<double> price;
  final Value<DateTime> dateFrom;
  final Value<DateTime> dateTo;
  final Value<int> rowid;
  const PartnersPricesCompanion({
    this.guid = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    this.goodsId = const Value.absent(),
    this.partnerId = const Value.absent(),
    this.price = const Value.absent(),
    this.dateFrom = const Value.absent(),
    this.dateTo = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PartnersPricesCompanion.insert({
    required String guid,
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    required int goodsId,
    required int partnerId,
    required double price,
    required DateTime dateFrom,
    required DateTime dateTo,
    this.rowid = const Value.absent(),
  })  : guid = Value(guid),
        goodsId = Value(goodsId),
        partnerId = Value(partnerId),
        price = Value(price),
        dateFrom = Value(dateFrom),
        dateTo = Value(dateTo);
  static Insertable<PartnersPrice> custom({
    Expression<String>? guid,
    Expression<bool>? isDeleted,
    Expression<DateTime>? timestamp,
    Expression<DateTime>? currentTimestamp,
    Expression<DateTime>? lastSyncTime,
    Expression<int>? id,
    Expression<int>? goodsId,
    Expression<int>? partnerId,
    Expression<double>? price,
    Expression<DateTime>? dateFrom,
    Expression<DateTime>? dateTo,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (guid != null) 'guid': guid,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (timestamp != null) 'timestamp': timestamp,
      if (currentTimestamp != null) 'current_timestamp': currentTimestamp,
      if (lastSyncTime != null) 'last_sync_time': lastSyncTime,
      if (id != null) 'id': id,
      if (goodsId != null) 'goods_id': goodsId,
      if (partnerId != null) 'partner_id': partnerId,
      if (price != null) 'price': price,
      if (dateFrom != null) 'date_from': dateFrom,
      if (dateTo != null) 'date_to': dateTo,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PartnersPricesCompanion copyWith(
      {Value<String>? guid,
      Value<bool>? isDeleted,
      Value<DateTime>? timestamp,
      Value<DateTime>? currentTimestamp,
      Value<DateTime?>? lastSyncTime,
      Value<int?>? id,
      Value<int>? goodsId,
      Value<int>? partnerId,
      Value<double>? price,
      Value<DateTime>? dateFrom,
      Value<DateTime>? dateTo,
      Value<int>? rowid}) {
    return PartnersPricesCompanion(
      guid: guid ?? this.guid,
      isDeleted: isDeleted ?? this.isDeleted,
      timestamp: timestamp ?? this.timestamp,
      currentTimestamp: currentTimestamp ?? this.currentTimestamp,
      lastSyncTime: lastSyncTime ?? this.lastSyncTime,
      id: id ?? this.id,
      goodsId: goodsId ?? this.goodsId,
      partnerId: partnerId ?? this.partnerId,
      price: price ?? this.price,
      dateFrom: dateFrom ?? this.dateFrom,
      dateTo: dateTo ?? this.dateTo,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (guid.present) {
      map['guid'] = Variable<String>(guid.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (currentTimestamp.present) {
      map['current_timestamp'] = Variable<DateTime>(currentTimestamp.value);
    }
    if (lastSyncTime.present) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (goodsId.present) {
      map['goods_id'] = Variable<int>(goodsId.value);
    }
    if (partnerId.present) {
      map['partner_id'] = Variable<int>(partnerId.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (dateFrom.present) {
      map['date_from'] = Variable<DateTime>(dateFrom.value);
    }
    if (dateTo.present) {
      map['date_to'] = Variable<DateTime>(dateTo.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PartnersPricesCompanion(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('id: $id, ')
          ..write('goodsId: $goodsId, ')
          ..write('partnerId: $partnerId, ')
          ..write('price: $price, ')
          ..write('dateFrom: $dateFrom, ')
          ..write('dateTo: $dateTo, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PricelistPricesTable extends PricelistPrices
    with TableInfo<$PricelistPricesTable, PricelistPrice> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PricelistPricesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _goodsIdMeta =
      const VerificationMeta('goodsId');
  @override
  late final GeneratedColumn<int> goodsId = GeneratedColumn<int>(
      'goods_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _pricelistIdMeta =
      const VerificationMeta('pricelistId');
  @override
  late final GeneratedColumn<int> pricelistId = GeneratedColumn<int>(
      'pricelist_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  @override
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
      'price', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _dateFromMeta =
      const VerificationMeta('dateFrom');
  @override
  late final GeneratedColumn<DateTime> dateFrom = GeneratedColumn<DateTime>(
      'date_from', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _dateToMeta = const VerificationMeta('dateTo');
  @override
  late final GeneratedColumn<DateTime> dateTo = GeneratedColumn<DateTime>(
      'date_to', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [goodsId, pricelistId, price, dateFrom, dateTo];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'pricelist_prices';
  @override
  VerificationContext validateIntegrity(Insertable<PricelistPrice> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('goods_id')) {
      context.handle(_goodsIdMeta,
          goodsId.isAcceptableOrUnknown(data['goods_id']!, _goodsIdMeta));
    } else if (isInserting) {
      context.missing(_goodsIdMeta);
    }
    if (data.containsKey('pricelist_id')) {
      context.handle(
          _pricelistIdMeta,
          pricelistId.isAcceptableOrUnknown(
              data['pricelist_id']!, _pricelistIdMeta));
    } else if (isInserting) {
      context.missing(_pricelistIdMeta);
    }
    if (data.containsKey('price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['price']!, _priceMeta));
    } else if (isInserting) {
      context.missing(_priceMeta);
    }
    if (data.containsKey('date_from')) {
      context.handle(_dateFromMeta,
          dateFrom.isAcceptableOrUnknown(data['date_from']!, _dateFromMeta));
    } else if (isInserting) {
      context.missing(_dateFromMeta);
    }
    if (data.containsKey('date_to')) {
      context.handle(_dateToMeta,
          dateTo.isAcceptableOrUnknown(data['date_to']!, _dateToMeta));
    } else if (isInserting) {
      context.missing(_dateToMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => const {};
  @override
  PricelistPrice map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PricelistPrice(
      goodsId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}goods_id'])!,
      pricelistId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}pricelist_id'])!,
      price: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}price'])!,
      dateFrom: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}date_from'])!,
      dateTo: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}date_to'])!,
    );
  }

  @override
  $PricelistPricesTable createAlias(String alias) {
    return $PricelistPricesTable(attachedDatabase, alias);
  }
}

class PricelistPrice extends DataClass implements Insertable<PricelistPrice> {
  final int goodsId;
  final int pricelistId;
  final double price;
  final DateTime dateFrom;
  final DateTime dateTo;
  const PricelistPrice(
      {required this.goodsId,
      required this.pricelistId,
      required this.price,
      required this.dateFrom,
      required this.dateTo});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['goods_id'] = Variable<int>(goodsId);
    map['pricelist_id'] = Variable<int>(pricelistId);
    map['price'] = Variable<double>(price);
    map['date_from'] = Variable<DateTime>(dateFrom);
    map['date_to'] = Variable<DateTime>(dateTo);
    return map;
  }

  PricelistPricesCompanion toCompanion(bool nullToAbsent) {
    return PricelistPricesCompanion(
      goodsId: Value(goodsId),
      pricelistId: Value(pricelistId),
      price: Value(price),
      dateFrom: Value(dateFrom),
      dateTo: Value(dateTo),
    );
  }

  factory PricelistPrice.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PricelistPrice(
      goodsId: serializer.fromJson<int>(json['goodsId']),
      pricelistId: serializer.fromJson<int>(json['pricelistId']),
      price: serializer.fromJson<double>(json['price']),
      dateFrom: serializer.fromJson<DateTime>(json['dateFrom']),
      dateTo: serializer.fromJson<DateTime>(json['dateTo']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'goodsId': serializer.toJson<int>(goodsId),
      'pricelistId': serializer.toJson<int>(pricelistId),
      'price': serializer.toJson<double>(price),
      'dateFrom': serializer.toJson<DateTime>(dateFrom),
      'dateTo': serializer.toJson<DateTime>(dateTo),
    };
  }

  PricelistPrice copyWith(
          {int? goodsId,
          int? pricelistId,
          double? price,
          DateTime? dateFrom,
          DateTime? dateTo}) =>
      PricelistPrice(
        goodsId: goodsId ?? this.goodsId,
        pricelistId: pricelistId ?? this.pricelistId,
        price: price ?? this.price,
        dateFrom: dateFrom ?? this.dateFrom,
        dateTo: dateTo ?? this.dateTo,
      );
  PricelistPrice copyWithCompanion(PricelistPricesCompanion data) {
    return PricelistPrice(
      goodsId: data.goodsId.present ? data.goodsId.value : this.goodsId,
      pricelistId:
          data.pricelistId.present ? data.pricelistId.value : this.pricelistId,
      price: data.price.present ? data.price.value : this.price,
      dateFrom: data.dateFrom.present ? data.dateFrom.value : this.dateFrom,
      dateTo: data.dateTo.present ? data.dateTo.value : this.dateTo,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PricelistPrice(')
          ..write('goodsId: $goodsId, ')
          ..write('pricelistId: $pricelistId, ')
          ..write('price: $price, ')
          ..write('dateFrom: $dateFrom, ')
          ..write('dateTo: $dateTo')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(goodsId, pricelistId, price, dateFrom, dateTo);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PricelistPrice &&
          other.goodsId == this.goodsId &&
          other.pricelistId == this.pricelistId &&
          other.price == this.price &&
          other.dateFrom == this.dateFrom &&
          other.dateTo == this.dateTo);
}

class PricelistPricesCompanion extends UpdateCompanion<PricelistPrice> {
  final Value<int> goodsId;
  final Value<int> pricelistId;
  final Value<double> price;
  final Value<DateTime> dateFrom;
  final Value<DateTime> dateTo;
  final Value<int> rowid;
  const PricelistPricesCompanion({
    this.goodsId = const Value.absent(),
    this.pricelistId = const Value.absent(),
    this.price = const Value.absent(),
    this.dateFrom = const Value.absent(),
    this.dateTo = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PricelistPricesCompanion.insert({
    required int goodsId,
    required int pricelistId,
    required double price,
    required DateTime dateFrom,
    required DateTime dateTo,
    this.rowid = const Value.absent(),
  })  : goodsId = Value(goodsId),
        pricelistId = Value(pricelistId),
        price = Value(price),
        dateFrom = Value(dateFrom),
        dateTo = Value(dateTo);
  static Insertable<PricelistPrice> custom({
    Expression<int>? goodsId,
    Expression<int>? pricelistId,
    Expression<double>? price,
    Expression<DateTime>? dateFrom,
    Expression<DateTime>? dateTo,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (goodsId != null) 'goods_id': goodsId,
      if (pricelistId != null) 'pricelist_id': pricelistId,
      if (price != null) 'price': price,
      if (dateFrom != null) 'date_from': dateFrom,
      if (dateTo != null) 'date_to': dateTo,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PricelistPricesCompanion copyWith(
      {Value<int>? goodsId,
      Value<int>? pricelistId,
      Value<double>? price,
      Value<DateTime>? dateFrom,
      Value<DateTime>? dateTo,
      Value<int>? rowid}) {
    return PricelistPricesCompanion(
      goodsId: goodsId ?? this.goodsId,
      pricelistId: pricelistId ?? this.pricelistId,
      price: price ?? this.price,
      dateFrom: dateFrom ?? this.dateFrom,
      dateTo: dateTo ?? this.dateTo,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (goodsId.present) {
      map['goods_id'] = Variable<int>(goodsId.value);
    }
    if (pricelistId.present) {
      map['pricelist_id'] = Variable<int>(pricelistId.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (dateFrom.present) {
      map['date_from'] = Variable<DateTime>(dateFrom.value);
    }
    if (dateTo.present) {
      map['date_to'] = Variable<DateTime>(dateTo.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PricelistPricesCompanion(')
          ..write('goodsId: $goodsId, ')
          ..write('pricelistId: $pricelistId, ')
          ..write('price: $price, ')
          ..write('dateFrom: $dateFrom, ')
          ..write('dateTo: $dateTo, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PartnersPricelistsTable extends PartnersPricelists
    with TableInfo<$PartnersPricelistsTable, PartnersPricelist> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PartnersPricelistsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _guidMeta = const VerificationMeta('guid');
  @override
  late final GeneratedColumn<String> guid = GeneratedColumn<String>(
      'guid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _timestampMeta =
      const VerificationMeta('timestamp');
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
      'timestamp', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _currentTimestampMeta =
      const VerificationMeta('currentTimestamp');
  @override
  late final GeneratedColumn<DateTime> currentTimestamp =
      GeneratedColumn<DateTime>('current_timestamp', aliasedName, false,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          defaultValue: currentDateAndTime);
  static const VerificationMeta _lastSyncTimeMeta =
      const VerificationMeta('lastSyncTime');
  @override
  late final GeneratedColumn<DateTime> lastSyncTime = GeneratedColumn<DateTime>(
      'last_sync_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _needSyncMeta =
      const VerificationMeta('needSync');
  @override
  late final GeneratedColumn<bool> needSync = GeneratedColumn<bool>(
      'need_sync', aliasedName, false,
      generatedAs: GeneratedAs(
          (isNew & BooleanExpressionOperators(isDeleted).not()) |
              (BooleanExpressionOperators(isNew).not() &
                  ComparableExpr(lastSyncTime).isSmallerThan(timestamp)),
          true),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("need_sync" IN (0, 1))'));
  static const VerificationMeta _isNewMeta = const VerificationMeta('isNew');
  @override
  late final GeneratedColumn<bool> isNew = GeneratedColumn<bool>(
      'is_new', aliasedName, false,
      generatedAs: GeneratedAs(lastSyncTime.isNull(), false),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_new" IN (0, 1))'));
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _partnerIdMeta =
      const VerificationMeta('partnerId');
  @override
  late final GeneratedColumn<int> partnerId = GeneratedColumn<int>(
      'partner_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _pricelistIdMeta =
      const VerificationMeta('pricelistId');
  @override
  late final GeneratedColumn<int> pricelistId = GeneratedColumn<int>(
      'pricelist_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _pricelistSetIdMeta =
      const VerificationMeta('pricelistSetId');
  @override
  late final GeneratedColumn<int> pricelistSetId = GeneratedColumn<int>(
      'pricelist_set_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _discountMeta =
      const VerificationMeta('discount');
  @override
  late final GeneratedColumn<double> discount = GeneratedColumn<double>(
      'discount', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        guid,
        isDeleted,
        timestamp,
        currentTimestamp,
        lastSyncTime,
        needSync,
        isNew,
        id,
        partnerId,
        pricelistId,
        pricelistSetId,
        discount
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'partners_pricelists';
  @override
  VerificationContext validateIntegrity(Insertable<PartnersPricelist> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('guid')) {
      context.handle(
          _guidMeta, guid.isAcceptableOrUnknown(data['guid']!, _guidMeta));
    } else if (isInserting) {
      context.missing(_guidMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('timestamp')) {
      context.handle(_timestampMeta,
          timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta));
    }
    if (data.containsKey('current_timestamp')) {
      context.handle(
          _currentTimestampMeta,
          currentTimestamp.isAcceptableOrUnknown(
              data['current_timestamp']!, _currentTimestampMeta));
    }
    if (data.containsKey('last_sync_time')) {
      context.handle(
          _lastSyncTimeMeta,
          lastSyncTime.isAcceptableOrUnknown(
              data['last_sync_time']!, _lastSyncTimeMeta));
    }
    if (data.containsKey('need_sync')) {
      context.handle(_needSyncMeta,
          needSync.isAcceptableOrUnknown(data['need_sync']!, _needSyncMeta));
    }
    if (data.containsKey('is_new')) {
      context.handle(
          _isNewMeta, isNew.isAcceptableOrUnknown(data['is_new']!, _isNewMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('partner_id')) {
      context.handle(_partnerIdMeta,
          partnerId.isAcceptableOrUnknown(data['partner_id']!, _partnerIdMeta));
    } else if (isInserting) {
      context.missing(_partnerIdMeta);
    }
    if (data.containsKey('pricelist_id')) {
      context.handle(
          _pricelistIdMeta,
          pricelistId.isAcceptableOrUnknown(
              data['pricelist_id']!, _pricelistIdMeta));
    } else if (isInserting) {
      context.missing(_pricelistIdMeta);
    }
    if (data.containsKey('pricelist_set_id')) {
      context.handle(
          _pricelistSetIdMeta,
          pricelistSetId.isAcceptableOrUnknown(
              data['pricelist_set_id']!, _pricelistSetIdMeta));
    } else if (isInserting) {
      context.missing(_pricelistSetIdMeta);
    }
    if (data.containsKey('discount')) {
      context.handle(_discountMeta,
          discount.isAcceptableOrUnknown(data['discount']!, _discountMeta));
    } else if (isInserting) {
      context.missing(_discountMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {guid};
  @override
  PartnersPricelist map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PartnersPricelist(
      guid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}guid'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      timestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}timestamp'])!,
      currentTimestamp: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}current_timestamp'])!,
      lastSyncTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_sync_time']),
      needSync: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_sync'])!,
      isNew: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_new'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id']),
      partnerId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}partner_id'])!,
      pricelistId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}pricelist_id'])!,
      pricelistSetId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}pricelist_set_id'])!,
      discount: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}discount'])!,
    );
  }

  @override
  $PartnersPricelistsTable createAlias(String alias) {
    return $PartnersPricelistsTable(attachedDatabase, alias);
  }
}

class PartnersPricelist extends DataClass
    implements Insertable<PartnersPricelist> {
  final String guid;
  final bool isDeleted;
  final DateTime timestamp;
  final DateTime currentTimestamp;
  final DateTime? lastSyncTime;
  final bool needSync;
  final bool isNew;
  final int? id;
  final int partnerId;
  final int pricelistId;
  final int pricelistSetId;
  final double discount;
  const PartnersPricelist(
      {required this.guid,
      required this.isDeleted,
      required this.timestamp,
      required this.currentTimestamp,
      this.lastSyncTime,
      required this.needSync,
      required this.isNew,
      this.id,
      required this.partnerId,
      required this.pricelistId,
      required this.pricelistSetId,
      required this.discount});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['guid'] = Variable<String>(guid);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['timestamp'] = Variable<DateTime>(timestamp);
    map['current_timestamp'] = Variable<DateTime>(currentTimestamp);
    if (!nullToAbsent || lastSyncTime != null) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    map['partner_id'] = Variable<int>(partnerId);
    map['pricelist_id'] = Variable<int>(pricelistId);
    map['pricelist_set_id'] = Variable<int>(pricelistSetId);
    map['discount'] = Variable<double>(discount);
    return map;
  }

  PartnersPricelistsCompanion toCompanion(bool nullToAbsent) {
    return PartnersPricelistsCompanion(
      guid: Value(guid),
      isDeleted: Value(isDeleted),
      timestamp: Value(timestamp),
      currentTimestamp: Value(currentTimestamp),
      lastSyncTime: lastSyncTime == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncTime),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      partnerId: Value(partnerId),
      pricelistId: Value(pricelistId),
      pricelistSetId: Value(pricelistSetId),
      discount: Value(discount),
    );
  }

  factory PartnersPricelist.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PartnersPricelist(
      guid: serializer.fromJson<String>(json['guid']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      currentTimestamp: serializer.fromJson<DateTime>(json['currentTimestamp']),
      lastSyncTime: serializer.fromJson<DateTime?>(json['lastSyncTime']),
      needSync: serializer.fromJson<bool>(json['needSync']),
      isNew: serializer.fromJson<bool>(json['isNew']),
      id: serializer.fromJson<int?>(json['id']),
      partnerId: serializer.fromJson<int>(json['partnerId']),
      pricelistId: serializer.fromJson<int>(json['pricelistId']),
      pricelistSetId: serializer.fromJson<int>(json['pricelistSetId']),
      discount: serializer.fromJson<double>(json['discount']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'guid': serializer.toJson<String>(guid),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'currentTimestamp': serializer.toJson<DateTime>(currentTimestamp),
      'lastSyncTime': serializer.toJson<DateTime?>(lastSyncTime),
      'needSync': serializer.toJson<bool>(needSync),
      'isNew': serializer.toJson<bool>(isNew),
      'id': serializer.toJson<int?>(id),
      'partnerId': serializer.toJson<int>(partnerId),
      'pricelistId': serializer.toJson<int>(pricelistId),
      'pricelistSetId': serializer.toJson<int>(pricelistSetId),
      'discount': serializer.toJson<double>(discount),
    };
  }

  PartnersPricelist copyWith(
          {String? guid,
          bool? isDeleted,
          DateTime? timestamp,
          DateTime? currentTimestamp,
          Value<DateTime?> lastSyncTime = const Value.absent(),
          bool? needSync,
          bool? isNew,
          Value<int?> id = const Value.absent(),
          int? partnerId,
          int? pricelistId,
          int? pricelistSetId,
          double? discount}) =>
      PartnersPricelist(
        guid: guid ?? this.guid,
        isDeleted: isDeleted ?? this.isDeleted,
        timestamp: timestamp ?? this.timestamp,
        currentTimestamp: currentTimestamp ?? this.currentTimestamp,
        lastSyncTime:
            lastSyncTime.present ? lastSyncTime.value : this.lastSyncTime,
        needSync: needSync ?? this.needSync,
        isNew: isNew ?? this.isNew,
        id: id.present ? id.value : this.id,
        partnerId: partnerId ?? this.partnerId,
        pricelistId: pricelistId ?? this.pricelistId,
        pricelistSetId: pricelistSetId ?? this.pricelistSetId,
        discount: discount ?? this.discount,
      );
  @override
  String toString() {
    return (StringBuffer('PartnersPricelist(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('needSync: $needSync, ')
          ..write('isNew: $isNew, ')
          ..write('id: $id, ')
          ..write('partnerId: $partnerId, ')
          ..write('pricelistId: $pricelistId, ')
          ..write('pricelistSetId: $pricelistSetId, ')
          ..write('discount: $discount')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      guid,
      isDeleted,
      timestamp,
      currentTimestamp,
      lastSyncTime,
      needSync,
      isNew,
      id,
      partnerId,
      pricelistId,
      pricelistSetId,
      discount);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PartnersPricelist &&
          other.guid == this.guid &&
          other.isDeleted == this.isDeleted &&
          other.timestamp == this.timestamp &&
          other.currentTimestamp == this.currentTimestamp &&
          other.lastSyncTime == this.lastSyncTime &&
          other.needSync == this.needSync &&
          other.isNew == this.isNew &&
          other.id == this.id &&
          other.partnerId == this.partnerId &&
          other.pricelistId == this.pricelistId &&
          other.pricelistSetId == this.pricelistSetId &&
          other.discount == this.discount);
}

class PartnersPricelistsCompanion extends UpdateCompanion<PartnersPricelist> {
  final Value<String> guid;
  final Value<bool> isDeleted;
  final Value<DateTime> timestamp;
  final Value<DateTime> currentTimestamp;
  final Value<DateTime?> lastSyncTime;
  final Value<int?> id;
  final Value<int> partnerId;
  final Value<int> pricelistId;
  final Value<int> pricelistSetId;
  final Value<double> discount;
  final Value<int> rowid;
  const PartnersPricelistsCompanion({
    this.guid = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    this.partnerId = const Value.absent(),
    this.pricelistId = const Value.absent(),
    this.pricelistSetId = const Value.absent(),
    this.discount = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PartnersPricelistsCompanion.insert({
    required String guid,
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    required int partnerId,
    required int pricelistId,
    required int pricelistSetId,
    required double discount,
    this.rowid = const Value.absent(),
  })  : guid = Value(guid),
        partnerId = Value(partnerId),
        pricelistId = Value(pricelistId),
        pricelistSetId = Value(pricelistSetId),
        discount = Value(discount);
  static Insertable<PartnersPricelist> custom({
    Expression<String>? guid,
    Expression<bool>? isDeleted,
    Expression<DateTime>? timestamp,
    Expression<DateTime>? currentTimestamp,
    Expression<DateTime>? lastSyncTime,
    Expression<int>? id,
    Expression<int>? partnerId,
    Expression<int>? pricelistId,
    Expression<int>? pricelistSetId,
    Expression<double>? discount,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (guid != null) 'guid': guid,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (timestamp != null) 'timestamp': timestamp,
      if (currentTimestamp != null) 'current_timestamp': currentTimestamp,
      if (lastSyncTime != null) 'last_sync_time': lastSyncTime,
      if (id != null) 'id': id,
      if (partnerId != null) 'partner_id': partnerId,
      if (pricelistId != null) 'pricelist_id': pricelistId,
      if (pricelistSetId != null) 'pricelist_set_id': pricelistSetId,
      if (discount != null) 'discount': discount,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PartnersPricelistsCompanion copyWith(
      {Value<String>? guid,
      Value<bool>? isDeleted,
      Value<DateTime>? timestamp,
      Value<DateTime>? currentTimestamp,
      Value<DateTime?>? lastSyncTime,
      Value<int?>? id,
      Value<int>? partnerId,
      Value<int>? pricelistId,
      Value<int>? pricelistSetId,
      Value<double>? discount,
      Value<int>? rowid}) {
    return PartnersPricelistsCompanion(
      guid: guid ?? this.guid,
      isDeleted: isDeleted ?? this.isDeleted,
      timestamp: timestamp ?? this.timestamp,
      currentTimestamp: currentTimestamp ?? this.currentTimestamp,
      lastSyncTime: lastSyncTime ?? this.lastSyncTime,
      id: id ?? this.id,
      partnerId: partnerId ?? this.partnerId,
      pricelistId: pricelistId ?? this.pricelistId,
      pricelistSetId: pricelistSetId ?? this.pricelistSetId,
      discount: discount ?? this.discount,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (guid.present) {
      map['guid'] = Variable<String>(guid.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (currentTimestamp.present) {
      map['current_timestamp'] = Variable<DateTime>(currentTimestamp.value);
    }
    if (lastSyncTime.present) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (partnerId.present) {
      map['partner_id'] = Variable<int>(partnerId.value);
    }
    if (pricelistId.present) {
      map['pricelist_id'] = Variable<int>(pricelistId.value);
    }
    if (pricelistSetId.present) {
      map['pricelist_set_id'] = Variable<int>(pricelistSetId.value);
    }
    if (discount.present) {
      map['discount'] = Variable<double>(discount.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PartnersPricelistsCompanion(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('id: $id, ')
          ..write('partnerId: $partnerId, ')
          ..write('pricelistId: $pricelistId, ')
          ..write('pricelistSetId: $pricelistSetId, ')
          ..write('discount: $discount, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GoodsRestrictionsTable extends GoodsRestrictions
    with TableInfo<$GoodsRestrictionsTable, GoodsRestriction> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GoodsRestrictionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _goodsIdMeta =
      const VerificationMeta('goodsId');
  @override
  late final GeneratedColumn<int> goodsId = GeneratedColumn<int>(
      'goods_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _buyerIdMeta =
      const VerificationMeta('buyerId');
  @override
  late final GeneratedColumn<int> buyerId = GeneratedColumn<int>(
      'buyer_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [goodsId, buyerId];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'goods_restrictions';
  @override
  VerificationContext validateIntegrity(Insertable<GoodsRestriction> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('goods_id')) {
      context.handle(_goodsIdMeta,
          goodsId.isAcceptableOrUnknown(data['goods_id']!, _goodsIdMeta));
    } else if (isInserting) {
      context.missing(_goodsIdMeta);
    }
    if (data.containsKey('buyer_id')) {
      context.handle(_buyerIdMeta,
          buyerId.isAcceptableOrUnknown(data['buyer_id']!, _buyerIdMeta));
    } else if (isInserting) {
      context.missing(_buyerIdMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {goodsId, buyerId};
  @override
  GoodsRestriction map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GoodsRestriction(
      goodsId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}goods_id'])!,
      buyerId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}buyer_id'])!,
    );
  }

  @override
  $GoodsRestrictionsTable createAlias(String alias) {
    return $GoodsRestrictionsTable(attachedDatabase, alias);
  }
}

class GoodsRestriction extends DataClass
    implements Insertable<GoodsRestriction> {
  final int goodsId;
  final int buyerId;
  const GoodsRestriction({required this.goodsId, required this.buyerId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['goods_id'] = Variable<int>(goodsId);
    map['buyer_id'] = Variable<int>(buyerId);
    return map;
  }

  GoodsRestrictionsCompanion toCompanion(bool nullToAbsent) {
    return GoodsRestrictionsCompanion(
      goodsId: Value(goodsId),
      buyerId: Value(buyerId),
    );
  }

  factory GoodsRestriction.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return GoodsRestriction(
      goodsId: serializer.fromJson<int>(json['goodsId']),
      buyerId: serializer.fromJson<int>(json['buyerId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'goodsId': serializer.toJson<int>(goodsId),
      'buyerId': serializer.toJson<int>(buyerId),
    };
  }

  GoodsRestriction copyWith({int? goodsId, int? buyerId}) => GoodsRestriction(
        goodsId: goodsId ?? this.goodsId,
        buyerId: buyerId ?? this.buyerId,
      );
  GoodsRestriction copyWithCompanion(GoodsRestrictionsCompanion data) {
    return GoodsRestriction(
      goodsId: data.goodsId.present ? data.goodsId.value : this.goodsId,
      buyerId: data.buyerId.present ? data.buyerId.value : this.buyerId,
    );
  }

  @override
  String toString() {
    return (StringBuffer('GoodsRestriction(')
          ..write('goodsId: $goodsId, ')
          ..write('buyerId: $buyerId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(goodsId, buyerId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GoodsRestriction &&
          other.goodsId == this.goodsId &&
          other.buyerId == this.buyerId);
}

class GoodsRestrictionsCompanion extends UpdateCompanion<GoodsRestriction> {
  final Value<int> goodsId;
  final Value<int> buyerId;
  final Value<int> rowid;
  const GoodsRestrictionsCompanion({
    this.goodsId = const Value.absent(),
    this.buyerId = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  GoodsRestrictionsCompanion.insert({
    required int goodsId,
    required int buyerId,
    this.rowid = const Value.absent(),
  })  : goodsId = Value(goodsId),
        buyerId = Value(buyerId);
  static Insertable<GoodsRestriction> custom({
    Expression<int>? goodsId,
    Expression<int>? buyerId,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (goodsId != null) 'goods_id': goodsId,
      if (buyerId != null) 'buyer_id': buyerId,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GoodsRestrictionsCompanion copyWith(
      {Value<int>? goodsId, Value<int>? buyerId, Value<int>? rowid}) {
    return GoodsRestrictionsCompanion(
      goodsId: goodsId ?? this.goodsId,
      buyerId: buyerId ?? this.buyerId,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (goodsId.present) {
      map['goods_id'] = Variable<int>(goodsId.value);
    }
    if (buyerId.present) {
      map['buyer_id'] = Variable<int>(buyerId.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GoodsRestrictionsCompanion(')
          ..write('goodsId: $goodsId, ')
          ..write('buyerId: $buyerId, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GoodsStocksTable extends GoodsStocks
    with TableInfo<$GoodsStocksTable, GoodsStock> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GoodsStocksTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _goodsIdMeta =
      const VerificationMeta('goodsId');
  @override
  late final GeneratedColumn<int> goodsId = GeneratedColumn<int>(
      'goods_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _siteIdMeta = const VerificationMeta('siteId');
  @override
  late final GeneratedColumn<int> siteId = GeneratedColumn<int>(
      'site_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _isVollowMeta =
      const VerificationMeta('isVollow');
  @override
  late final GeneratedColumn<bool> isVollow = GeneratedColumn<bool>(
      'is_vollow', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_vollow" IN (0, 1))'));
  static const VerificationMeta _volMeta = const VerificationMeta('vol');
  @override
  late final GeneratedColumn<int> vol = GeneratedColumn<int>(
      'vol', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _minVolMeta = const VerificationMeta('minVol');
  @override
  late final GeneratedColumn<int> minVol = GeneratedColumn<int>(
      'min_vol', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [goodsId, siteId, isVollow, vol, minVol];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'goods_stocks';
  @override
  VerificationContext validateIntegrity(Insertable<GoodsStock> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('goods_id')) {
      context.handle(_goodsIdMeta,
          goodsId.isAcceptableOrUnknown(data['goods_id']!, _goodsIdMeta));
    } else if (isInserting) {
      context.missing(_goodsIdMeta);
    }
    if (data.containsKey('site_id')) {
      context.handle(_siteIdMeta,
          siteId.isAcceptableOrUnknown(data['site_id']!, _siteIdMeta));
    } else if (isInserting) {
      context.missing(_siteIdMeta);
    }
    if (data.containsKey('is_vollow')) {
      context.handle(_isVollowMeta,
          isVollow.isAcceptableOrUnknown(data['is_vollow']!, _isVollowMeta));
    } else if (isInserting) {
      context.missing(_isVollowMeta);
    }
    if (data.containsKey('vol')) {
      context.handle(
          _volMeta, vol.isAcceptableOrUnknown(data['vol']!, _volMeta));
    } else if (isInserting) {
      context.missing(_volMeta);
    }
    if (data.containsKey('min_vol')) {
      context.handle(_minVolMeta,
          minVol.isAcceptableOrUnknown(data['min_vol']!, _minVolMeta));
    } else if (isInserting) {
      context.missing(_minVolMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {goodsId, siteId};
  @override
  GoodsStock map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GoodsStock(
      goodsId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}goods_id'])!,
      siteId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}site_id'])!,
      isVollow: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_vollow'])!,
      vol: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}vol'])!,
      minVol: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}min_vol'])!,
    );
  }

  @override
  $GoodsStocksTable createAlias(String alias) {
    return $GoodsStocksTable(attachedDatabase, alias);
  }
}

class GoodsStock extends DataClass implements Insertable<GoodsStock> {
  final int goodsId;
  final int siteId;
  final bool isVollow;
  final int vol;
  final int minVol;
  const GoodsStock(
      {required this.goodsId,
      required this.siteId,
      required this.isVollow,
      required this.vol,
      required this.minVol});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['goods_id'] = Variable<int>(goodsId);
    map['site_id'] = Variable<int>(siteId);
    map['is_vollow'] = Variable<bool>(isVollow);
    map['vol'] = Variable<int>(vol);
    map['min_vol'] = Variable<int>(minVol);
    return map;
  }

  GoodsStocksCompanion toCompanion(bool nullToAbsent) {
    return GoodsStocksCompanion(
      goodsId: Value(goodsId),
      siteId: Value(siteId),
      isVollow: Value(isVollow),
      vol: Value(vol),
      minVol: Value(minVol),
    );
  }

  factory GoodsStock.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return GoodsStock(
      goodsId: serializer.fromJson<int>(json['goodsId']),
      siteId: serializer.fromJson<int>(json['siteId']),
      isVollow: serializer.fromJson<bool>(json['isVollow']),
      vol: serializer.fromJson<int>(json['vol']),
      minVol: serializer.fromJson<int>(json['minVol']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'goodsId': serializer.toJson<int>(goodsId),
      'siteId': serializer.toJson<int>(siteId),
      'isVollow': serializer.toJson<bool>(isVollow),
      'vol': serializer.toJson<int>(vol),
      'minVol': serializer.toJson<int>(minVol),
    };
  }

  GoodsStock copyWith(
          {int? goodsId, int? siteId, bool? isVollow, int? vol, int? minVol}) =>
      GoodsStock(
        goodsId: goodsId ?? this.goodsId,
        siteId: siteId ?? this.siteId,
        isVollow: isVollow ?? this.isVollow,
        vol: vol ?? this.vol,
        minVol: minVol ?? this.minVol,
      );
  GoodsStock copyWithCompanion(GoodsStocksCompanion data) {
    return GoodsStock(
      goodsId: data.goodsId.present ? data.goodsId.value : this.goodsId,
      siteId: data.siteId.present ? data.siteId.value : this.siteId,
      isVollow: data.isVollow.present ? data.isVollow.value : this.isVollow,
      vol: data.vol.present ? data.vol.value : this.vol,
      minVol: data.minVol.present ? data.minVol.value : this.minVol,
    );
  }

  @override
  String toString() {
    return (StringBuffer('GoodsStock(')
          ..write('goodsId: $goodsId, ')
          ..write('siteId: $siteId, ')
          ..write('isVollow: $isVollow, ')
          ..write('vol: $vol, ')
          ..write('minVol: $minVol')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(goodsId, siteId, isVollow, vol, minVol);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GoodsStock &&
          other.goodsId == this.goodsId &&
          other.siteId == this.siteId &&
          other.isVollow == this.isVollow &&
          other.vol == this.vol &&
          other.minVol == this.minVol);
}

class GoodsStocksCompanion extends UpdateCompanion<GoodsStock> {
  final Value<int> goodsId;
  final Value<int> siteId;
  final Value<bool> isVollow;
  final Value<int> vol;
  final Value<int> minVol;
  final Value<int> rowid;
  const GoodsStocksCompanion({
    this.goodsId = const Value.absent(),
    this.siteId = const Value.absent(),
    this.isVollow = const Value.absent(),
    this.vol = const Value.absent(),
    this.minVol = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  GoodsStocksCompanion.insert({
    required int goodsId,
    required int siteId,
    required bool isVollow,
    required int vol,
    required int minVol,
    this.rowid = const Value.absent(),
  })  : goodsId = Value(goodsId),
        siteId = Value(siteId),
        isVollow = Value(isVollow),
        vol = Value(vol),
        minVol = Value(minVol);
  static Insertable<GoodsStock> custom({
    Expression<int>? goodsId,
    Expression<int>? siteId,
    Expression<bool>? isVollow,
    Expression<int>? vol,
    Expression<int>? minVol,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (goodsId != null) 'goods_id': goodsId,
      if (siteId != null) 'site_id': siteId,
      if (isVollow != null) 'is_vollow': isVollow,
      if (vol != null) 'vol': vol,
      if (minVol != null) 'min_vol': minVol,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GoodsStocksCompanion copyWith(
      {Value<int>? goodsId,
      Value<int>? siteId,
      Value<bool>? isVollow,
      Value<int>? vol,
      Value<int>? minVol,
      Value<int>? rowid}) {
    return GoodsStocksCompanion(
      goodsId: goodsId ?? this.goodsId,
      siteId: siteId ?? this.siteId,
      isVollow: isVollow ?? this.isVollow,
      vol: vol ?? this.vol,
      minVol: minVol ?? this.minVol,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (goodsId.present) {
      map['goods_id'] = Variable<int>(goodsId.value);
    }
    if (siteId.present) {
      map['site_id'] = Variable<int>(siteId.value);
    }
    if (isVollow.present) {
      map['is_vollow'] = Variable<bool>(isVollow.value);
    }
    if (vol.present) {
      map['vol'] = Variable<int>(vol.value);
    }
    if (minVol.present) {
      map['min_vol'] = Variable<int>(minVol.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GoodsStocksCompanion(')
          ..write('goodsId: $goodsId, ')
          ..write('siteId: $siteId, ')
          ..write('isVollow: $isVollow, ')
          ..write('vol: $vol, ')
          ..write('minVol: $minVol, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GoodsPartnersPricelistsTable extends GoodsPartnersPricelists
    with TableInfo<$GoodsPartnersPricelistsTable, GoodsPartnersPricelist> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GoodsPartnersPricelistsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _goodsIdMeta =
      const VerificationMeta('goodsId');
  @override
  late final GeneratedColumn<int> goodsId = GeneratedColumn<int>(
      'goods_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _partnerPricelistIdMeta =
      const VerificationMeta('partnerPricelistId');
  @override
  late final GeneratedColumn<int> partnerPricelistId = GeneratedColumn<int>(
      'partner_pricelist_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _pricelistIdMeta =
      const VerificationMeta('pricelistId');
  @override
  late final GeneratedColumn<int> pricelistId = GeneratedColumn<int>(
      'pricelist_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _discountMeta =
      const VerificationMeta('discount');
  @override
  late final GeneratedColumn<double> discount = GeneratedColumn<double>(
      'discount', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [goodsId, partnerPricelistId, pricelistId, discount];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'goods_partners_pricelists';
  @override
  VerificationContext validateIntegrity(
      Insertable<GoodsPartnersPricelist> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('goods_id')) {
      context.handle(_goodsIdMeta,
          goodsId.isAcceptableOrUnknown(data['goods_id']!, _goodsIdMeta));
    } else if (isInserting) {
      context.missing(_goodsIdMeta);
    }
    if (data.containsKey('partner_pricelist_id')) {
      context.handle(
          _partnerPricelistIdMeta,
          partnerPricelistId.isAcceptableOrUnknown(
              data['partner_pricelist_id']!, _partnerPricelistIdMeta));
    } else if (isInserting) {
      context.missing(_partnerPricelistIdMeta);
    }
    if (data.containsKey('pricelist_id')) {
      context.handle(
          _pricelistIdMeta,
          pricelistId.isAcceptableOrUnknown(
              data['pricelist_id']!, _pricelistIdMeta));
    } else if (isInserting) {
      context.missing(_pricelistIdMeta);
    }
    if (data.containsKey('discount')) {
      context.handle(_discountMeta,
          discount.isAcceptableOrUnknown(data['discount']!, _discountMeta));
    } else if (isInserting) {
      context.missing(_discountMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey =>
      {goodsId, partnerPricelistId, pricelistId};
  @override
  GoodsPartnersPricelist map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GoodsPartnersPricelist(
      goodsId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}goods_id'])!,
      partnerPricelistId: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}partner_pricelist_id'])!,
      pricelistId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}pricelist_id'])!,
      discount: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}discount'])!,
    );
  }

  @override
  $GoodsPartnersPricelistsTable createAlias(String alias) {
    return $GoodsPartnersPricelistsTable(attachedDatabase, alias);
  }
}

class GoodsPartnersPricelist extends DataClass
    implements Insertable<GoodsPartnersPricelist> {
  final int goodsId;
  final int partnerPricelistId;
  final int pricelistId;
  final double discount;
  const GoodsPartnersPricelist(
      {required this.goodsId,
      required this.partnerPricelistId,
      required this.pricelistId,
      required this.discount});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['goods_id'] = Variable<int>(goodsId);
    map['partner_pricelist_id'] = Variable<int>(partnerPricelistId);
    map['pricelist_id'] = Variable<int>(pricelistId);
    map['discount'] = Variable<double>(discount);
    return map;
  }

  GoodsPartnersPricelistsCompanion toCompanion(bool nullToAbsent) {
    return GoodsPartnersPricelistsCompanion(
      goodsId: Value(goodsId),
      partnerPricelistId: Value(partnerPricelistId),
      pricelistId: Value(pricelistId),
      discount: Value(discount),
    );
  }

  factory GoodsPartnersPricelist.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return GoodsPartnersPricelist(
      goodsId: serializer.fromJson<int>(json['goodsId']),
      partnerPricelistId: serializer.fromJson<int>(json['partnerPricelistId']),
      pricelistId: serializer.fromJson<int>(json['pricelistId']),
      discount: serializer.fromJson<double>(json['discount']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'goodsId': serializer.toJson<int>(goodsId),
      'partnerPricelistId': serializer.toJson<int>(partnerPricelistId),
      'pricelistId': serializer.toJson<int>(pricelistId),
      'discount': serializer.toJson<double>(discount),
    };
  }

  GoodsPartnersPricelist copyWith(
          {int? goodsId,
          int? partnerPricelistId,
          int? pricelistId,
          double? discount}) =>
      GoodsPartnersPricelist(
        goodsId: goodsId ?? this.goodsId,
        partnerPricelistId: partnerPricelistId ?? this.partnerPricelistId,
        pricelistId: pricelistId ?? this.pricelistId,
        discount: discount ?? this.discount,
      );
  GoodsPartnersPricelist copyWithCompanion(
      GoodsPartnersPricelistsCompanion data) {
    return GoodsPartnersPricelist(
      goodsId: data.goodsId.present ? data.goodsId.value : this.goodsId,
      partnerPricelistId: data.partnerPricelistId.present
          ? data.partnerPricelistId.value
          : this.partnerPricelistId,
      pricelistId:
          data.pricelistId.present ? data.pricelistId.value : this.pricelistId,
      discount: data.discount.present ? data.discount.value : this.discount,
    );
  }

  @override
  String toString() {
    return (StringBuffer('GoodsPartnersPricelist(')
          ..write('goodsId: $goodsId, ')
          ..write('partnerPricelistId: $partnerPricelistId, ')
          ..write('pricelistId: $pricelistId, ')
          ..write('discount: $discount')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(goodsId, partnerPricelistId, pricelistId, discount);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GoodsPartnersPricelist &&
          other.goodsId == this.goodsId &&
          other.partnerPricelistId == this.partnerPricelistId &&
          other.pricelistId == this.pricelistId &&
          other.discount == this.discount);
}

class GoodsPartnersPricelistsCompanion
    extends UpdateCompanion<GoodsPartnersPricelist> {
  final Value<int> goodsId;
  final Value<int> partnerPricelistId;
  final Value<int> pricelistId;
  final Value<double> discount;
  final Value<int> rowid;
  const GoodsPartnersPricelistsCompanion({
    this.goodsId = const Value.absent(),
    this.partnerPricelistId = const Value.absent(),
    this.pricelistId = const Value.absent(),
    this.discount = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  GoodsPartnersPricelistsCompanion.insert({
    required int goodsId,
    required int partnerPricelistId,
    required int pricelistId,
    required double discount,
    this.rowid = const Value.absent(),
  })  : goodsId = Value(goodsId),
        partnerPricelistId = Value(partnerPricelistId),
        pricelistId = Value(pricelistId),
        discount = Value(discount);
  static Insertable<GoodsPartnersPricelist> custom({
    Expression<int>? goodsId,
    Expression<int>? partnerPricelistId,
    Expression<int>? pricelistId,
    Expression<double>? discount,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (goodsId != null) 'goods_id': goodsId,
      if (partnerPricelistId != null)
        'partner_pricelist_id': partnerPricelistId,
      if (pricelistId != null) 'pricelist_id': pricelistId,
      if (discount != null) 'discount': discount,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GoodsPartnersPricelistsCompanion copyWith(
      {Value<int>? goodsId,
      Value<int>? partnerPricelistId,
      Value<int>? pricelistId,
      Value<double>? discount,
      Value<int>? rowid}) {
    return GoodsPartnersPricelistsCompanion(
      goodsId: goodsId ?? this.goodsId,
      partnerPricelistId: partnerPricelistId ?? this.partnerPricelistId,
      pricelistId: pricelistId ?? this.pricelistId,
      discount: discount ?? this.discount,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (goodsId.present) {
      map['goods_id'] = Variable<int>(goodsId.value);
    }
    if (partnerPricelistId.present) {
      map['partner_pricelist_id'] = Variable<int>(partnerPricelistId.value);
    }
    if (pricelistId.present) {
      map['pricelist_id'] = Variable<int>(pricelistId.value);
    }
    if (discount.present) {
      map['discount'] = Variable<double>(discount.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GoodsPartnersPricelistsCompanion(')
          ..write('goodsId: $goodsId, ')
          ..write('partnerPricelistId: $partnerPricelistId, ')
          ..write('pricelistId: $pricelistId, ')
          ..write('discount: $discount, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GoodsReturnStocksTable extends GoodsReturnStocks
    with TableInfo<$GoodsReturnStocksTable, GoodsReturnStock> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GoodsReturnStocksTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _goodsIdMeta =
      const VerificationMeta('goodsId');
  @override
  late final GeneratedColumn<int> goodsId = GeneratedColumn<int>(
      'goods_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _returnActTypeIdMeta =
      const VerificationMeta('returnActTypeId');
  @override
  late final GeneratedColumn<int> returnActTypeId = GeneratedColumn<int>(
      'return_act_type_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _buyerIdMeta =
      const VerificationMeta('buyerId');
  @override
  late final GeneratedColumn<int> buyerId = GeneratedColumn<int>(
      'buyer_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _volMeta = const VerificationMeta('vol');
  @override
  late final GeneratedColumn<double> vol = GeneratedColumn<double>(
      'vol', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _receptIdMeta =
      const VerificationMeta('receptId');
  @override
  late final GeneratedColumn<int> receptId = GeneratedColumn<int>(
      'recept_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _receptSubidMeta =
      const VerificationMeta('receptSubid');
  @override
  late final GeneratedColumn<int> receptSubid = GeneratedColumn<int>(
      'recept_subid', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _receptDateMeta =
      const VerificationMeta('receptDate');
  @override
  late final GeneratedColumn<DateTime> receptDate = GeneratedColumn<DateTime>(
      'recept_date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _receptNdocMeta =
      const VerificationMeta('receptNdoc');
  @override
  late final GeneratedColumn<String> receptNdoc = GeneratedColumn<String>(
      'recept_ndoc', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        goodsId,
        returnActTypeId,
        buyerId,
        vol,
        receptId,
        receptSubid,
        receptDate,
        receptNdoc
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'goods_return_stocks';
  @override
  VerificationContext validateIntegrity(Insertable<GoodsReturnStock> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('goods_id')) {
      context.handle(_goodsIdMeta,
          goodsId.isAcceptableOrUnknown(data['goods_id']!, _goodsIdMeta));
    } else if (isInserting) {
      context.missing(_goodsIdMeta);
    }
    if (data.containsKey('return_act_type_id')) {
      context.handle(
          _returnActTypeIdMeta,
          returnActTypeId.isAcceptableOrUnknown(
              data['return_act_type_id']!, _returnActTypeIdMeta));
    } else if (isInserting) {
      context.missing(_returnActTypeIdMeta);
    }
    if (data.containsKey('buyer_id')) {
      context.handle(_buyerIdMeta,
          buyerId.isAcceptableOrUnknown(data['buyer_id']!, _buyerIdMeta));
    } else if (isInserting) {
      context.missing(_buyerIdMeta);
    }
    if (data.containsKey('vol')) {
      context.handle(
          _volMeta, vol.isAcceptableOrUnknown(data['vol']!, _volMeta));
    } else if (isInserting) {
      context.missing(_volMeta);
    }
    if (data.containsKey('recept_id')) {
      context.handle(_receptIdMeta,
          receptId.isAcceptableOrUnknown(data['recept_id']!, _receptIdMeta));
    } else if (isInserting) {
      context.missing(_receptIdMeta);
    }
    if (data.containsKey('recept_subid')) {
      context.handle(
          _receptSubidMeta,
          receptSubid.isAcceptableOrUnknown(
              data['recept_subid']!, _receptSubidMeta));
    } else if (isInserting) {
      context.missing(_receptSubidMeta);
    }
    if (data.containsKey('recept_date')) {
      context.handle(
          _receptDateMeta,
          receptDate.isAcceptableOrUnknown(
              data['recept_date']!, _receptDateMeta));
    } else if (isInserting) {
      context.missing(_receptDateMeta);
    }
    if (data.containsKey('recept_ndoc')) {
      context.handle(
          _receptNdocMeta,
          receptNdoc.isAcceptableOrUnknown(
              data['recept_ndoc']!, _receptNdocMeta));
    } else if (isInserting) {
      context.missing(_receptNdocMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey =>
      {goodsId, receptId, receptSubid, returnActTypeId};
  @override
  GoodsReturnStock map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GoodsReturnStock(
      goodsId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}goods_id'])!,
      returnActTypeId: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}return_act_type_id'])!,
      buyerId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}buyer_id'])!,
      vol: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}vol'])!,
      receptId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}recept_id'])!,
      receptSubid: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}recept_subid'])!,
      receptDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}recept_date'])!,
      receptNdoc: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}recept_ndoc'])!,
    );
  }

  @override
  $GoodsReturnStocksTable createAlias(String alias) {
    return $GoodsReturnStocksTable(attachedDatabase, alias);
  }
}

class GoodsReturnStock extends DataClass
    implements Insertable<GoodsReturnStock> {
  final int goodsId;
  final int returnActTypeId;
  final int buyerId;
  final double vol;
  final int receptId;
  final int receptSubid;
  final DateTime receptDate;
  final String receptNdoc;
  const GoodsReturnStock(
      {required this.goodsId,
      required this.returnActTypeId,
      required this.buyerId,
      required this.vol,
      required this.receptId,
      required this.receptSubid,
      required this.receptDate,
      required this.receptNdoc});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['goods_id'] = Variable<int>(goodsId);
    map['return_act_type_id'] = Variable<int>(returnActTypeId);
    map['buyer_id'] = Variable<int>(buyerId);
    map['vol'] = Variable<double>(vol);
    map['recept_id'] = Variable<int>(receptId);
    map['recept_subid'] = Variable<int>(receptSubid);
    map['recept_date'] = Variable<DateTime>(receptDate);
    map['recept_ndoc'] = Variable<String>(receptNdoc);
    return map;
  }

  GoodsReturnStocksCompanion toCompanion(bool nullToAbsent) {
    return GoodsReturnStocksCompanion(
      goodsId: Value(goodsId),
      returnActTypeId: Value(returnActTypeId),
      buyerId: Value(buyerId),
      vol: Value(vol),
      receptId: Value(receptId),
      receptSubid: Value(receptSubid),
      receptDate: Value(receptDate),
      receptNdoc: Value(receptNdoc),
    );
  }

  factory GoodsReturnStock.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return GoodsReturnStock(
      goodsId: serializer.fromJson<int>(json['goodsId']),
      returnActTypeId: serializer.fromJson<int>(json['returnActTypeId']),
      buyerId: serializer.fromJson<int>(json['buyerId']),
      vol: serializer.fromJson<double>(json['vol']),
      receptId: serializer.fromJson<int>(json['receptId']),
      receptSubid: serializer.fromJson<int>(json['receptSubid']),
      receptDate: serializer.fromJson<DateTime>(json['receptDate']),
      receptNdoc: serializer.fromJson<String>(json['receptNdoc']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'goodsId': serializer.toJson<int>(goodsId),
      'returnActTypeId': serializer.toJson<int>(returnActTypeId),
      'buyerId': serializer.toJson<int>(buyerId),
      'vol': serializer.toJson<double>(vol),
      'receptId': serializer.toJson<int>(receptId),
      'receptSubid': serializer.toJson<int>(receptSubid),
      'receptDate': serializer.toJson<DateTime>(receptDate),
      'receptNdoc': serializer.toJson<String>(receptNdoc),
    };
  }

  GoodsReturnStock copyWith(
          {int? goodsId,
          int? returnActTypeId,
          int? buyerId,
          double? vol,
          int? receptId,
          int? receptSubid,
          DateTime? receptDate,
          String? receptNdoc}) =>
      GoodsReturnStock(
        goodsId: goodsId ?? this.goodsId,
        returnActTypeId: returnActTypeId ?? this.returnActTypeId,
        buyerId: buyerId ?? this.buyerId,
        vol: vol ?? this.vol,
        receptId: receptId ?? this.receptId,
        receptSubid: receptSubid ?? this.receptSubid,
        receptDate: receptDate ?? this.receptDate,
        receptNdoc: receptNdoc ?? this.receptNdoc,
      );
  GoodsReturnStock copyWithCompanion(GoodsReturnStocksCompanion data) {
    return GoodsReturnStock(
      goodsId: data.goodsId.present ? data.goodsId.value : this.goodsId,
      returnActTypeId: data.returnActTypeId.present
          ? data.returnActTypeId.value
          : this.returnActTypeId,
      buyerId: data.buyerId.present ? data.buyerId.value : this.buyerId,
      vol: data.vol.present ? data.vol.value : this.vol,
      receptId: data.receptId.present ? data.receptId.value : this.receptId,
      receptSubid:
          data.receptSubid.present ? data.receptSubid.value : this.receptSubid,
      receptDate:
          data.receptDate.present ? data.receptDate.value : this.receptDate,
      receptNdoc:
          data.receptNdoc.present ? data.receptNdoc.value : this.receptNdoc,
    );
  }

  @override
  String toString() {
    return (StringBuffer('GoodsReturnStock(')
          ..write('goodsId: $goodsId, ')
          ..write('returnActTypeId: $returnActTypeId, ')
          ..write('buyerId: $buyerId, ')
          ..write('vol: $vol, ')
          ..write('receptId: $receptId, ')
          ..write('receptSubid: $receptSubid, ')
          ..write('receptDate: $receptDate, ')
          ..write('receptNdoc: $receptNdoc')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(goodsId, returnActTypeId, buyerId, vol,
      receptId, receptSubid, receptDate, receptNdoc);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GoodsReturnStock &&
          other.goodsId == this.goodsId &&
          other.returnActTypeId == this.returnActTypeId &&
          other.buyerId == this.buyerId &&
          other.vol == this.vol &&
          other.receptId == this.receptId &&
          other.receptSubid == this.receptSubid &&
          other.receptDate == this.receptDate &&
          other.receptNdoc == this.receptNdoc);
}

class GoodsReturnStocksCompanion extends UpdateCompanion<GoodsReturnStock> {
  final Value<int> goodsId;
  final Value<int> returnActTypeId;
  final Value<int> buyerId;
  final Value<double> vol;
  final Value<int> receptId;
  final Value<int> receptSubid;
  final Value<DateTime> receptDate;
  final Value<String> receptNdoc;
  final Value<int> rowid;
  const GoodsReturnStocksCompanion({
    this.goodsId = const Value.absent(),
    this.returnActTypeId = const Value.absent(),
    this.buyerId = const Value.absent(),
    this.vol = const Value.absent(),
    this.receptId = const Value.absent(),
    this.receptSubid = const Value.absent(),
    this.receptDate = const Value.absent(),
    this.receptNdoc = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  GoodsReturnStocksCompanion.insert({
    required int goodsId,
    required int returnActTypeId,
    required int buyerId,
    required double vol,
    required int receptId,
    required int receptSubid,
    required DateTime receptDate,
    required String receptNdoc,
    this.rowid = const Value.absent(),
  })  : goodsId = Value(goodsId),
        returnActTypeId = Value(returnActTypeId),
        buyerId = Value(buyerId),
        vol = Value(vol),
        receptId = Value(receptId),
        receptSubid = Value(receptSubid),
        receptDate = Value(receptDate),
        receptNdoc = Value(receptNdoc);
  static Insertable<GoodsReturnStock> custom({
    Expression<int>? goodsId,
    Expression<int>? returnActTypeId,
    Expression<int>? buyerId,
    Expression<double>? vol,
    Expression<int>? receptId,
    Expression<int>? receptSubid,
    Expression<DateTime>? receptDate,
    Expression<String>? receptNdoc,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (goodsId != null) 'goods_id': goodsId,
      if (returnActTypeId != null) 'return_act_type_id': returnActTypeId,
      if (buyerId != null) 'buyer_id': buyerId,
      if (vol != null) 'vol': vol,
      if (receptId != null) 'recept_id': receptId,
      if (receptSubid != null) 'recept_subid': receptSubid,
      if (receptDate != null) 'recept_date': receptDate,
      if (receptNdoc != null) 'recept_ndoc': receptNdoc,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GoodsReturnStocksCompanion copyWith(
      {Value<int>? goodsId,
      Value<int>? returnActTypeId,
      Value<int>? buyerId,
      Value<double>? vol,
      Value<int>? receptId,
      Value<int>? receptSubid,
      Value<DateTime>? receptDate,
      Value<String>? receptNdoc,
      Value<int>? rowid}) {
    return GoodsReturnStocksCompanion(
      goodsId: goodsId ?? this.goodsId,
      returnActTypeId: returnActTypeId ?? this.returnActTypeId,
      buyerId: buyerId ?? this.buyerId,
      vol: vol ?? this.vol,
      receptId: receptId ?? this.receptId,
      receptSubid: receptSubid ?? this.receptSubid,
      receptDate: receptDate ?? this.receptDate,
      receptNdoc: receptNdoc ?? this.receptNdoc,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (goodsId.present) {
      map['goods_id'] = Variable<int>(goodsId.value);
    }
    if (returnActTypeId.present) {
      map['return_act_type_id'] = Variable<int>(returnActTypeId.value);
    }
    if (buyerId.present) {
      map['buyer_id'] = Variable<int>(buyerId.value);
    }
    if (vol.present) {
      map['vol'] = Variable<double>(vol.value);
    }
    if (receptId.present) {
      map['recept_id'] = Variable<int>(receptId.value);
    }
    if (receptSubid.present) {
      map['recept_subid'] = Variable<int>(receptSubid.value);
    }
    if (receptDate.present) {
      map['recept_date'] = Variable<DateTime>(receptDate.value);
    }
    if (receptNdoc.present) {
      map['recept_ndoc'] = Variable<String>(receptNdoc.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GoodsReturnStocksCompanion(')
          ..write('goodsId: $goodsId, ')
          ..write('returnActTypeId: $returnActTypeId, ')
          ..write('buyerId: $buyerId, ')
          ..write('vol: $vol, ')
          ..write('receptId: $receptId, ')
          ..write('receptSubid: $receptSubid, ')
          ..write('receptDate: $receptDate, ')
          ..write('receptNdoc: $receptNdoc, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ReturnActsTable extends ReturnActs
    with TableInfo<$ReturnActsTable, ReturnAct> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ReturnActsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _guidMeta = const VerificationMeta('guid');
  @override
  late final GeneratedColumn<String> guid = GeneratedColumn<String>(
      'guid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _timestampMeta =
      const VerificationMeta('timestamp');
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
      'timestamp', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _currentTimestampMeta =
      const VerificationMeta('currentTimestamp');
  @override
  late final GeneratedColumn<DateTime> currentTimestamp =
      GeneratedColumn<DateTime>('current_timestamp', aliasedName, false,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          defaultValue: currentDateAndTime);
  static const VerificationMeta _lastSyncTimeMeta =
      const VerificationMeta('lastSyncTime');
  @override
  late final GeneratedColumn<DateTime> lastSyncTime = GeneratedColumn<DateTime>(
      'last_sync_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _needSyncMeta =
      const VerificationMeta('needSync');
  @override
  late final GeneratedColumn<bool> needSync = GeneratedColumn<bool>(
      'need_sync', aliasedName, false,
      generatedAs: GeneratedAs(
          (isNew & BooleanExpressionOperators(isDeleted).not()) |
              (BooleanExpressionOperators(isNew).not() &
                  ComparableExpr(lastSyncTime).isSmallerThan(timestamp)),
          true),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("need_sync" IN (0, 1))'));
  static const VerificationMeta _isNewMeta = const VerificationMeta('isNew');
  @override
  late final GeneratedColumn<bool> isNew = GeneratedColumn<bool>(
      'is_new', aliasedName, false,
      generatedAs: GeneratedAs(lastSyncTime.isNull(), false),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_new" IN (0, 1))'));
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
      'date', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _numberMeta = const VerificationMeta('number');
  @override
  late final GeneratedColumn<String> number = GeneratedColumn<String>(
      'number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _buyerIdMeta =
      const VerificationMeta('buyerId');
  @override
  late final GeneratedColumn<int> buyerId = GeneratedColumn<int>(
      'buyer_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _needPickupMeta =
      const VerificationMeta('needPickup');
  @override
  late final GeneratedColumn<bool> needPickup = GeneratedColumn<bool>(
      'need_pickup', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("need_pickup" IN (0, 1))'));
  static const VerificationMeta _returnActTypeIdMeta =
      const VerificationMeta('returnActTypeId');
  @override
  late final GeneratedColumn<int> returnActTypeId = GeneratedColumn<int>(
      'return_act_type_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _receptIdMeta =
      const VerificationMeta('receptId');
  @override
  late final GeneratedColumn<int> receptId = GeneratedColumn<int>(
      'recept_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _receptNdocMeta =
      const VerificationMeta('receptNdoc');
  @override
  late final GeneratedColumn<String> receptNdoc = GeneratedColumn<String>(
      'recept_ndoc', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _receptDateMeta =
      const VerificationMeta('receptDate');
  @override
  late final GeneratedColumn<DateTime> receptDate = GeneratedColumn<DateTime>(
      'recept_date', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        guid,
        isDeleted,
        timestamp,
        currentTimestamp,
        lastSyncTime,
        needSync,
        isNew,
        id,
        date,
        number,
        buyerId,
        needPickup,
        returnActTypeId,
        receptId,
        receptNdoc,
        receptDate
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'return_acts';
  @override
  VerificationContext validateIntegrity(Insertable<ReturnAct> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('guid')) {
      context.handle(
          _guidMeta, guid.isAcceptableOrUnknown(data['guid']!, _guidMeta));
    } else if (isInserting) {
      context.missing(_guidMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('timestamp')) {
      context.handle(_timestampMeta,
          timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta));
    }
    if (data.containsKey('current_timestamp')) {
      context.handle(
          _currentTimestampMeta,
          currentTimestamp.isAcceptableOrUnknown(
              data['current_timestamp']!, _currentTimestampMeta));
    }
    if (data.containsKey('last_sync_time')) {
      context.handle(
          _lastSyncTimeMeta,
          lastSyncTime.isAcceptableOrUnknown(
              data['last_sync_time']!, _lastSyncTimeMeta));
    }
    if (data.containsKey('need_sync')) {
      context.handle(_needSyncMeta,
          needSync.isAcceptableOrUnknown(data['need_sync']!, _needSyncMeta));
    }
    if (data.containsKey('is_new')) {
      context.handle(
          _isNewMeta, isNew.isAcceptableOrUnknown(data['is_new']!, _isNewMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('date')) {
      context.handle(
          _dateMeta, date.isAcceptableOrUnknown(data['date']!, _dateMeta));
    }
    if (data.containsKey('number')) {
      context.handle(_numberMeta,
          number.isAcceptableOrUnknown(data['number']!, _numberMeta));
    }
    if (data.containsKey('buyer_id')) {
      context.handle(_buyerIdMeta,
          buyerId.isAcceptableOrUnknown(data['buyer_id']!, _buyerIdMeta));
    }
    if (data.containsKey('need_pickup')) {
      context.handle(
          _needPickupMeta,
          needPickup.isAcceptableOrUnknown(
              data['need_pickup']!, _needPickupMeta));
    } else if (isInserting) {
      context.missing(_needPickupMeta);
    }
    if (data.containsKey('return_act_type_id')) {
      context.handle(
          _returnActTypeIdMeta,
          returnActTypeId.isAcceptableOrUnknown(
              data['return_act_type_id']!, _returnActTypeIdMeta));
    }
    if (data.containsKey('recept_id')) {
      context.handle(_receptIdMeta,
          receptId.isAcceptableOrUnknown(data['recept_id']!, _receptIdMeta));
    }
    if (data.containsKey('recept_ndoc')) {
      context.handle(
          _receptNdocMeta,
          receptNdoc.isAcceptableOrUnknown(
              data['recept_ndoc']!, _receptNdocMeta));
    }
    if (data.containsKey('recept_date')) {
      context.handle(
          _receptDateMeta,
          receptDate.isAcceptableOrUnknown(
              data['recept_date']!, _receptDateMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {guid};
  @override
  ReturnAct map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ReturnAct(
      guid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}guid'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      timestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}timestamp'])!,
      currentTimestamp: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}current_timestamp'])!,
      lastSyncTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_sync_time']),
      needSync: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_sync'])!,
      isNew: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_new'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id']),
      date: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}date']),
      number: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}number']),
      buyerId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}buyer_id']),
      needPickup: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_pickup'])!,
      returnActTypeId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}return_act_type_id']),
      receptId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}recept_id']),
      receptNdoc: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}recept_ndoc']),
      receptDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}recept_date']),
    );
  }

  @override
  $ReturnActsTable createAlias(String alias) {
    return $ReturnActsTable(attachedDatabase, alias);
  }
}

class ReturnAct extends DataClass implements Insertable<ReturnAct> {
  final String guid;
  final bool isDeleted;
  final DateTime timestamp;
  final DateTime currentTimestamp;
  final DateTime? lastSyncTime;
  final bool needSync;
  final bool isNew;
  final int? id;
  final DateTime? date;
  final String? number;
  final int? buyerId;
  final bool needPickup;
  final int? returnActTypeId;
  final int? receptId;
  final String? receptNdoc;
  final DateTime? receptDate;
  const ReturnAct(
      {required this.guid,
      required this.isDeleted,
      required this.timestamp,
      required this.currentTimestamp,
      this.lastSyncTime,
      required this.needSync,
      required this.isNew,
      this.id,
      this.date,
      this.number,
      this.buyerId,
      required this.needPickup,
      this.returnActTypeId,
      this.receptId,
      this.receptNdoc,
      this.receptDate});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['guid'] = Variable<String>(guid);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['timestamp'] = Variable<DateTime>(timestamp);
    map['current_timestamp'] = Variable<DateTime>(currentTimestamp);
    if (!nullToAbsent || lastSyncTime != null) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || date != null) {
      map['date'] = Variable<DateTime>(date);
    }
    if (!nullToAbsent || number != null) {
      map['number'] = Variable<String>(number);
    }
    if (!nullToAbsent || buyerId != null) {
      map['buyer_id'] = Variable<int>(buyerId);
    }
    map['need_pickup'] = Variable<bool>(needPickup);
    if (!nullToAbsent || returnActTypeId != null) {
      map['return_act_type_id'] = Variable<int>(returnActTypeId);
    }
    if (!nullToAbsent || receptId != null) {
      map['recept_id'] = Variable<int>(receptId);
    }
    if (!nullToAbsent || receptNdoc != null) {
      map['recept_ndoc'] = Variable<String>(receptNdoc);
    }
    if (!nullToAbsent || receptDate != null) {
      map['recept_date'] = Variable<DateTime>(receptDate);
    }
    return map;
  }

  ReturnActsCompanion toCompanion(bool nullToAbsent) {
    return ReturnActsCompanion(
      guid: Value(guid),
      isDeleted: Value(isDeleted),
      timestamp: Value(timestamp),
      currentTimestamp: Value(currentTimestamp),
      lastSyncTime: lastSyncTime == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncTime),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      date: date == null && nullToAbsent ? const Value.absent() : Value(date),
      number:
          number == null && nullToAbsent ? const Value.absent() : Value(number),
      buyerId: buyerId == null && nullToAbsent
          ? const Value.absent()
          : Value(buyerId),
      needPickup: Value(needPickup),
      returnActTypeId: returnActTypeId == null && nullToAbsent
          ? const Value.absent()
          : Value(returnActTypeId),
      receptId: receptId == null && nullToAbsent
          ? const Value.absent()
          : Value(receptId),
      receptNdoc: receptNdoc == null && nullToAbsent
          ? const Value.absent()
          : Value(receptNdoc),
      receptDate: receptDate == null && nullToAbsent
          ? const Value.absent()
          : Value(receptDate),
    );
  }

  factory ReturnAct.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ReturnAct(
      guid: serializer.fromJson<String>(json['guid']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      currentTimestamp: serializer.fromJson<DateTime>(json['currentTimestamp']),
      lastSyncTime: serializer.fromJson<DateTime?>(json['lastSyncTime']),
      needSync: serializer.fromJson<bool>(json['needSync']),
      isNew: serializer.fromJson<bool>(json['isNew']),
      id: serializer.fromJson<int?>(json['id']),
      date: serializer.fromJson<DateTime?>(json['date']),
      number: serializer.fromJson<String?>(json['number']),
      buyerId: serializer.fromJson<int?>(json['buyerId']),
      needPickup: serializer.fromJson<bool>(json['needPickup']),
      returnActTypeId: serializer.fromJson<int?>(json['returnActTypeId']),
      receptId: serializer.fromJson<int?>(json['receptId']),
      receptNdoc: serializer.fromJson<String?>(json['receptNdoc']),
      receptDate: serializer.fromJson<DateTime?>(json['receptDate']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'guid': serializer.toJson<String>(guid),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'currentTimestamp': serializer.toJson<DateTime>(currentTimestamp),
      'lastSyncTime': serializer.toJson<DateTime?>(lastSyncTime),
      'needSync': serializer.toJson<bool>(needSync),
      'isNew': serializer.toJson<bool>(isNew),
      'id': serializer.toJson<int?>(id),
      'date': serializer.toJson<DateTime?>(date),
      'number': serializer.toJson<String?>(number),
      'buyerId': serializer.toJson<int?>(buyerId),
      'needPickup': serializer.toJson<bool>(needPickup),
      'returnActTypeId': serializer.toJson<int?>(returnActTypeId),
      'receptId': serializer.toJson<int?>(receptId),
      'receptNdoc': serializer.toJson<String?>(receptNdoc),
      'receptDate': serializer.toJson<DateTime?>(receptDate),
    };
  }

  ReturnAct copyWith(
          {String? guid,
          bool? isDeleted,
          DateTime? timestamp,
          DateTime? currentTimestamp,
          Value<DateTime?> lastSyncTime = const Value.absent(),
          bool? needSync,
          bool? isNew,
          Value<int?> id = const Value.absent(),
          Value<DateTime?> date = const Value.absent(),
          Value<String?> number = const Value.absent(),
          Value<int?> buyerId = const Value.absent(),
          bool? needPickup,
          Value<int?> returnActTypeId = const Value.absent(),
          Value<int?> receptId = const Value.absent(),
          Value<String?> receptNdoc = const Value.absent(),
          Value<DateTime?> receptDate = const Value.absent()}) =>
      ReturnAct(
        guid: guid ?? this.guid,
        isDeleted: isDeleted ?? this.isDeleted,
        timestamp: timestamp ?? this.timestamp,
        currentTimestamp: currentTimestamp ?? this.currentTimestamp,
        lastSyncTime:
            lastSyncTime.present ? lastSyncTime.value : this.lastSyncTime,
        needSync: needSync ?? this.needSync,
        isNew: isNew ?? this.isNew,
        id: id.present ? id.value : this.id,
        date: date.present ? date.value : this.date,
        number: number.present ? number.value : this.number,
        buyerId: buyerId.present ? buyerId.value : this.buyerId,
        needPickup: needPickup ?? this.needPickup,
        returnActTypeId: returnActTypeId.present
            ? returnActTypeId.value
            : this.returnActTypeId,
        receptId: receptId.present ? receptId.value : this.receptId,
        receptNdoc: receptNdoc.present ? receptNdoc.value : this.receptNdoc,
        receptDate: receptDate.present ? receptDate.value : this.receptDate,
      );
  @override
  String toString() {
    return (StringBuffer('ReturnAct(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('needSync: $needSync, ')
          ..write('isNew: $isNew, ')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('number: $number, ')
          ..write('buyerId: $buyerId, ')
          ..write('needPickup: $needPickup, ')
          ..write('returnActTypeId: $returnActTypeId, ')
          ..write('receptId: $receptId, ')
          ..write('receptNdoc: $receptNdoc, ')
          ..write('receptDate: $receptDate')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      guid,
      isDeleted,
      timestamp,
      currentTimestamp,
      lastSyncTime,
      needSync,
      isNew,
      id,
      date,
      number,
      buyerId,
      needPickup,
      returnActTypeId,
      receptId,
      receptNdoc,
      receptDate);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ReturnAct &&
          other.guid == this.guid &&
          other.isDeleted == this.isDeleted &&
          other.timestamp == this.timestamp &&
          other.currentTimestamp == this.currentTimestamp &&
          other.lastSyncTime == this.lastSyncTime &&
          other.needSync == this.needSync &&
          other.isNew == this.isNew &&
          other.id == this.id &&
          other.date == this.date &&
          other.number == this.number &&
          other.buyerId == this.buyerId &&
          other.needPickup == this.needPickup &&
          other.returnActTypeId == this.returnActTypeId &&
          other.receptId == this.receptId &&
          other.receptNdoc == this.receptNdoc &&
          other.receptDate == this.receptDate);
}

class ReturnActsCompanion extends UpdateCompanion<ReturnAct> {
  final Value<String> guid;
  final Value<bool> isDeleted;
  final Value<DateTime> timestamp;
  final Value<DateTime> currentTimestamp;
  final Value<DateTime?> lastSyncTime;
  final Value<int?> id;
  final Value<DateTime?> date;
  final Value<String?> number;
  final Value<int?> buyerId;
  final Value<bool> needPickup;
  final Value<int?> returnActTypeId;
  final Value<int?> receptId;
  final Value<String?> receptNdoc;
  final Value<DateTime?> receptDate;
  final Value<int> rowid;
  const ReturnActsCompanion({
    this.guid = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    this.date = const Value.absent(),
    this.number = const Value.absent(),
    this.buyerId = const Value.absent(),
    this.needPickup = const Value.absent(),
    this.returnActTypeId = const Value.absent(),
    this.receptId = const Value.absent(),
    this.receptNdoc = const Value.absent(),
    this.receptDate = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ReturnActsCompanion.insert({
    required String guid,
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    this.date = const Value.absent(),
    this.number = const Value.absent(),
    this.buyerId = const Value.absent(),
    required bool needPickup,
    this.returnActTypeId = const Value.absent(),
    this.receptId = const Value.absent(),
    this.receptNdoc = const Value.absent(),
    this.receptDate = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : guid = Value(guid),
        needPickup = Value(needPickup);
  static Insertable<ReturnAct> custom({
    Expression<String>? guid,
    Expression<bool>? isDeleted,
    Expression<DateTime>? timestamp,
    Expression<DateTime>? currentTimestamp,
    Expression<DateTime>? lastSyncTime,
    Expression<int>? id,
    Expression<DateTime>? date,
    Expression<String>? number,
    Expression<int>? buyerId,
    Expression<bool>? needPickup,
    Expression<int>? returnActTypeId,
    Expression<int>? receptId,
    Expression<String>? receptNdoc,
    Expression<DateTime>? receptDate,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (guid != null) 'guid': guid,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (timestamp != null) 'timestamp': timestamp,
      if (currentTimestamp != null) 'current_timestamp': currentTimestamp,
      if (lastSyncTime != null) 'last_sync_time': lastSyncTime,
      if (id != null) 'id': id,
      if (date != null) 'date': date,
      if (number != null) 'number': number,
      if (buyerId != null) 'buyer_id': buyerId,
      if (needPickup != null) 'need_pickup': needPickup,
      if (returnActTypeId != null) 'return_act_type_id': returnActTypeId,
      if (receptId != null) 'recept_id': receptId,
      if (receptNdoc != null) 'recept_ndoc': receptNdoc,
      if (receptDate != null) 'recept_date': receptDate,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ReturnActsCompanion copyWith(
      {Value<String>? guid,
      Value<bool>? isDeleted,
      Value<DateTime>? timestamp,
      Value<DateTime>? currentTimestamp,
      Value<DateTime?>? lastSyncTime,
      Value<int?>? id,
      Value<DateTime?>? date,
      Value<String?>? number,
      Value<int?>? buyerId,
      Value<bool>? needPickup,
      Value<int?>? returnActTypeId,
      Value<int?>? receptId,
      Value<String?>? receptNdoc,
      Value<DateTime?>? receptDate,
      Value<int>? rowid}) {
    return ReturnActsCompanion(
      guid: guid ?? this.guid,
      isDeleted: isDeleted ?? this.isDeleted,
      timestamp: timestamp ?? this.timestamp,
      currentTimestamp: currentTimestamp ?? this.currentTimestamp,
      lastSyncTime: lastSyncTime ?? this.lastSyncTime,
      id: id ?? this.id,
      date: date ?? this.date,
      number: number ?? this.number,
      buyerId: buyerId ?? this.buyerId,
      needPickup: needPickup ?? this.needPickup,
      returnActTypeId: returnActTypeId ?? this.returnActTypeId,
      receptId: receptId ?? this.receptId,
      receptNdoc: receptNdoc ?? this.receptNdoc,
      receptDate: receptDate ?? this.receptDate,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (guid.present) {
      map['guid'] = Variable<String>(guid.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (currentTimestamp.present) {
      map['current_timestamp'] = Variable<DateTime>(currentTimestamp.value);
    }
    if (lastSyncTime.present) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (number.present) {
      map['number'] = Variable<String>(number.value);
    }
    if (buyerId.present) {
      map['buyer_id'] = Variable<int>(buyerId.value);
    }
    if (needPickup.present) {
      map['need_pickup'] = Variable<bool>(needPickup.value);
    }
    if (returnActTypeId.present) {
      map['return_act_type_id'] = Variable<int>(returnActTypeId.value);
    }
    if (receptId.present) {
      map['recept_id'] = Variable<int>(receptId.value);
    }
    if (receptNdoc.present) {
      map['recept_ndoc'] = Variable<String>(receptNdoc.value);
    }
    if (receptDate.present) {
      map['recept_date'] = Variable<DateTime>(receptDate.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ReturnActsCompanion(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('number: $number, ')
          ..write('buyerId: $buyerId, ')
          ..write('needPickup: $needPickup, ')
          ..write('returnActTypeId: $returnActTypeId, ')
          ..write('receptId: $receptId, ')
          ..write('receptNdoc: $receptNdoc, ')
          ..write('receptDate: $receptDate, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ReturnActLinesTable extends ReturnActLines
    with TableInfo<$ReturnActLinesTable, ReturnActLine> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ReturnActLinesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _guidMeta = const VerificationMeta('guid');
  @override
  late final GeneratedColumn<String> guid = GeneratedColumn<String>(
      'guid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _timestampMeta =
      const VerificationMeta('timestamp');
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
      'timestamp', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _currentTimestampMeta =
      const VerificationMeta('currentTimestamp');
  @override
  late final GeneratedColumn<DateTime> currentTimestamp =
      GeneratedColumn<DateTime>('current_timestamp', aliasedName, false,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          defaultValue: currentDateAndTime);
  static const VerificationMeta _lastSyncTimeMeta =
      const VerificationMeta('lastSyncTime');
  @override
  late final GeneratedColumn<DateTime> lastSyncTime = GeneratedColumn<DateTime>(
      'last_sync_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _needSyncMeta =
      const VerificationMeta('needSync');
  @override
  late final GeneratedColumn<bool> needSync = GeneratedColumn<bool>(
      'need_sync', aliasedName, false,
      generatedAs: GeneratedAs(
          (isNew & BooleanExpressionOperators(isDeleted).not()) |
              (BooleanExpressionOperators(isNew).not() &
                  ComparableExpr(lastSyncTime).isSmallerThan(timestamp)),
          true),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("need_sync" IN (0, 1))'));
  static const VerificationMeta _isNewMeta = const VerificationMeta('isNew');
  @override
  late final GeneratedColumn<bool> isNew = GeneratedColumn<bool>(
      'is_new', aliasedName, false,
      generatedAs: GeneratedAs(lastSyncTime.isNull(), false),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_new" IN (0, 1))'));
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _returnActGuidMeta =
      const VerificationMeta('returnActGuid');
  @override
  late final GeneratedColumn<String> returnActGuid = GeneratedColumn<String>(
      'return_act_guid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES return_acts (guid) ON UPDATE CASCADE ON DELETE CASCADE'));
  static const VerificationMeta _goodsIdMeta =
      const VerificationMeta('goodsId');
  @override
  late final GeneratedColumn<int> goodsId = GeneratedColumn<int>(
      'goods_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _volMeta = const VerificationMeta('vol');
  @override
  late final GeneratedColumn<double> vol = GeneratedColumn<double>(
      'vol', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  @override
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
      'price', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _productionDateMeta =
      const VerificationMeta('productionDate');
  @override
  late final GeneratedColumn<DateTime> productionDate =
      GeneratedColumn<DateTime>('production_date', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _isBadMeta = const VerificationMeta('isBad');
  @override
  late final GeneratedColumn<bool> isBad = GeneratedColumn<bool>(
      'is_bad', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_bad" IN (0, 1))'));
  static const VerificationMeta _relMeta = const VerificationMeta('rel');
  @override
  late final GeneratedColumn<int> rel = GeneratedColumn<int>(
      'rel', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        guid,
        isDeleted,
        timestamp,
        currentTimestamp,
        lastSyncTime,
        needSync,
        isNew,
        id,
        returnActGuid,
        goodsId,
        vol,
        price,
        productionDate,
        isBad,
        rel
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'return_act_lines';
  @override
  VerificationContext validateIntegrity(Insertable<ReturnActLine> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('guid')) {
      context.handle(
          _guidMeta, guid.isAcceptableOrUnknown(data['guid']!, _guidMeta));
    } else if (isInserting) {
      context.missing(_guidMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('timestamp')) {
      context.handle(_timestampMeta,
          timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta));
    }
    if (data.containsKey('current_timestamp')) {
      context.handle(
          _currentTimestampMeta,
          currentTimestamp.isAcceptableOrUnknown(
              data['current_timestamp']!, _currentTimestampMeta));
    }
    if (data.containsKey('last_sync_time')) {
      context.handle(
          _lastSyncTimeMeta,
          lastSyncTime.isAcceptableOrUnknown(
              data['last_sync_time']!, _lastSyncTimeMeta));
    }
    if (data.containsKey('need_sync')) {
      context.handle(_needSyncMeta,
          needSync.isAcceptableOrUnknown(data['need_sync']!, _needSyncMeta));
    }
    if (data.containsKey('is_new')) {
      context.handle(
          _isNewMeta, isNew.isAcceptableOrUnknown(data['is_new']!, _isNewMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('return_act_guid')) {
      context.handle(
          _returnActGuidMeta,
          returnActGuid.isAcceptableOrUnknown(
              data['return_act_guid']!, _returnActGuidMeta));
    } else if (isInserting) {
      context.missing(_returnActGuidMeta);
    }
    if (data.containsKey('goods_id')) {
      context.handle(_goodsIdMeta,
          goodsId.isAcceptableOrUnknown(data['goods_id']!, _goodsIdMeta));
    } else if (isInserting) {
      context.missing(_goodsIdMeta);
    }
    if (data.containsKey('vol')) {
      context.handle(
          _volMeta, vol.isAcceptableOrUnknown(data['vol']!, _volMeta));
    } else if (isInserting) {
      context.missing(_volMeta);
    }
    if (data.containsKey('price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['price']!, _priceMeta));
    } else if (isInserting) {
      context.missing(_priceMeta);
    }
    if (data.containsKey('production_date')) {
      context.handle(
          _productionDateMeta,
          productionDate.isAcceptableOrUnknown(
              data['production_date']!, _productionDateMeta));
    }
    if (data.containsKey('is_bad')) {
      context.handle(
          _isBadMeta, isBad.isAcceptableOrUnknown(data['is_bad']!, _isBadMeta));
    }
    if (data.containsKey('rel')) {
      context.handle(
          _relMeta, rel.isAcceptableOrUnknown(data['rel']!, _relMeta));
    } else if (isInserting) {
      context.missing(_relMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {guid};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
        {returnActGuid, goodsId},
      ];
  @override
  ReturnActLine map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ReturnActLine(
      guid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}guid'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      timestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}timestamp'])!,
      currentTimestamp: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}current_timestamp'])!,
      lastSyncTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_sync_time']),
      needSync: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_sync'])!,
      isNew: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_new'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id']),
      returnActGuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}return_act_guid'])!,
      goodsId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}goods_id'])!,
      vol: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}vol'])!,
      price: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}price'])!,
      productionDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}production_date']),
      isBad: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_bad']),
      rel: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}rel'])!,
    );
  }

  @override
  $ReturnActLinesTable createAlias(String alias) {
    return $ReturnActLinesTable(attachedDatabase, alias);
  }
}

class ReturnActLine extends DataClass implements Insertable<ReturnActLine> {
  final String guid;
  final bool isDeleted;
  final DateTime timestamp;
  final DateTime currentTimestamp;
  final DateTime? lastSyncTime;
  final bool needSync;
  final bool isNew;
  final int? id;
  final String returnActGuid;
  final int goodsId;
  final double vol;
  final double price;
  final DateTime? productionDate;
  final bool? isBad;
  final int rel;
  const ReturnActLine(
      {required this.guid,
      required this.isDeleted,
      required this.timestamp,
      required this.currentTimestamp,
      this.lastSyncTime,
      required this.needSync,
      required this.isNew,
      this.id,
      required this.returnActGuid,
      required this.goodsId,
      required this.vol,
      required this.price,
      this.productionDate,
      this.isBad,
      required this.rel});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['guid'] = Variable<String>(guid);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['timestamp'] = Variable<DateTime>(timestamp);
    map['current_timestamp'] = Variable<DateTime>(currentTimestamp);
    if (!nullToAbsent || lastSyncTime != null) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    map['return_act_guid'] = Variable<String>(returnActGuid);
    map['goods_id'] = Variable<int>(goodsId);
    map['vol'] = Variable<double>(vol);
    map['price'] = Variable<double>(price);
    if (!nullToAbsent || productionDate != null) {
      map['production_date'] = Variable<DateTime>(productionDate);
    }
    if (!nullToAbsent || isBad != null) {
      map['is_bad'] = Variable<bool>(isBad);
    }
    map['rel'] = Variable<int>(rel);
    return map;
  }

  ReturnActLinesCompanion toCompanion(bool nullToAbsent) {
    return ReturnActLinesCompanion(
      guid: Value(guid),
      isDeleted: Value(isDeleted),
      timestamp: Value(timestamp),
      currentTimestamp: Value(currentTimestamp),
      lastSyncTime: lastSyncTime == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncTime),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      returnActGuid: Value(returnActGuid),
      goodsId: Value(goodsId),
      vol: Value(vol),
      price: Value(price),
      productionDate: productionDate == null && nullToAbsent
          ? const Value.absent()
          : Value(productionDate),
      isBad:
          isBad == null && nullToAbsent ? const Value.absent() : Value(isBad),
      rel: Value(rel),
    );
  }

  factory ReturnActLine.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ReturnActLine(
      guid: serializer.fromJson<String>(json['guid']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      currentTimestamp: serializer.fromJson<DateTime>(json['currentTimestamp']),
      lastSyncTime: serializer.fromJson<DateTime?>(json['lastSyncTime']),
      needSync: serializer.fromJson<bool>(json['needSync']),
      isNew: serializer.fromJson<bool>(json['isNew']),
      id: serializer.fromJson<int?>(json['id']),
      returnActGuid: serializer.fromJson<String>(json['returnActGuid']),
      goodsId: serializer.fromJson<int>(json['goodsId']),
      vol: serializer.fromJson<double>(json['vol']),
      price: serializer.fromJson<double>(json['price']),
      productionDate: serializer.fromJson<DateTime?>(json['productionDate']),
      isBad: serializer.fromJson<bool?>(json['isBad']),
      rel: serializer.fromJson<int>(json['rel']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'guid': serializer.toJson<String>(guid),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'currentTimestamp': serializer.toJson<DateTime>(currentTimestamp),
      'lastSyncTime': serializer.toJson<DateTime?>(lastSyncTime),
      'needSync': serializer.toJson<bool>(needSync),
      'isNew': serializer.toJson<bool>(isNew),
      'id': serializer.toJson<int?>(id),
      'returnActGuid': serializer.toJson<String>(returnActGuid),
      'goodsId': serializer.toJson<int>(goodsId),
      'vol': serializer.toJson<double>(vol),
      'price': serializer.toJson<double>(price),
      'productionDate': serializer.toJson<DateTime?>(productionDate),
      'isBad': serializer.toJson<bool?>(isBad),
      'rel': serializer.toJson<int>(rel),
    };
  }

  ReturnActLine copyWith(
          {String? guid,
          bool? isDeleted,
          DateTime? timestamp,
          DateTime? currentTimestamp,
          Value<DateTime?> lastSyncTime = const Value.absent(),
          bool? needSync,
          bool? isNew,
          Value<int?> id = const Value.absent(),
          String? returnActGuid,
          int? goodsId,
          double? vol,
          double? price,
          Value<DateTime?> productionDate = const Value.absent(),
          Value<bool?> isBad = const Value.absent(),
          int? rel}) =>
      ReturnActLine(
        guid: guid ?? this.guid,
        isDeleted: isDeleted ?? this.isDeleted,
        timestamp: timestamp ?? this.timestamp,
        currentTimestamp: currentTimestamp ?? this.currentTimestamp,
        lastSyncTime:
            lastSyncTime.present ? lastSyncTime.value : this.lastSyncTime,
        needSync: needSync ?? this.needSync,
        isNew: isNew ?? this.isNew,
        id: id.present ? id.value : this.id,
        returnActGuid: returnActGuid ?? this.returnActGuid,
        goodsId: goodsId ?? this.goodsId,
        vol: vol ?? this.vol,
        price: price ?? this.price,
        productionDate:
            productionDate.present ? productionDate.value : this.productionDate,
        isBad: isBad.present ? isBad.value : this.isBad,
        rel: rel ?? this.rel,
      );
  @override
  String toString() {
    return (StringBuffer('ReturnActLine(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('needSync: $needSync, ')
          ..write('isNew: $isNew, ')
          ..write('id: $id, ')
          ..write('returnActGuid: $returnActGuid, ')
          ..write('goodsId: $goodsId, ')
          ..write('vol: $vol, ')
          ..write('price: $price, ')
          ..write('productionDate: $productionDate, ')
          ..write('isBad: $isBad, ')
          ..write('rel: $rel')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      guid,
      isDeleted,
      timestamp,
      currentTimestamp,
      lastSyncTime,
      needSync,
      isNew,
      id,
      returnActGuid,
      goodsId,
      vol,
      price,
      productionDate,
      isBad,
      rel);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ReturnActLine &&
          other.guid == this.guid &&
          other.isDeleted == this.isDeleted &&
          other.timestamp == this.timestamp &&
          other.currentTimestamp == this.currentTimestamp &&
          other.lastSyncTime == this.lastSyncTime &&
          other.needSync == this.needSync &&
          other.isNew == this.isNew &&
          other.id == this.id &&
          other.returnActGuid == this.returnActGuid &&
          other.goodsId == this.goodsId &&
          other.vol == this.vol &&
          other.price == this.price &&
          other.productionDate == this.productionDate &&
          other.isBad == this.isBad &&
          other.rel == this.rel);
}

class ReturnActLinesCompanion extends UpdateCompanion<ReturnActLine> {
  final Value<String> guid;
  final Value<bool> isDeleted;
  final Value<DateTime> timestamp;
  final Value<DateTime> currentTimestamp;
  final Value<DateTime?> lastSyncTime;
  final Value<int?> id;
  final Value<String> returnActGuid;
  final Value<int> goodsId;
  final Value<double> vol;
  final Value<double> price;
  final Value<DateTime?> productionDate;
  final Value<bool?> isBad;
  final Value<int> rel;
  final Value<int> rowid;
  const ReturnActLinesCompanion({
    this.guid = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    this.returnActGuid = const Value.absent(),
    this.goodsId = const Value.absent(),
    this.vol = const Value.absent(),
    this.price = const Value.absent(),
    this.productionDate = const Value.absent(),
    this.isBad = const Value.absent(),
    this.rel = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ReturnActLinesCompanion.insert({
    required String guid,
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    required String returnActGuid,
    required int goodsId,
    required double vol,
    required double price,
    this.productionDate = const Value.absent(),
    this.isBad = const Value.absent(),
    required int rel,
    this.rowid = const Value.absent(),
  })  : guid = Value(guid),
        returnActGuid = Value(returnActGuid),
        goodsId = Value(goodsId),
        vol = Value(vol),
        price = Value(price),
        rel = Value(rel);
  static Insertable<ReturnActLine> custom({
    Expression<String>? guid,
    Expression<bool>? isDeleted,
    Expression<DateTime>? timestamp,
    Expression<DateTime>? currentTimestamp,
    Expression<DateTime>? lastSyncTime,
    Expression<int>? id,
    Expression<String>? returnActGuid,
    Expression<int>? goodsId,
    Expression<double>? vol,
    Expression<double>? price,
    Expression<DateTime>? productionDate,
    Expression<bool>? isBad,
    Expression<int>? rel,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (guid != null) 'guid': guid,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (timestamp != null) 'timestamp': timestamp,
      if (currentTimestamp != null) 'current_timestamp': currentTimestamp,
      if (lastSyncTime != null) 'last_sync_time': lastSyncTime,
      if (id != null) 'id': id,
      if (returnActGuid != null) 'return_act_guid': returnActGuid,
      if (goodsId != null) 'goods_id': goodsId,
      if (vol != null) 'vol': vol,
      if (price != null) 'price': price,
      if (productionDate != null) 'production_date': productionDate,
      if (isBad != null) 'is_bad': isBad,
      if (rel != null) 'rel': rel,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ReturnActLinesCompanion copyWith(
      {Value<String>? guid,
      Value<bool>? isDeleted,
      Value<DateTime>? timestamp,
      Value<DateTime>? currentTimestamp,
      Value<DateTime?>? lastSyncTime,
      Value<int?>? id,
      Value<String>? returnActGuid,
      Value<int>? goodsId,
      Value<double>? vol,
      Value<double>? price,
      Value<DateTime?>? productionDate,
      Value<bool?>? isBad,
      Value<int>? rel,
      Value<int>? rowid}) {
    return ReturnActLinesCompanion(
      guid: guid ?? this.guid,
      isDeleted: isDeleted ?? this.isDeleted,
      timestamp: timestamp ?? this.timestamp,
      currentTimestamp: currentTimestamp ?? this.currentTimestamp,
      lastSyncTime: lastSyncTime ?? this.lastSyncTime,
      id: id ?? this.id,
      returnActGuid: returnActGuid ?? this.returnActGuid,
      goodsId: goodsId ?? this.goodsId,
      vol: vol ?? this.vol,
      price: price ?? this.price,
      productionDate: productionDate ?? this.productionDate,
      isBad: isBad ?? this.isBad,
      rel: rel ?? this.rel,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (guid.present) {
      map['guid'] = Variable<String>(guid.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (currentTimestamp.present) {
      map['current_timestamp'] = Variable<DateTime>(currentTimestamp.value);
    }
    if (lastSyncTime.present) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (returnActGuid.present) {
      map['return_act_guid'] = Variable<String>(returnActGuid.value);
    }
    if (goodsId.present) {
      map['goods_id'] = Variable<int>(goodsId.value);
    }
    if (vol.present) {
      map['vol'] = Variable<double>(vol.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (productionDate.present) {
      map['production_date'] = Variable<DateTime>(productionDate.value);
    }
    if (isBad.present) {
      map['is_bad'] = Variable<bool>(isBad.value);
    }
    if (rel.present) {
      map['rel'] = Variable<int>(rel.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ReturnActLinesCompanion(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('id: $id, ')
          ..write('returnActGuid: $returnActGuid, ')
          ..write('goodsId: $goodsId, ')
          ..write('vol: $vol, ')
          ..write('price: $price, ')
          ..write('productionDate: $productionDate, ')
          ..write('isBad: $isBad, ')
          ..write('rel: $rel, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ReturnActTypesTable extends ReturnActTypes
    with TableInfo<$ReturnActTypesTable, ReturnActType> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ReturnActTypesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [id, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'return_act_types';
  @override
  VerificationContext validateIntegrity(Insertable<ReturnActType> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ReturnActType map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ReturnActType(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $ReturnActTypesTable createAlias(String alias) {
    return $ReturnActTypesTable(attachedDatabase, alias);
  }
}

class ReturnActType extends DataClass implements Insertable<ReturnActType> {
  final int id;
  final String name;
  const ReturnActType({required this.id, required this.name});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    return map;
  }

  ReturnActTypesCompanion toCompanion(bool nullToAbsent) {
    return ReturnActTypesCompanion(
      id: Value(id),
      name: Value(name),
    );
  }

  factory ReturnActType.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ReturnActType(
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
    };
  }

  ReturnActType copyWith({int? id, String? name}) => ReturnActType(
        id: id ?? this.id,
        name: name ?? this.name,
      );
  ReturnActType copyWithCompanion(ReturnActTypesCompanion data) {
    return ReturnActType(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ReturnActType(')
          ..write('id: $id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ReturnActType &&
          other.id == this.id &&
          other.name == this.name);
}

class ReturnActTypesCompanion extends UpdateCompanion<ReturnActType> {
  final Value<int> id;
  final Value<String> name;
  const ReturnActTypesCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
  });
  ReturnActTypesCompanion.insert({
    this.id = const Value.absent(),
    required String name,
  }) : name = Value(name);
  static Insertable<ReturnActType> custom({
    Expression<int>? id,
    Expression<String>? name,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
    });
  }

  ReturnActTypesCompanion copyWith({Value<int>? id, Value<String>? name}) {
    return ReturnActTypesCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ReturnActTypesCompanion(')
          ..write('id: $id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class $PartnersReturnActTypesTable extends PartnersReturnActTypes
    with TableInfo<$PartnersReturnActTypesTable, PartnersReturnActType> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PartnersReturnActTypesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _returnActTypeIdMeta =
      const VerificationMeta('returnActTypeId');
  @override
  late final GeneratedColumn<int> returnActTypeId = GeneratedColumn<int>(
      'return_act_type_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _partnerIdMeta =
      const VerificationMeta('partnerId');
  @override
  late final GeneratedColumn<int> partnerId = GeneratedColumn<int>(
      'partner_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [returnActTypeId, partnerId];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'partners_return_act_types';
  @override
  VerificationContext validateIntegrity(
      Insertable<PartnersReturnActType> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('return_act_type_id')) {
      context.handle(
          _returnActTypeIdMeta,
          returnActTypeId.isAcceptableOrUnknown(
              data['return_act_type_id']!, _returnActTypeIdMeta));
    } else if (isInserting) {
      context.missing(_returnActTypeIdMeta);
    }
    if (data.containsKey('partner_id')) {
      context.handle(_partnerIdMeta,
          partnerId.isAcceptableOrUnknown(data['partner_id']!, _partnerIdMeta));
    } else if (isInserting) {
      context.missing(_partnerIdMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {returnActTypeId, partnerId};
  @override
  PartnersReturnActType map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PartnersReturnActType(
      returnActTypeId: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}return_act_type_id'])!,
      partnerId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}partner_id'])!,
    );
  }

  @override
  $PartnersReturnActTypesTable createAlias(String alias) {
    return $PartnersReturnActTypesTable(attachedDatabase, alias);
  }
}

class PartnersReturnActType extends DataClass
    implements Insertable<PartnersReturnActType> {
  final int returnActTypeId;
  final int partnerId;
  const PartnersReturnActType(
      {required this.returnActTypeId, required this.partnerId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['return_act_type_id'] = Variable<int>(returnActTypeId);
    map['partner_id'] = Variable<int>(partnerId);
    return map;
  }

  PartnersReturnActTypesCompanion toCompanion(bool nullToAbsent) {
    return PartnersReturnActTypesCompanion(
      returnActTypeId: Value(returnActTypeId),
      partnerId: Value(partnerId),
    );
  }

  factory PartnersReturnActType.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PartnersReturnActType(
      returnActTypeId: serializer.fromJson<int>(json['returnActTypeId']),
      partnerId: serializer.fromJson<int>(json['partnerId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'returnActTypeId': serializer.toJson<int>(returnActTypeId),
      'partnerId': serializer.toJson<int>(partnerId),
    };
  }

  PartnersReturnActType copyWith({int? returnActTypeId, int? partnerId}) =>
      PartnersReturnActType(
        returnActTypeId: returnActTypeId ?? this.returnActTypeId,
        partnerId: partnerId ?? this.partnerId,
      );
  PartnersReturnActType copyWithCompanion(
      PartnersReturnActTypesCompanion data) {
    return PartnersReturnActType(
      returnActTypeId: data.returnActTypeId.present
          ? data.returnActTypeId.value
          : this.returnActTypeId,
      partnerId: data.partnerId.present ? data.partnerId.value : this.partnerId,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PartnersReturnActType(')
          ..write('returnActTypeId: $returnActTypeId, ')
          ..write('partnerId: $partnerId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(returnActTypeId, partnerId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PartnersReturnActType &&
          other.returnActTypeId == this.returnActTypeId &&
          other.partnerId == this.partnerId);
}

class PartnersReturnActTypesCompanion
    extends UpdateCompanion<PartnersReturnActType> {
  final Value<int> returnActTypeId;
  final Value<int> partnerId;
  final Value<int> rowid;
  const PartnersReturnActTypesCompanion({
    this.returnActTypeId = const Value.absent(),
    this.partnerId = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PartnersReturnActTypesCompanion.insert({
    required int returnActTypeId,
    required int partnerId,
    this.rowid = const Value.absent(),
  })  : returnActTypeId = Value(returnActTypeId),
        partnerId = Value(partnerId);
  static Insertable<PartnersReturnActType> custom({
    Expression<int>? returnActTypeId,
    Expression<int>? partnerId,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (returnActTypeId != null) 'return_act_type_id': returnActTypeId,
      if (partnerId != null) 'partner_id': partnerId,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PartnersReturnActTypesCompanion copyWith(
      {Value<int>? returnActTypeId, Value<int>? partnerId, Value<int>? rowid}) {
    return PartnersReturnActTypesCompanion(
      returnActTypeId: returnActTypeId ?? this.returnActTypeId,
      partnerId: partnerId ?? this.partnerId,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (returnActTypeId.present) {
      map['return_act_type_id'] = Variable<int>(returnActTypeId.value);
    }
    if (partnerId.present) {
      map['partner_id'] = Variable<int>(partnerId.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PartnersReturnActTypesCompanion(')
          ..write('returnActTypeId: $returnActTypeId, ')
          ..write('partnerId: $partnerId, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $RoutePointsTable extends RoutePoints
    with TableInfo<$RoutePointsTable, RoutePoint> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RoutePointsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
      'date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _buyerIdMeta =
      const VerificationMeta('buyerId');
  @override
  late final GeneratedColumn<int> buyerId = GeneratedColumn<int>(
      'buyer_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _visitedMeta =
      const VerificationMeta('visited');
  @override
  late final GeneratedColumn<bool> visited = GeneratedColumn<bool>(
      'visited', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("visited" IN (0, 1))'));
  @override
  List<GeneratedColumn> get $columns => [id, date, buyerId, visited];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'route_points';
  @override
  VerificationContext validateIntegrity(Insertable<RoutePoint> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('date')) {
      context.handle(
          _dateMeta, date.isAcceptableOrUnknown(data['date']!, _dateMeta));
    } else if (isInserting) {
      context.missing(_dateMeta);
    }
    if (data.containsKey('buyer_id')) {
      context.handle(_buyerIdMeta,
          buyerId.isAcceptableOrUnknown(data['buyer_id']!, _buyerIdMeta));
    } else if (isInserting) {
      context.missing(_buyerIdMeta);
    }
    if (data.containsKey('visited')) {
      context.handle(_visitedMeta,
          visited.isAcceptableOrUnknown(data['visited']!, _visitedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  RoutePoint map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RoutePoint(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      date: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}date'])!,
      buyerId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}buyer_id'])!,
      visited: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}visited']),
    );
  }

  @override
  $RoutePointsTable createAlias(String alias) {
    return $RoutePointsTable(attachedDatabase, alias);
  }
}

class RoutePoint extends DataClass implements Insertable<RoutePoint> {
  final int id;
  final DateTime date;
  final int buyerId;
  final bool? visited;
  const RoutePoint(
      {required this.id,
      required this.date,
      required this.buyerId,
      this.visited});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['date'] = Variable<DateTime>(date);
    map['buyer_id'] = Variable<int>(buyerId);
    if (!nullToAbsent || visited != null) {
      map['visited'] = Variable<bool>(visited);
    }
    return map;
  }

  RoutePointsCompanion toCompanion(bool nullToAbsent) {
    return RoutePointsCompanion(
      id: Value(id),
      date: Value(date),
      buyerId: Value(buyerId),
      visited: visited == null && nullToAbsent
          ? const Value.absent()
          : Value(visited),
    );
  }

  factory RoutePoint.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RoutePoint(
      id: serializer.fromJson<int>(json['id']),
      date: serializer.fromJson<DateTime>(json['date']),
      buyerId: serializer.fromJson<int>(json['buyerId']),
      visited: serializer.fromJson<bool?>(json['visited']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'date': serializer.toJson<DateTime>(date),
      'buyerId': serializer.toJson<int>(buyerId),
      'visited': serializer.toJson<bool?>(visited),
    };
  }

  RoutePoint copyWith(
          {int? id,
          DateTime? date,
          int? buyerId,
          Value<bool?> visited = const Value.absent()}) =>
      RoutePoint(
        id: id ?? this.id,
        date: date ?? this.date,
        buyerId: buyerId ?? this.buyerId,
        visited: visited.present ? visited.value : this.visited,
      );
  RoutePoint copyWithCompanion(RoutePointsCompanion data) {
    return RoutePoint(
      id: data.id.present ? data.id.value : this.id,
      date: data.date.present ? data.date.value : this.date,
      buyerId: data.buyerId.present ? data.buyerId.value : this.buyerId,
      visited: data.visited.present ? data.visited.value : this.visited,
    );
  }

  @override
  String toString() {
    return (StringBuffer('RoutePoint(')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('buyerId: $buyerId, ')
          ..write('visited: $visited')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, date, buyerId, visited);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RoutePoint &&
          other.id == this.id &&
          other.date == this.date &&
          other.buyerId == this.buyerId &&
          other.visited == this.visited);
}

class RoutePointsCompanion extends UpdateCompanion<RoutePoint> {
  final Value<int> id;
  final Value<DateTime> date;
  final Value<int> buyerId;
  final Value<bool?> visited;
  const RoutePointsCompanion({
    this.id = const Value.absent(),
    this.date = const Value.absent(),
    this.buyerId = const Value.absent(),
    this.visited = const Value.absent(),
  });
  RoutePointsCompanion.insert({
    this.id = const Value.absent(),
    required DateTime date,
    required int buyerId,
    this.visited = const Value.absent(),
  })  : date = Value(date),
        buyerId = Value(buyerId);
  static Insertable<RoutePoint> custom({
    Expression<int>? id,
    Expression<DateTime>? date,
    Expression<int>? buyerId,
    Expression<bool>? visited,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (date != null) 'date': date,
      if (buyerId != null) 'buyer_id': buyerId,
      if (visited != null) 'visited': visited,
    });
  }

  RoutePointsCompanion copyWith(
      {Value<int>? id,
      Value<DateTime>? date,
      Value<int>? buyerId,
      Value<bool?>? visited}) {
    return RoutePointsCompanion(
      id: id ?? this.id,
      date: date ?? this.date,
      buyerId: buyerId ?? this.buyerId,
      visited: visited ?? this.visited,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (buyerId.present) {
      map['buyer_id'] = Variable<int>(buyerId.value);
    }
    if (visited.present) {
      map['visited'] = Variable<bool>(visited.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RoutePointsCompanion(')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('buyerId: $buyerId, ')
          ..write('visited: $visited')
          ..write(')'))
        .toString();
  }
}

class $VisitSkipReasonsTable extends VisitSkipReasons
    with TableInfo<$VisitSkipReasonsTable, VisitSkipReason> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $VisitSkipReasonsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [id, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'visit_skip_reasons';
  @override
  VerificationContext validateIntegrity(Insertable<VisitSkipReason> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  VisitSkipReason map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return VisitSkipReason(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $VisitSkipReasonsTable createAlias(String alias) {
    return $VisitSkipReasonsTable(attachedDatabase, alias);
  }
}

class VisitSkipReason extends DataClass implements Insertable<VisitSkipReason> {
  final int id;
  final String name;
  const VisitSkipReason({required this.id, required this.name});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    return map;
  }

  VisitSkipReasonsCompanion toCompanion(bool nullToAbsent) {
    return VisitSkipReasonsCompanion(
      id: Value(id),
      name: Value(name),
    );
  }

  factory VisitSkipReason.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return VisitSkipReason(
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
    };
  }

  VisitSkipReason copyWith({int? id, String? name}) => VisitSkipReason(
        id: id ?? this.id,
        name: name ?? this.name,
      );
  VisitSkipReason copyWithCompanion(VisitSkipReasonsCompanion data) {
    return VisitSkipReason(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
    );
  }

  @override
  String toString() {
    return (StringBuffer('VisitSkipReason(')
          ..write('id: $id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is VisitSkipReason &&
          other.id == this.id &&
          other.name == this.name);
}

class VisitSkipReasonsCompanion extends UpdateCompanion<VisitSkipReason> {
  final Value<int> id;
  final Value<String> name;
  const VisitSkipReasonsCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
  });
  VisitSkipReasonsCompanion.insert({
    this.id = const Value.absent(),
    required String name,
  }) : name = Value(name);
  static Insertable<VisitSkipReason> custom({
    Expression<int>? id,
    Expression<String>? name,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
    });
  }

  VisitSkipReasonsCompanion copyWith({Value<int>? id, Value<String>? name}) {
    return VisitSkipReasonsCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('VisitSkipReasonsCompanion(')
          ..write('id: $id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class $VisitsTable extends Visits with TableInfo<$VisitsTable, Visit> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $VisitsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _guidMeta = const VerificationMeta('guid');
  @override
  late final GeneratedColumn<String> guid = GeneratedColumn<String>(
      'guid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _timestampMeta =
      const VerificationMeta('timestamp');
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
      'timestamp', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _currentTimestampMeta =
      const VerificationMeta('currentTimestamp');
  @override
  late final GeneratedColumn<DateTime> currentTimestamp =
      GeneratedColumn<DateTime>('current_timestamp', aliasedName, false,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          defaultValue: currentDateAndTime);
  static const VerificationMeta _lastSyncTimeMeta =
      const VerificationMeta('lastSyncTime');
  @override
  late final GeneratedColumn<DateTime> lastSyncTime = GeneratedColumn<DateTime>(
      'last_sync_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _needSyncMeta =
      const VerificationMeta('needSync');
  @override
  late final GeneratedColumn<bool> needSync = GeneratedColumn<bool>(
      'need_sync', aliasedName, false,
      generatedAs: GeneratedAs(
          (isNew & BooleanExpressionOperators(isDeleted).not()) |
              (BooleanExpressionOperators(isNew).not() &
                  ComparableExpr(lastSyncTime).isSmallerThan(timestamp)),
          true),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("need_sync" IN (0, 1))'));
  static const VerificationMeta _isNewMeta = const VerificationMeta('isNew');
  @override
  late final GeneratedColumn<bool> isNew = GeneratedColumn<bool>(
      'is_new', aliasedName, false,
      generatedAs: GeneratedAs(lastSyncTime.isNull(), false),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_new" IN (0, 1))'));
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
      'date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _buyerIdMeta =
      const VerificationMeta('buyerId');
  @override
  late final GeneratedColumn<int> buyerId = GeneratedColumn<int>(
      'buyer_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _routePointIdMeta =
      const VerificationMeta('routePointId');
  @override
  late final GeneratedColumn<int> routePointId = GeneratedColumn<int>(
      'route_point_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _visitSkipReasonIdMeta =
      const VerificationMeta('visitSkipReasonId');
  @override
  late final GeneratedColumn<int> visitSkipReasonId = GeneratedColumn<int>(
      'visit_skip_reason_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _needCheckGLMeta =
      const VerificationMeta('needCheckGL');
  @override
  late final GeneratedColumn<bool> needCheckGL = GeneratedColumn<bool>(
      'need_check_g_l', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("need_check_g_l" IN (0, 1))'));
  static const VerificationMeta _needTakePhotosMeta =
      const VerificationMeta('needTakePhotos');
  @override
  late final GeneratedColumn<bool> needTakePhotos = GeneratedColumn<bool>(
      'need_take_photos', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("need_take_photos" IN (0, 1))'));
  static const VerificationMeta _needFillSoftwareMeta =
      const VerificationMeta('needFillSoftware');
  @override
  late final GeneratedColumn<bool> needFillSoftware = GeneratedColumn<bool>(
      'need_fill_software', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("need_fill_software" IN (0, 1))'));
  static const VerificationMeta _needDetailsMeta =
      const VerificationMeta('needDetails');
  @override
  late final GeneratedColumn<bool> needDetails = GeneratedColumn<bool>(
      'need_details', aliasedName, false,
      generatedAs:
          GeneratedAs(needCheckGL | needTakePhotos | needFillSoftware, false),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("need_details" IN (0, 1))'));
  static const VerificationMeta _visitedMeta =
      const VerificationMeta('visited');
  @override
  late final GeneratedColumn<bool> visited = GeneratedColumn<bool>(
      'visited', aliasedName, false,
      generatedAs: GeneratedAs(visitSkipReasonId.isNull(), false),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("visited" IN (0, 1))'));
  @override
  List<GeneratedColumn> get $columns => [
        guid,
        isDeleted,
        timestamp,
        currentTimestamp,
        lastSyncTime,
        needSync,
        isNew,
        id,
        date,
        buyerId,
        routePointId,
        visitSkipReasonId,
        needCheckGL,
        needTakePhotos,
        needFillSoftware,
        needDetails,
        visited
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'visits';
  @override
  VerificationContext validateIntegrity(Insertable<Visit> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('guid')) {
      context.handle(
          _guidMeta, guid.isAcceptableOrUnknown(data['guid']!, _guidMeta));
    } else if (isInserting) {
      context.missing(_guidMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('timestamp')) {
      context.handle(_timestampMeta,
          timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta));
    }
    if (data.containsKey('current_timestamp')) {
      context.handle(
          _currentTimestampMeta,
          currentTimestamp.isAcceptableOrUnknown(
              data['current_timestamp']!, _currentTimestampMeta));
    }
    if (data.containsKey('last_sync_time')) {
      context.handle(
          _lastSyncTimeMeta,
          lastSyncTime.isAcceptableOrUnknown(
              data['last_sync_time']!, _lastSyncTimeMeta));
    }
    if (data.containsKey('need_sync')) {
      context.handle(_needSyncMeta,
          needSync.isAcceptableOrUnknown(data['need_sync']!, _needSyncMeta));
    }
    if (data.containsKey('is_new')) {
      context.handle(
          _isNewMeta, isNew.isAcceptableOrUnknown(data['is_new']!, _isNewMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('date')) {
      context.handle(
          _dateMeta, date.isAcceptableOrUnknown(data['date']!, _dateMeta));
    } else if (isInserting) {
      context.missing(_dateMeta);
    }
    if (data.containsKey('buyer_id')) {
      context.handle(_buyerIdMeta,
          buyerId.isAcceptableOrUnknown(data['buyer_id']!, _buyerIdMeta));
    } else if (isInserting) {
      context.missing(_buyerIdMeta);
    }
    if (data.containsKey('route_point_id')) {
      context.handle(
          _routePointIdMeta,
          routePointId.isAcceptableOrUnknown(
              data['route_point_id']!, _routePointIdMeta));
    }
    if (data.containsKey('visit_skip_reason_id')) {
      context.handle(
          _visitSkipReasonIdMeta,
          visitSkipReasonId.isAcceptableOrUnknown(
              data['visit_skip_reason_id']!, _visitSkipReasonIdMeta));
    }
    if (data.containsKey('need_check_g_l')) {
      context.handle(
          _needCheckGLMeta,
          needCheckGL.isAcceptableOrUnknown(
              data['need_check_g_l']!, _needCheckGLMeta));
    } else if (isInserting) {
      context.missing(_needCheckGLMeta);
    }
    if (data.containsKey('need_take_photos')) {
      context.handle(
          _needTakePhotosMeta,
          needTakePhotos.isAcceptableOrUnknown(
              data['need_take_photos']!, _needTakePhotosMeta));
    } else if (isInserting) {
      context.missing(_needTakePhotosMeta);
    }
    if (data.containsKey('need_fill_software')) {
      context.handle(
          _needFillSoftwareMeta,
          needFillSoftware.isAcceptableOrUnknown(
              data['need_fill_software']!, _needFillSoftwareMeta));
    } else if (isInserting) {
      context.missing(_needFillSoftwareMeta);
    }
    if (data.containsKey('need_details')) {
      context.handle(
          _needDetailsMeta,
          needDetails.isAcceptableOrUnknown(
              data['need_details']!, _needDetailsMeta));
    }
    if (data.containsKey('visited')) {
      context.handle(_visitedMeta,
          visited.isAcceptableOrUnknown(data['visited']!, _visitedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {guid};
  @override
  Visit map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Visit(
      guid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}guid'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      timestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}timestamp'])!,
      currentTimestamp: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}current_timestamp'])!,
      lastSyncTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_sync_time']),
      needSync: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_sync'])!,
      isNew: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_new'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id']),
      date: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}date'])!,
      buyerId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}buyer_id'])!,
      routePointId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}route_point_id']),
      visitSkipReasonId: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}visit_skip_reason_id']),
      needCheckGL: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_check_g_l'])!,
      needTakePhotos: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_take_photos'])!,
      needFillSoftware: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}need_fill_software'])!,
      needDetails: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_details'])!,
      visited: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}visited'])!,
    );
  }

  @override
  $VisitsTable createAlias(String alias) {
    return $VisitsTable(attachedDatabase, alias);
  }
}

class Visit extends DataClass implements Insertable<Visit> {
  final String guid;
  final bool isDeleted;
  final DateTime timestamp;
  final DateTime currentTimestamp;
  final DateTime? lastSyncTime;
  final bool needSync;
  final bool isNew;
  final int? id;
  final DateTime date;
  final int buyerId;
  final int? routePointId;
  final int? visitSkipReasonId;
  final bool needCheckGL;
  final bool needTakePhotos;
  final bool needFillSoftware;
  final bool needDetails;
  final bool visited;
  const Visit(
      {required this.guid,
      required this.isDeleted,
      required this.timestamp,
      required this.currentTimestamp,
      this.lastSyncTime,
      required this.needSync,
      required this.isNew,
      this.id,
      required this.date,
      required this.buyerId,
      this.routePointId,
      this.visitSkipReasonId,
      required this.needCheckGL,
      required this.needTakePhotos,
      required this.needFillSoftware,
      required this.needDetails,
      required this.visited});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['guid'] = Variable<String>(guid);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['timestamp'] = Variable<DateTime>(timestamp);
    map['current_timestamp'] = Variable<DateTime>(currentTimestamp);
    if (!nullToAbsent || lastSyncTime != null) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    map['date'] = Variable<DateTime>(date);
    map['buyer_id'] = Variable<int>(buyerId);
    if (!nullToAbsent || routePointId != null) {
      map['route_point_id'] = Variable<int>(routePointId);
    }
    if (!nullToAbsent || visitSkipReasonId != null) {
      map['visit_skip_reason_id'] = Variable<int>(visitSkipReasonId);
    }
    map['need_check_g_l'] = Variable<bool>(needCheckGL);
    map['need_take_photos'] = Variable<bool>(needTakePhotos);
    map['need_fill_software'] = Variable<bool>(needFillSoftware);
    return map;
  }

  VisitsCompanion toCompanion(bool nullToAbsent) {
    return VisitsCompanion(
      guid: Value(guid),
      isDeleted: Value(isDeleted),
      timestamp: Value(timestamp),
      currentTimestamp: Value(currentTimestamp),
      lastSyncTime: lastSyncTime == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncTime),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      date: Value(date),
      buyerId: Value(buyerId),
      routePointId: routePointId == null && nullToAbsent
          ? const Value.absent()
          : Value(routePointId),
      visitSkipReasonId: visitSkipReasonId == null && nullToAbsent
          ? const Value.absent()
          : Value(visitSkipReasonId),
      needCheckGL: Value(needCheckGL),
      needTakePhotos: Value(needTakePhotos),
      needFillSoftware: Value(needFillSoftware),
    );
  }

  factory Visit.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Visit(
      guid: serializer.fromJson<String>(json['guid']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      currentTimestamp: serializer.fromJson<DateTime>(json['currentTimestamp']),
      lastSyncTime: serializer.fromJson<DateTime?>(json['lastSyncTime']),
      needSync: serializer.fromJson<bool>(json['needSync']),
      isNew: serializer.fromJson<bool>(json['isNew']),
      id: serializer.fromJson<int?>(json['id']),
      date: serializer.fromJson<DateTime>(json['date']),
      buyerId: serializer.fromJson<int>(json['buyerId']),
      routePointId: serializer.fromJson<int?>(json['routePointId']),
      visitSkipReasonId: serializer.fromJson<int?>(json['visitSkipReasonId']),
      needCheckGL: serializer.fromJson<bool>(json['needCheckGL']),
      needTakePhotos: serializer.fromJson<bool>(json['needTakePhotos']),
      needFillSoftware: serializer.fromJson<bool>(json['needFillSoftware']),
      needDetails: serializer.fromJson<bool>(json['needDetails']),
      visited: serializer.fromJson<bool>(json['visited']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'guid': serializer.toJson<String>(guid),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'currentTimestamp': serializer.toJson<DateTime>(currentTimestamp),
      'lastSyncTime': serializer.toJson<DateTime?>(lastSyncTime),
      'needSync': serializer.toJson<bool>(needSync),
      'isNew': serializer.toJson<bool>(isNew),
      'id': serializer.toJson<int?>(id),
      'date': serializer.toJson<DateTime>(date),
      'buyerId': serializer.toJson<int>(buyerId),
      'routePointId': serializer.toJson<int?>(routePointId),
      'visitSkipReasonId': serializer.toJson<int?>(visitSkipReasonId),
      'needCheckGL': serializer.toJson<bool>(needCheckGL),
      'needTakePhotos': serializer.toJson<bool>(needTakePhotos),
      'needFillSoftware': serializer.toJson<bool>(needFillSoftware),
      'needDetails': serializer.toJson<bool>(needDetails),
      'visited': serializer.toJson<bool>(visited),
    };
  }

  Visit copyWith(
          {String? guid,
          bool? isDeleted,
          DateTime? timestamp,
          DateTime? currentTimestamp,
          Value<DateTime?> lastSyncTime = const Value.absent(),
          bool? needSync,
          bool? isNew,
          Value<int?> id = const Value.absent(),
          DateTime? date,
          int? buyerId,
          Value<int?> routePointId = const Value.absent(),
          Value<int?> visitSkipReasonId = const Value.absent(),
          bool? needCheckGL,
          bool? needTakePhotos,
          bool? needFillSoftware,
          bool? needDetails,
          bool? visited}) =>
      Visit(
        guid: guid ?? this.guid,
        isDeleted: isDeleted ?? this.isDeleted,
        timestamp: timestamp ?? this.timestamp,
        currentTimestamp: currentTimestamp ?? this.currentTimestamp,
        lastSyncTime:
            lastSyncTime.present ? lastSyncTime.value : this.lastSyncTime,
        needSync: needSync ?? this.needSync,
        isNew: isNew ?? this.isNew,
        id: id.present ? id.value : this.id,
        date: date ?? this.date,
        buyerId: buyerId ?? this.buyerId,
        routePointId:
            routePointId.present ? routePointId.value : this.routePointId,
        visitSkipReasonId: visitSkipReasonId.present
            ? visitSkipReasonId.value
            : this.visitSkipReasonId,
        needCheckGL: needCheckGL ?? this.needCheckGL,
        needTakePhotos: needTakePhotos ?? this.needTakePhotos,
        needFillSoftware: needFillSoftware ?? this.needFillSoftware,
        needDetails: needDetails ?? this.needDetails,
        visited: visited ?? this.visited,
      );
  @override
  String toString() {
    return (StringBuffer('Visit(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('needSync: $needSync, ')
          ..write('isNew: $isNew, ')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('buyerId: $buyerId, ')
          ..write('routePointId: $routePointId, ')
          ..write('visitSkipReasonId: $visitSkipReasonId, ')
          ..write('needCheckGL: $needCheckGL, ')
          ..write('needTakePhotos: $needTakePhotos, ')
          ..write('needFillSoftware: $needFillSoftware, ')
          ..write('needDetails: $needDetails, ')
          ..write('visited: $visited')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      guid,
      isDeleted,
      timestamp,
      currentTimestamp,
      lastSyncTime,
      needSync,
      isNew,
      id,
      date,
      buyerId,
      routePointId,
      visitSkipReasonId,
      needCheckGL,
      needTakePhotos,
      needFillSoftware,
      needDetails,
      visited);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Visit &&
          other.guid == this.guid &&
          other.isDeleted == this.isDeleted &&
          other.timestamp == this.timestamp &&
          other.currentTimestamp == this.currentTimestamp &&
          other.lastSyncTime == this.lastSyncTime &&
          other.needSync == this.needSync &&
          other.isNew == this.isNew &&
          other.id == this.id &&
          other.date == this.date &&
          other.buyerId == this.buyerId &&
          other.routePointId == this.routePointId &&
          other.visitSkipReasonId == this.visitSkipReasonId &&
          other.needCheckGL == this.needCheckGL &&
          other.needTakePhotos == this.needTakePhotos &&
          other.needFillSoftware == this.needFillSoftware &&
          other.needDetails == this.needDetails &&
          other.visited == this.visited);
}

class VisitsCompanion extends UpdateCompanion<Visit> {
  final Value<String> guid;
  final Value<bool> isDeleted;
  final Value<DateTime> timestamp;
  final Value<DateTime> currentTimestamp;
  final Value<DateTime?> lastSyncTime;
  final Value<int?> id;
  final Value<DateTime> date;
  final Value<int> buyerId;
  final Value<int?> routePointId;
  final Value<int?> visitSkipReasonId;
  final Value<bool> needCheckGL;
  final Value<bool> needTakePhotos;
  final Value<bool> needFillSoftware;
  final Value<int> rowid;
  const VisitsCompanion({
    this.guid = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    this.date = const Value.absent(),
    this.buyerId = const Value.absent(),
    this.routePointId = const Value.absent(),
    this.visitSkipReasonId = const Value.absent(),
    this.needCheckGL = const Value.absent(),
    this.needTakePhotos = const Value.absent(),
    this.needFillSoftware = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  VisitsCompanion.insert({
    required String guid,
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    required DateTime date,
    required int buyerId,
    this.routePointId = const Value.absent(),
    this.visitSkipReasonId = const Value.absent(),
    required bool needCheckGL,
    required bool needTakePhotos,
    required bool needFillSoftware,
    this.rowid = const Value.absent(),
  })  : guid = Value(guid),
        date = Value(date),
        buyerId = Value(buyerId),
        needCheckGL = Value(needCheckGL),
        needTakePhotos = Value(needTakePhotos),
        needFillSoftware = Value(needFillSoftware);
  static Insertable<Visit> custom({
    Expression<String>? guid,
    Expression<bool>? isDeleted,
    Expression<DateTime>? timestamp,
    Expression<DateTime>? currentTimestamp,
    Expression<DateTime>? lastSyncTime,
    Expression<int>? id,
    Expression<DateTime>? date,
    Expression<int>? buyerId,
    Expression<int>? routePointId,
    Expression<int>? visitSkipReasonId,
    Expression<bool>? needCheckGL,
    Expression<bool>? needTakePhotos,
    Expression<bool>? needFillSoftware,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (guid != null) 'guid': guid,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (timestamp != null) 'timestamp': timestamp,
      if (currentTimestamp != null) 'current_timestamp': currentTimestamp,
      if (lastSyncTime != null) 'last_sync_time': lastSyncTime,
      if (id != null) 'id': id,
      if (date != null) 'date': date,
      if (buyerId != null) 'buyer_id': buyerId,
      if (routePointId != null) 'route_point_id': routePointId,
      if (visitSkipReasonId != null) 'visit_skip_reason_id': visitSkipReasonId,
      if (needCheckGL != null) 'need_check_g_l': needCheckGL,
      if (needTakePhotos != null) 'need_take_photos': needTakePhotos,
      if (needFillSoftware != null) 'need_fill_software': needFillSoftware,
      if (rowid != null) 'rowid': rowid,
    });
  }

  VisitsCompanion copyWith(
      {Value<String>? guid,
      Value<bool>? isDeleted,
      Value<DateTime>? timestamp,
      Value<DateTime>? currentTimestamp,
      Value<DateTime?>? lastSyncTime,
      Value<int?>? id,
      Value<DateTime>? date,
      Value<int>? buyerId,
      Value<int?>? routePointId,
      Value<int?>? visitSkipReasonId,
      Value<bool>? needCheckGL,
      Value<bool>? needTakePhotos,
      Value<bool>? needFillSoftware,
      Value<int>? rowid}) {
    return VisitsCompanion(
      guid: guid ?? this.guid,
      isDeleted: isDeleted ?? this.isDeleted,
      timestamp: timestamp ?? this.timestamp,
      currentTimestamp: currentTimestamp ?? this.currentTimestamp,
      lastSyncTime: lastSyncTime ?? this.lastSyncTime,
      id: id ?? this.id,
      date: date ?? this.date,
      buyerId: buyerId ?? this.buyerId,
      routePointId: routePointId ?? this.routePointId,
      visitSkipReasonId: visitSkipReasonId ?? this.visitSkipReasonId,
      needCheckGL: needCheckGL ?? this.needCheckGL,
      needTakePhotos: needTakePhotos ?? this.needTakePhotos,
      needFillSoftware: needFillSoftware ?? this.needFillSoftware,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (guid.present) {
      map['guid'] = Variable<String>(guid.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (currentTimestamp.present) {
      map['current_timestamp'] = Variable<DateTime>(currentTimestamp.value);
    }
    if (lastSyncTime.present) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (buyerId.present) {
      map['buyer_id'] = Variable<int>(buyerId.value);
    }
    if (routePointId.present) {
      map['route_point_id'] = Variable<int>(routePointId.value);
    }
    if (visitSkipReasonId.present) {
      map['visit_skip_reason_id'] = Variable<int>(visitSkipReasonId.value);
    }
    if (needCheckGL.present) {
      map['need_check_g_l'] = Variable<bool>(needCheckGL.value);
    }
    if (needTakePhotos.present) {
      map['need_take_photos'] = Variable<bool>(needTakePhotos.value);
    }
    if (needFillSoftware.present) {
      map['need_fill_software'] = Variable<bool>(needFillSoftware.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('VisitsCompanion(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('id: $id, ')
          ..write('date: $date, ')
          ..write('buyerId: $buyerId, ')
          ..write('routePointId: $routePointId, ')
          ..write('visitSkipReasonId: $visitSkipReasonId, ')
          ..write('needCheckGL: $needCheckGL, ')
          ..write('needTakePhotos: $needTakePhotos, ')
          ..write('needFillSoftware: $needFillSoftware, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SitesTable extends Sites with TableInfo<$SitesTable, Site> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SitesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [id, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sites';
  @override
  VerificationContext validateIntegrity(Insertable<Site> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Site map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Site(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $SitesTable createAlias(String alias) {
    return $SitesTable(attachedDatabase, alias);
  }
}

class Site extends DataClass implements Insertable<Site> {
  final int id;
  final String name;
  const Site({required this.id, required this.name});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    return map;
  }

  SitesCompanion toCompanion(bool nullToAbsent) {
    return SitesCompanion(
      id: Value(id),
      name: Value(name),
    );
  }

  factory Site.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Site(
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
    };
  }

  Site copyWith({int? id, String? name}) => Site(
        id: id ?? this.id,
        name: name ?? this.name,
      );
  Site copyWithCompanion(SitesCompanion data) {
    return Site(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Site(')
          ..write('id: $id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Site && other.id == this.id && other.name == this.name);
}

class SitesCompanion extends UpdateCompanion<Site> {
  final Value<int> id;
  final Value<String> name;
  const SitesCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
  });
  SitesCompanion.insert({
    this.id = const Value.absent(),
    required String name,
  }) : name = Value(name);
  static Insertable<Site> custom({
    Expression<int>? id,
    Expression<String>? name,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
    });
  }

  SitesCompanion copyWith({Value<int>? id, Value<String>? name}) {
    return SitesCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SitesCompanion(')
          ..write('id: $id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class $NtDeptTypesTable extends NtDeptTypes
    with TableInfo<$NtDeptTypesTable, NtDeptType> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $NtDeptTypesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [id, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'nt_dept_types';
  @override
  VerificationContext validateIntegrity(Insertable<NtDeptType> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  NtDeptType map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return NtDeptType(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $NtDeptTypesTable createAlias(String alias) {
    return $NtDeptTypesTable(attachedDatabase, alias);
  }
}

class NtDeptType extends DataClass implements Insertable<NtDeptType> {
  final int id;
  final String name;
  const NtDeptType({required this.id, required this.name});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    return map;
  }

  NtDeptTypesCompanion toCompanion(bool nullToAbsent) {
    return NtDeptTypesCompanion(
      id: Value(id),
      name: Value(name),
    );
  }

  factory NtDeptType.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return NtDeptType(
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
    };
  }

  NtDeptType copyWith({int? id, String? name}) => NtDeptType(
        id: id ?? this.id,
        name: name ?? this.name,
      );
  NtDeptType copyWithCompanion(NtDeptTypesCompanion data) {
    return NtDeptType(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
    );
  }

  @override
  String toString() {
    return (StringBuffer('NtDeptType(')
          ..write('id: $id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is NtDeptType && other.id == this.id && other.name == this.name);
}

class NtDeptTypesCompanion extends UpdateCompanion<NtDeptType> {
  final Value<int> id;
  final Value<String> name;
  const NtDeptTypesCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
  });
  NtDeptTypesCompanion.insert({
    this.id = const Value.absent(),
    required String name,
  }) : name = Value(name);
  static Insertable<NtDeptType> custom({
    Expression<int>? id,
    Expression<String>? name,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
    });
  }

  NtDeptTypesCompanion copyWith({Value<int>? id, Value<String>? name}) {
    return NtDeptTypesCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('NtDeptTypesCompanion(')
          ..write('id: $id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class $GoodsListsTable extends GoodsLists
    with TableInfo<$GoodsListsTable, GoodsList> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GoodsListsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [id, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'goods_lists';
  @override
  VerificationContext validateIntegrity(Insertable<GoodsList> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  GoodsList map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GoodsList(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $GoodsListsTable createAlias(String alias) {
    return $GoodsListsTable(attachedDatabase, alias);
  }
}

class GoodsList extends DataClass implements Insertable<GoodsList> {
  final int id;
  final String name;
  const GoodsList({required this.id, required this.name});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    return map;
  }

  GoodsListsCompanion toCompanion(bool nullToAbsent) {
    return GoodsListsCompanion(
      id: Value(id),
      name: Value(name),
    );
  }

  factory GoodsList.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return GoodsList(
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
    };
  }

  GoodsList copyWith({int? id, String? name}) => GoodsList(
        id: id ?? this.id,
        name: name ?? this.name,
      );
  GoodsList copyWithCompanion(GoodsListsCompanion data) {
    return GoodsList(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
    );
  }

  @override
  String toString() {
    return (StringBuffer('GoodsList(')
          ..write('id: $id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GoodsList && other.id == this.id && other.name == this.name);
}

class GoodsListsCompanion extends UpdateCompanion<GoodsList> {
  final Value<int> id;
  final Value<String> name;
  const GoodsListsCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
  });
  GoodsListsCompanion.insert({
    this.id = const Value.absent(),
    required String name,
  }) : name = Value(name);
  static Insertable<GoodsList> custom({
    Expression<int>? id,
    Expression<String>? name,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
    });
  }

  GoodsListsCompanion copyWith({Value<int>? id, Value<String>? name}) {
    return GoodsListsCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GoodsListsCompanion(')
          ..write('id: $id, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }
}

class $AllGoodsListGoodsTable extends AllGoodsListGoods
    with TableInfo<$AllGoodsListGoodsTable, GoodsListGoods> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AllGoodsListGoodsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _goodsListIdMeta =
      const VerificationMeta('goodsListId');
  @override
  late final GeneratedColumn<int> goodsListId = GeneratedColumn<int>(
      'goods_list_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _goodsIdMeta =
      const VerificationMeta('goodsId');
  @override
  late final GeneratedColumn<int> goodsId = GeneratedColumn<int>(
      'goods_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [goodsListId, goodsId];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'goods_list_goods';
  @override
  VerificationContext validateIntegrity(Insertable<GoodsListGoods> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('goods_list_id')) {
      context.handle(
          _goodsListIdMeta,
          goodsListId.isAcceptableOrUnknown(
              data['goods_list_id']!, _goodsListIdMeta));
    } else if (isInserting) {
      context.missing(_goodsListIdMeta);
    }
    if (data.containsKey('goods_id')) {
      context.handle(_goodsIdMeta,
          goodsId.isAcceptableOrUnknown(data['goods_id']!, _goodsIdMeta));
    } else if (isInserting) {
      context.missing(_goodsIdMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {goodsListId, goodsId};
  @override
  GoodsListGoods map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GoodsListGoods(
      goodsListId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}goods_list_id'])!,
      goodsId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}goods_id'])!,
    );
  }

  @override
  $AllGoodsListGoodsTable createAlias(String alias) {
    return $AllGoodsListGoodsTable(attachedDatabase, alias);
  }
}

class GoodsListGoods extends DataClass implements Insertable<GoodsListGoods> {
  final int goodsListId;
  final int goodsId;
  const GoodsListGoods({required this.goodsListId, required this.goodsId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['goods_list_id'] = Variable<int>(goodsListId);
    map['goods_id'] = Variable<int>(goodsId);
    return map;
  }

  AllGoodsListGoodsCompanion toCompanion(bool nullToAbsent) {
    return AllGoodsListGoodsCompanion(
      goodsListId: Value(goodsListId),
      goodsId: Value(goodsId),
    );
  }

  factory GoodsListGoods.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return GoodsListGoods(
      goodsListId: serializer.fromJson<int>(json['goodsListId']),
      goodsId: serializer.fromJson<int>(json['goodsId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'goodsListId': serializer.toJson<int>(goodsListId),
      'goodsId': serializer.toJson<int>(goodsId),
    };
  }

  GoodsListGoods copyWith({int? goodsListId, int? goodsId}) => GoodsListGoods(
        goodsListId: goodsListId ?? this.goodsListId,
        goodsId: goodsId ?? this.goodsId,
      );
  GoodsListGoods copyWithCompanion(AllGoodsListGoodsCompanion data) {
    return GoodsListGoods(
      goodsListId:
          data.goodsListId.present ? data.goodsListId.value : this.goodsListId,
      goodsId: data.goodsId.present ? data.goodsId.value : this.goodsId,
    );
  }

  @override
  String toString() {
    return (StringBuffer('GoodsListGoods(')
          ..write('goodsListId: $goodsListId, ')
          ..write('goodsId: $goodsId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(goodsListId, goodsId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GoodsListGoods &&
          other.goodsListId == this.goodsListId &&
          other.goodsId == this.goodsId);
}

class AllGoodsListGoodsCompanion extends UpdateCompanion<GoodsListGoods> {
  final Value<int> goodsListId;
  final Value<int> goodsId;
  final Value<int> rowid;
  const AllGoodsListGoodsCompanion({
    this.goodsListId = const Value.absent(),
    this.goodsId = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AllGoodsListGoodsCompanion.insert({
    required int goodsListId,
    required int goodsId,
    this.rowid = const Value.absent(),
  })  : goodsListId = Value(goodsListId),
        goodsId = Value(goodsId);
  static Insertable<GoodsListGoods> custom({
    Expression<int>? goodsListId,
    Expression<int>? goodsId,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (goodsListId != null) 'goods_list_id': goodsListId,
      if (goodsId != null) 'goods_id': goodsId,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AllGoodsListGoodsCompanion copyWith(
      {Value<int>? goodsListId, Value<int>? goodsId, Value<int>? rowid}) {
    return AllGoodsListGoodsCompanion(
      goodsListId: goodsListId ?? this.goodsListId,
      goodsId: goodsId ?? this.goodsId,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (goodsListId.present) {
      map['goods_list_id'] = Variable<int>(goodsListId.value);
    }
    if (goodsId.present) {
      map['goods_id'] = Variable<int>(goodsId.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AllGoodsListGoodsCompanion(')
          ..write('goodsListId: $goodsListId, ')
          ..write('goodsId: $goodsId, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $VisitImagesTable extends VisitImages
    with TableInfo<$VisitImagesTable, VisitImage> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $VisitImagesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _latitudeMeta =
      const VerificationMeta('latitude');
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
      'latitude', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _longitudeMeta =
      const VerificationMeta('longitude');
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
      'longitude', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _accuracyMeta =
      const VerificationMeta('accuracy');
  @override
  late final GeneratedColumn<double> accuracy = GeneratedColumn<double>(
      'accuracy', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _imageUrlMeta =
      const VerificationMeta('imageUrl');
  @override
  late final GeneratedColumn<String> imageUrl = GeneratedColumn<String>(
      'image_url', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _imageKeyMeta =
      const VerificationMeta('imageKey');
  @override
  late final GeneratedColumn<String> imageKey = GeneratedColumn<String>(
      'image_key', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _guidMeta = const VerificationMeta('guid');
  @override
  late final GeneratedColumn<String> guid = GeneratedColumn<String>(
      'guid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _timestampMeta =
      const VerificationMeta('timestamp');
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
      'timestamp', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _currentTimestampMeta =
      const VerificationMeta('currentTimestamp');
  @override
  late final GeneratedColumn<DateTime> currentTimestamp =
      GeneratedColumn<DateTime>('current_timestamp', aliasedName, false,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          defaultValue: currentDateAndTime);
  static const VerificationMeta _lastSyncTimeMeta =
      const VerificationMeta('lastSyncTime');
  @override
  late final GeneratedColumn<DateTime> lastSyncTime = GeneratedColumn<DateTime>(
      'last_sync_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _needSyncMeta =
      const VerificationMeta('needSync');
  @override
  late final GeneratedColumn<bool> needSync = GeneratedColumn<bool>(
      'need_sync', aliasedName, false,
      generatedAs: GeneratedAs(
          (isNew & BooleanExpressionOperators(isDeleted).not()) |
              (BooleanExpressionOperators(isNew).not() &
                  ComparableExpr(lastSyncTime).isSmallerThan(timestamp)),
          true),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("need_sync" IN (0, 1))'));
  static const VerificationMeta _isNewMeta = const VerificationMeta('isNew');
  @override
  late final GeneratedColumn<bool> isNew = GeneratedColumn<bool>(
      'is_new', aliasedName, false,
      generatedAs: GeneratedAs(lastSyncTime.isNull(), false),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_new" IN (0, 1))'));
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _visitGuidMeta =
      const VerificationMeta('visitGuid');
  @override
  late final GeneratedColumn<String> visitGuid = GeneratedColumn<String>(
      'visit_guid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES visits (guid) ON UPDATE CASCADE ON DELETE CASCADE'));
  @override
  List<GeneratedColumn> get $columns => [
        latitude,
        longitude,
        accuracy,
        imageUrl,
        imageKey,
        guid,
        isDeleted,
        timestamp,
        currentTimestamp,
        lastSyncTime,
        needSync,
        isNew,
        id,
        visitGuid
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'visit_images';
  @override
  VerificationContext validateIntegrity(Insertable<VisitImage> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('latitude')) {
      context.handle(_latitudeMeta,
          latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta));
    } else if (isInserting) {
      context.missing(_latitudeMeta);
    }
    if (data.containsKey('longitude')) {
      context.handle(_longitudeMeta,
          longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta));
    } else if (isInserting) {
      context.missing(_longitudeMeta);
    }
    if (data.containsKey('accuracy')) {
      context.handle(_accuracyMeta,
          accuracy.isAcceptableOrUnknown(data['accuracy']!, _accuracyMeta));
    } else if (isInserting) {
      context.missing(_accuracyMeta);
    }
    if (data.containsKey('image_url')) {
      context.handle(_imageUrlMeta,
          imageUrl.isAcceptableOrUnknown(data['image_url']!, _imageUrlMeta));
    } else if (isInserting) {
      context.missing(_imageUrlMeta);
    }
    if (data.containsKey('image_key')) {
      context.handle(_imageKeyMeta,
          imageKey.isAcceptableOrUnknown(data['image_key']!, _imageKeyMeta));
    } else if (isInserting) {
      context.missing(_imageKeyMeta);
    }
    if (data.containsKey('guid')) {
      context.handle(
          _guidMeta, guid.isAcceptableOrUnknown(data['guid']!, _guidMeta));
    } else if (isInserting) {
      context.missing(_guidMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('timestamp')) {
      context.handle(_timestampMeta,
          timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta));
    }
    if (data.containsKey('current_timestamp')) {
      context.handle(
          _currentTimestampMeta,
          currentTimestamp.isAcceptableOrUnknown(
              data['current_timestamp']!, _currentTimestampMeta));
    }
    if (data.containsKey('last_sync_time')) {
      context.handle(
          _lastSyncTimeMeta,
          lastSyncTime.isAcceptableOrUnknown(
              data['last_sync_time']!, _lastSyncTimeMeta));
    }
    if (data.containsKey('need_sync')) {
      context.handle(_needSyncMeta,
          needSync.isAcceptableOrUnknown(data['need_sync']!, _needSyncMeta));
    }
    if (data.containsKey('is_new')) {
      context.handle(
          _isNewMeta, isNew.isAcceptableOrUnknown(data['is_new']!, _isNewMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('visit_guid')) {
      context.handle(_visitGuidMeta,
          visitGuid.isAcceptableOrUnknown(data['visit_guid']!, _visitGuidMeta));
    } else if (isInserting) {
      context.missing(_visitGuidMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {guid};
  @override
  VisitImage map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return VisitImage(
      latitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}latitude'])!,
      longitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}longitude'])!,
      accuracy: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}accuracy'])!,
      imageUrl: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}image_url'])!,
      imageKey: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}image_key'])!,
      guid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}guid'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      timestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}timestamp'])!,
      currentTimestamp: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}current_timestamp'])!,
      lastSyncTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_sync_time']),
      needSync: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_sync'])!,
      isNew: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_new'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      visitGuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}visit_guid'])!,
    );
  }

  @override
  $VisitImagesTable createAlias(String alias) {
    return $VisitImagesTable(attachedDatabase, alias);
  }
}

class VisitImage extends DataClass implements Insertable<VisitImage> {
  final double latitude;
  final double longitude;
  final double accuracy;
  final String imageUrl;
  final String imageKey;
  final String guid;
  final bool isDeleted;
  final DateTime timestamp;
  final DateTime currentTimestamp;
  final DateTime? lastSyncTime;
  final bool needSync;
  final bool isNew;
  final int id;
  final String visitGuid;
  const VisitImage(
      {required this.latitude,
      required this.longitude,
      required this.accuracy,
      required this.imageUrl,
      required this.imageKey,
      required this.guid,
      required this.isDeleted,
      required this.timestamp,
      required this.currentTimestamp,
      this.lastSyncTime,
      required this.needSync,
      required this.isNew,
      required this.id,
      required this.visitGuid});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['latitude'] = Variable<double>(latitude);
    map['longitude'] = Variable<double>(longitude);
    map['accuracy'] = Variable<double>(accuracy);
    map['image_url'] = Variable<String>(imageUrl);
    map['image_key'] = Variable<String>(imageKey);
    map['guid'] = Variable<String>(guid);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['timestamp'] = Variable<DateTime>(timestamp);
    map['current_timestamp'] = Variable<DateTime>(currentTimestamp);
    if (!nullToAbsent || lastSyncTime != null) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime);
    }
    map['id'] = Variable<int>(id);
    map['visit_guid'] = Variable<String>(visitGuid);
    return map;
  }

  VisitImagesCompanion toCompanion(bool nullToAbsent) {
    return VisitImagesCompanion(
      latitude: Value(latitude),
      longitude: Value(longitude),
      accuracy: Value(accuracy),
      imageUrl: Value(imageUrl),
      imageKey: Value(imageKey),
      guid: Value(guid),
      isDeleted: Value(isDeleted),
      timestamp: Value(timestamp),
      currentTimestamp: Value(currentTimestamp),
      lastSyncTime: lastSyncTime == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncTime),
      id: Value(id),
      visitGuid: Value(visitGuid),
    );
  }

  factory VisitImage.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return VisitImage(
      latitude: serializer.fromJson<double>(json['latitude']),
      longitude: serializer.fromJson<double>(json['longitude']),
      accuracy: serializer.fromJson<double>(json['accuracy']),
      imageUrl: serializer.fromJson<String>(json['imageUrl']),
      imageKey: serializer.fromJson<String>(json['imageKey']),
      guid: serializer.fromJson<String>(json['guid']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      currentTimestamp: serializer.fromJson<DateTime>(json['currentTimestamp']),
      lastSyncTime: serializer.fromJson<DateTime?>(json['lastSyncTime']),
      needSync: serializer.fromJson<bool>(json['needSync']),
      isNew: serializer.fromJson<bool>(json['isNew']),
      id: serializer.fromJson<int>(json['id']),
      visitGuid: serializer.fromJson<String>(json['visitGuid']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'latitude': serializer.toJson<double>(latitude),
      'longitude': serializer.toJson<double>(longitude),
      'accuracy': serializer.toJson<double>(accuracy),
      'imageUrl': serializer.toJson<String>(imageUrl),
      'imageKey': serializer.toJson<String>(imageKey),
      'guid': serializer.toJson<String>(guid),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'currentTimestamp': serializer.toJson<DateTime>(currentTimestamp),
      'lastSyncTime': serializer.toJson<DateTime?>(lastSyncTime),
      'needSync': serializer.toJson<bool>(needSync),
      'isNew': serializer.toJson<bool>(isNew),
      'id': serializer.toJson<int>(id),
      'visitGuid': serializer.toJson<String>(visitGuid),
    };
  }

  VisitImage copyWith(
          {double? latitude,
          double? longitude,
          double? accuracy,
          String? imageUrl,
          String? imageKey,
          String? guid,
          bool? isDeleted,
          DateTime? timestamp,
          DateTime? currentTimestamp,
          Value<DateTime?> lastSyncTime = const Value.absent(),
          bool? needSync,
          bool? isNew,
          int? id,
          String? visitGuid}) =>
      VisitImage(
        latitude: latitude ?? this.latitude,
        longitude: longitude ?? this.longitude,
        accuracy: accuracy ?? this.accuracy,
        imageUrl: imageUrl ?? this.imageUrl,
        imageKey: imageKey ?? this.imageKey,
        guid: guid ?? this.guid,
        isDeleted: isDeleted ?? this.isDeleted,
        timestamp: timestamp ?? this.timestamp,
        currentTimestamp: currentTimestamp ?? this.currentTimestamp,
        lastSyncTime:
            lastSyncTime.present ? lastSyncTime.value : this.lastSyncTime,
        needSync: needSync ?? this.needSync,
        isNew: isNew ?? this.isNew,
        id: id ?? this.id,
        visitGuid: visitGuid ?? this.visitGuid,
      );
  @override
  String toString() {
    return (StringBuffer('VisitImage(')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('accuracy: $accuracy, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('imageKey: $imageKey, ')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('needSync: $needSync, ')
          ..write('isNew: $isNew, ')
          ..write('id: $id, ')
          ..write('visitGuid: $visitGuid')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      latitude,
      longitude,
      accuracy,
      imageUrl,
      imageKey,
      guid,
      isDeleted,
      timestamp,
      currentTimestamp,
      lastSyncTime,
      needSync,
      isNew,
      id,
      visitGuid);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is VisitImage &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.accuracy == this.accuracy &&
          other.imageUrl == this.imageUrl &&
          other.imageKey == this.imageKey &&
          other.guid == this.guid &&
          other.isDeleted == this.isDeleted &&
          other.timestamp == this.timestamp &&
          other.currentTimestamp == this.currentTimestamp &&
          other.lastSyncTime == this.lastSyncTime &&
          other.needSync == this.needSync &&
          other.isNew == this.isNew &&
          other.id == this.id &&
          other.visitGuid == this.visitGuid);
}

class VisitImagesCompanion extends UpdateCompanion<VisitImage> {
  final Value<double> latitude;
  final Value<double> longitude;
  final Value<double> accuracy;
  final Value<String> imageUrl;
  final Value<String> imageKey;
  final Value<String> guid;
  final Value<bool> isDeleted;
  final Value<DateTime> timestamp;
  final Value<DateTime> currentTimestamp;
  final Value<DateTime?> lastSyncTime;
  final Value<int> id;
  final Value<String> visitGuid;
  final Value<int> rowid;
  const VisitImagesCompanion({
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.accuracy = const Value.absent(),
    this.imageUrl = const Value.absent(),
    this.imageKey = const Value.absent(),
    this.guid = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    this.visitGuid = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  VisitImagesCompanion.insert({
    required double latitude,
    required double longitude,
    required double accuracy,
    required String imageUrl,
    required String imageKey,
    required String guid,
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    required int id,
    required String visitGuid,
    this.rowid = const Value.absent(),
  })  : latitude = Value(latitude),
        longitude = Value(longitude),
        accuracy = Value(accuracy),
        imageUrl = Value(imageUrl),
        imageKey = Value(imageKey),
        guid = Value(guid),
        id = Value(id),
        visitGuid = Value(visitGuid);
  static Insertable<VisitImage> custom({
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<double>? accuracy,
    Expression<String>? imageUrl,
    Expression<String>? imageKey,
    Expression<String>? guid,
    Expression<bool>? isDeleted,
    Expression<DateTime>? timestamp,
    Expression<DateTime>? currentTimestamp,
    Expression<DateTime>? lastSyncTime,
    Expression<int>? id,
    Expression<String>? visitGuid,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (accuracy != null) 'accuracy': accuracy,
      if (imageUrl != null) 'image_url': imageUrl,
      if (imageKey != null) 'image_key': imageKey,
      if (guid != null) 'guid': guid,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (timestamp != null) 'timestamp': timestamp,
      if (currentTimestamp != null) 'current_timestamp': currentTimestamp,
      if (lastSyncTime != null) 'last_sync_time': lastSyncTime,
      if (id != null) 'id': id,
      if (visitGuid != null) 'visit_guid': visitGuid,
      if (rowid != null) 'rowid': rowid,
    });
  }

  VisitImagesCompanion copyWith(
      {Value<double>? latitude,
      Value<double>? longitude,
      Value<double>? accuracy,
      Value<String>? imageUrl,
      Value<String>? imageKey,
      Value<String>? guid,
      Value<bool>? isDeleted,
      Value<DateTime>? timestamp,
      Value<DateTime>? currentTimestamp,
      Value<DateTime?>? lastSyncTime,
      Value<int>? id,
      Value<String>? visitGuid,
      Value<int>? rowid}) {
    return VisitImagesCompanion(
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      accuracy: accuracy ?? this.accuracy,
      imageUrl: imageUrl ?? this.imageUrl,
      imageKey: imageKey ?? this.imageKey,
      guid: guid ?? this.guid,
      isDeleted: isDeleted ?? this.isDeleted,
      timestamp: timestamp ?? this.timestamp,
      currentTimestamp: currentTimestamp ?? this.currentTimestamp,
      lastSyncTime: lastSyncTime ?? this.lastSyncTime,
      id: id ?? this.id,
      visitGuid: visitGuid ?? this.visitGuid,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (accuracy.present) {
      map['accuracy'] = Variable<double>(accuracy.value);
    }
    if (imageUrl.present) {
      map['image_url'] = Variable<String>(imageUrl.value);
    }
    if (imageKey.present) {
      map['image_key'] = Variable<String>(imageKey.value);
    }
    if (guid.present) {
      map['guid'] = Variable<String>(guid.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (currentTimestamp.present) {
      map['current_timestamp'] = Variable<DateTime>(currentTimestamp.value);
    }
    if (lastSyncTime.present) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (visitGuid.present) {
      map['visit_guid'] = Variable<String>(visitGuid.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('VisitImagesCompanion(')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('accuracy: $accuracy, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('imageKey: $imageKey, ')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('id: $id, ')
          ..write('visitGuid: $visitGuid, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $VisitSoftwaresTable extends VisitSoftwares
    with TableInfo<$VisitSoftwaresTable, VisitSoftware> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $VisitSoftwaresTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _latitudeMeta =
      const VerificationMeta('latitude');
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
      'latitude', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _longitudeMeta =
      const VerificationMeta('longitude');
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
      'longitude', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _accuracyMeta =
      const VerificationMeta('accuracy');
  @override
  late final GeneratedColumn<double> accuracy = GeneratedColumn<double>(
      'accuracy', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _imageUrlMeta =
      const VerificationMeta('imageUrl');
  @override
  late final GeneratedColumn<String> imageUrl = GeneratedColumn<String>(
      'image_url', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _imageKeyMeta =
      const VerificationMeta('imageKey');
  @override
  late final GeneratedColumn<String> imageKey = GeneratedColumn<String>(
      'image_key', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _guidMeta = const VerificationMeta('guid');
  @override
  late final GeneratedColumn<String> guid = GeneratedColumn<String>(
      'guid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _timestampMeta =
      const VerificationMeta('timestamp');
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
      'timestamp', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _currentTimestampMeta =
      const VerificationMeta('currentTimestamp');
  @override
  late final GeneratedColumn<DateTime> currentTimestamp =
      GeneratedColumn<DateTime>('current_timestamp', aliasedName, false,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          defaultValue: currentDateAndTime);
  static const VerificationMeta _lastSyncTimeMeta =
      const VerificationMeta('lastSyncTime');
  @override
  late final GeneratedColumn<DateTime> lastSyncTime = GeneratedColumn<DateTime>(
      'last_sync_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _needSyncMeta =
      const VerificationMeta('needSync');
  @override
  late final GeneratedColumn<bool> needSync = GeneratedColumn<bool>(
      'need_sync', aliasedName, false,
      generatedAs: GeneratedAs(
          (isNew & BooleanExpressionOperators(isDeleted).not()) |
              (BooleanExpressionOperators(isNew).not() &
                  ComparableExpr(lastSyncTime).isSmallerThan(timestamp)),
          true),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("need_sync" IN (0, 1))'));
  static const VerificationMeta _isNewMeta = const VerificationMeta('isNew');
  @override
  late final GeneratedColumn<bool> isNew = GeneratedColumn<bool>(
      'is_new', aliasedName, false,
      generatedAs: GeneratedAs(lastSyncTime.isNull(), false),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_new" IN (0, 1))'));
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _visitGuidMeta =
      const VerificationMeta('visitGuid');
  @override
  late final GeneratedColumn<String> visitGuid = GeneratedColumn<String>(
      'visit_guid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES visits (guid) ON UPDATE CASCADE ON DELETE CASCADE'));
  @override
  List<GeneratedColumn> get $columns => [
        latitude,
        longitude,
        accuracy,
        imageUrl,
        imageKey,
        guid,
        isDeleted,
        timestamp,
        currentTimestamp,
        lastSyncTime,
        needSync,
        isNew,
        id,
        visitGuid
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'visit_softwares';
  @override
  VerificationContext validateIntegrity(Insertable<VisitSoftware> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('latitude')) {
      context.handle(_latitudeMeta,
          latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta));
    } else if (isInserting) {
      context.missing(_latitudeMeta);
    }
    if (data.containsKey('longitude')) {
      context.handle(_longitudeMeta,
          longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta));
    } else if (isInserting) {
      context.missing(_longitudeMeta);
    }
    if (data.containsKey('accuracy')) {
      context.handle(_accuracyMeta,
          accuracy.isAcceptableOrUnknown(data['accuracy']!, _accuracyMeta));
    } else if (isInserting) {
      context.missing(_accuracyMeta);
    }
    if (data.containsKey('image_url')) {
      context.handle(_imageUrlMeta,
          imageUrl.isAcceptableOrUnknown(data['image_url']!, _imageUrlMeta));
    } else if (isInserting) {
      context.missing(_imageUrlMeta);
    }
    if (data.containsKey('image_key')) {
      context.handle(_imageKeyMeta,
          imageKey.isAcceptableOrUnknown(data['image_key']!, _imageKeyMeta));
    } else if (isInserting) {
      context.missing(_imageKeyMeta);
    }
    if (data.containsKey('guid')) {
      context.handle(
          _guidMeta, guid.isAcceptableOrUnknown(data['guid']!, _guidMeta));
    } else if (isInserting) {
      context.missing(_guidMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('timestamp')) {
      context.handle(_timestampMeta,
          timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta));
    }
    if (data.containsKey('current_timestamp')) {
      context.handle(
          _currentTimestampMeta,
          currentTimestamp.isAcceptableOrUnknown(
              data['current_timestamp']!, _currentTimestampMeta));
    }
    if (data.containsKey('last_sync_time')) {
      context.handle(
          _lastSyncTimeMeta,
          lastSyncTime.isAcceptableOrUnknown(
              data['last_sync_time']!, _lastSyncTimeMeta));
    }
    if (data.containsKey('need_sync')) {
      context.handle(_needSyncMeta,
          needSync.isAcceptableOrUnknown(data['need_sync']!, _needSyncMeta));
    }
    if (data.containsKey('is_new')) {
      context.handle(
          _isNewMeta, isNew.isAcceptableOrUnknown(data['is_new']!, _isNewMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('visit_guid')) {
      context.handle(_visitGuidMeta,
          visitGuid.isAcceptableOrUnknown(data['visit_guid']!, _visitGuidMeta));
    } else if (isInserting) {
      context.missing(_visitGuidMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {guid};
  @override
  VisitSoftware map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return VisitSoftware(
      latitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}latitude'])!,
      longitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}longitude'])!,
      accuracy: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}accuracy'])!,
      imageUrl: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}image_url'])!,
      imageKey: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}image_key'])!,
      guid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}guid'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      timestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}timestamp'])!,
      currentTimestamp: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}current_timestamp'])!,
      lastSyncTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_sync_time']),
      needSync: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_sync'])!,
      isNew: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_new'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      visitGuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}visit_guid'])!,
    );
  }

  @override
  $VisitSoftwaresTable createAlias(String alias) {
    return $VisitSoftwaresTable(attachedDatabase, alias);
  }
}

class VisitSoftware extends DataClass implements Insertable<VisitSoftware> {
  final double latitude;
  final double longitude;
  final double accuracy;
  final String imageUrl;
  final String imageKey;
  final String guid;
  final bool isDeleted;
  final DateTime timestamp;
  final DateTime currentTimestamp;
  final DateTime? lastSyncTime;
  final bool needSync;
  final bool isNew;
  final int id;
  final String visitGuid;
  const VisitSoftware(
      {required this.latitude,
      required this.longitude,
      required this.accuracy,
      required this.imageUrl,
      required this.imageKey,
      required this.guid,
      required this.isDeleted,
      required this.timestamp,
      required this.currentTimestamp,
      this.lastSyncTime,
      required this.needSync,
      required this.isNew,
      required this.id,
      required this.visitGuid});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['latitude'] = Variable<double>(latitude);
    map['longitude'] = Variable<double>(longitude);
    map['accuracy'] = Variable<double>(accuracy);
    map['image_url'] = Variable<String>(imageUrl);
    map['image_key'] = Variable<String>(imageKey);
    map['guid'] = Variable<String>(guid);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['timestamp'] = Variable<DateTime>(timestamp);
    map['current_timestamp'] = Variable<DateTime>(currentTimestamp);
    if (!nullToAbsent || lastSyncTime != null) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime);
    }
    map['id'] = Variable<int>(id);
    map['visit_guid'] = Variable<String>(visitGuid);
    return map;
  }

  VisitSoftwaresCompanion toCompanion(bool nullToAbsent) {
    return VisitSoftwaresCompanion(
      latitude: Value(latitude),
      longitude: Value(longitude),
      accuracy: Value(accuracy),
      imageUrl: Value(imageUrl),
      imageKey: Value(imageKey),
      guid: Value(guid),
      isDeleted: Value(isDeleted),
      timestamp: Value(timestamp),
      currentTimestamp: Value(currentTimestamp),
      lastSyncTime: lastSyncTime == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncTime),
      id: Value(id),
      visitGuid: Value(visitGuid),
    );
  }

  factory VisitSoftware.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return VisitSoftware(
      latitude: serializer.fromJson<double>(json['latitude']),
      longitude: serializer.fromJson<double>(json['longitude']),
      accuracy: serializer.fromJson<double>(json['accuracy']),
      imageUrl: serializer.fromJson<String>(json['imageUrl']),
      imageKey: serializer.fromJson<String>(json['imageKey']),
      guid: serializer.fromJson<String>(json['guid']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      currentTimestamp: serializer.fromJson<DateTime>(json['currentTimestamp']),
      lastSyncTime: serializer.fromJson<DateTime?>(json['lastSyncTime']),
      needSync: serializer.fromJson<bool>(json['needSync']),
      isNew: serializer.fromJson<bool>(json['isNew']),
      id: serializer.fromJson<int>(json['id']),
      visitGuid: serializer.fromJson<String>(json['visitGuid']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'latitude': serializer.toJson<double>(latitude),
      'longitude': serializer.toJson<double>(longitude),
      'accuracy': serializer.toJson<double>(accuracy),
      'imageUrl': serializer.toJson<String>(imageUrl),
      'imageKey': serializer.toJson<String>(imageKey),
      'guid': serializer.toJson<String>(guid),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'currentTimestamp': serializer.toJson<DateTime>(currentTimestamp),
      'lastSyncTime': serializer.toJson<DateTime?>(lastSyncTime),
      'needSync': serializer.toJson<bool>(needSync),
      'isNew': serializer.toJson<bool>(isNew),
      'id': serializer.toJson<int>(id),
      'visitGuid': serializer.toJson<String>(visitGuid),
    };
  }

  VisitSoftware copyWith(
          {double? latitude,
          double? longitude,
          double? accuracy,
          String? imageUrl,
          String? imageKey,
          String? guid,
          bool? isDeleted,
          DateTime? timestamp,
          DateTime? currentTimestamp,
          Value<DateTime?> lastSyncTime = const Value.absent(),
          bool? needSync,
          bool? isNew,
          int? id,
          String? visitGuid}) =>
      VisitSoftware(
        latitude: latitude ?? this.latitude,
        longitude: longitude ?? this.longitude,
        accuracy: accuracy ?? this.accuracy,
        imageUrl: imageUrl ?? this.imageUrl,
        imageKey: imageKey ?? this.imageKey,
        guid: guid ?? this.guid,
        isDeleted: isDeleted ?? this.isDeleted,
        timestamp: timestamp ?? this.timestamp,
        currentTimestamp: currentTimestamp ?? this.currentTimestamp,
        lastSyncTime:
            lastSyncTime.present ? lastSyncTime.value : this.lastSyncTime,
        needSync: needSync ?? this.needSync,
        isNew: isNew ?? this.isNew,
        id: id ?? this.id,
        visitGuid: visitGuid ?? this.visitGuid,
      );
  @override
  String toString() {
    return (StringBuffer('VisitSoftware(')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('accuracy: $accuracy, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('imageKey: $imageKey, ')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('needSync: $needSync, ')
          ..write('isNew: $isNew, ')
          ..write('id: $id, ')
          ..write('visitGuid: $visitGuid')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      latitude,
      longitude,
      accuracy,
      imageUrl,
      imageKey,
      guid,
      isDeleted,
      timestamp,
      currentTimestamp,
      lastSyncTime,
      needSync,
      isNew,
      id,
      visitGuid);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is VisitSoftware &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.accuracy == this.accuracy &&
          other.imageUrl == this.imageUrl &&
          other.imageKey == this.imageKey &&
          other.guid == this.guid &&
          other.isDeleted == this.isDeleted &&
          other.timestamp == this.timestamp &&
          other.currentTimestamp == this.currentTimestamp &&
          other.lastSyncTime == this.lastSyncTime &&
          other.needSync == this.needSync &&
          other.isNew == this.isNew &&
          other.id == this.id &&
          other.visitGuid == this.visitGuid);
}

class VisitSoftwaresCompanion extends UpdateCompanion<VisitSoftware> {
  final Value<double> latitude;
  final Value<double> longitude;
  final Value<double> accuracy;
  final Value<String> imageUrl;
  final Value<String> imageKey;
  final Value<String> guid;
  final Value<bool> isDeleted;
  final Value<DateTime> timestamp;
  final Value<DateTime> currentTimestamp;
  final Value<DateTime?> lastSyncTime;
  final Value<int> id;
  final Value<String> visitGuid;
  final Value<int> rowid;
  const VisitSoftwaresCompanion({
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.accuracy = const Value.absent(),
    this.imageUrl = const Value.absent(),
    this.imageKey = const Value.absent(),
    this.guid = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    this.visitGuid = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  VisitSoftwaresCompanion.insert({
    required double latitude,
    required double longitude,
    required double accuracy,
    required String imageUrl,
    required String imageKey,
    required String guid,
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    required int id,
    required String visitGuid,
    this.rowid = const Value.absent(),
  })  : latitude = Value(latitude),
        longitude = Value(longitude),
        accuracy = Value(accuracy),
        imageUrl = Value(imageUrl),
        imageKey = Value(imageKey),
        guid = Value(guid),
        id = Value(id),
        visitGuid = Value(visitGuid);
  static Insertable<VisitSoftware> custom({
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<double>? accuracy,
    Expression<String>? imageUrl,
    Expression<String>? imageKey,
    Expression<String>? guid,
    Expression<bool>? isDeleted,
    Expression<DateTime>? timestamp,
    Expression<DateTime>? currentTimestamp,
    Expression<DateTime>? lastSyncTime,
    Expression<int>? id,
    Expression<String>? visitGuid,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (accuracy != null) 'accuracy': accuracy,
      if (imageUrl != null) 'image_url': imageUrl,
      if (imageKey != null) 'image_key': imageKey,
      if (guid != null) 'guid': guid,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (timestamp != null) 'timestamp': timestamp,
      if (currentTimestamp != null) 'current_timestamp': currentTimestamp,
      if (lastSyncTime != null) 'last_sync_time': lastSyncTime,
      if (id != null) 'id': id,
      if (visitGuid != null) 'visit_guid': visitGuid,
      if (rowid != null) 'rowid': rowid,
    });
  }

  VisitSoftwaresCompanion copyWith(
      {Value<double>? latitude,
      Value<double>? longitude,
      Value<double>? accuracy,
      Value<String>? imageUrl,
      Value<String>? imageKey,
      Value<String>? guid,
      Value<bool>? isDeleted,
      Value<DateTime>? timestamp,
      Value<DateTime>? currentTimestamp,
      Value<DateTime?>? lastSyncTime,
      Value<int>? id,
      Value<String>? visitGuid,
      Value<int>? rowid}) {
    return VisitSoftwaresCompanion(
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      accuracy: accuracy ?? this.accuracy,
      imageUrl: imageUrl ?? this.imageUrl,
      imageKey: imageKey ?? this.imageKey,
      guid: guid ?? this.guid,
      isDeleted: isDeleted ?? this.isDeleted,
      timestamp: timestamp ?? this.timestamp,
      currentTimestamp: currentTimestamp ?? this.currentTimestamp,
      lastSyncTime: lastSyncTime ?? this.lastSyncTime,
      id: id ?? this.id,
      visitGuid: visitGuid ?? this.visitGuid,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (accuracy.present) {
      map['accuracy'] = Variable<double>(accuracy.value);
    }
    if (imageUrl.present) {
      map['image_url'] = Variable<String>(imageUrl.value);
    }
    if (imageKey.present) {
      map['image_key'] = Variable<String>(imageKey.value);
    }
    if (guid.present) {
      map['guid'] = Variable<String>(guid.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (currentTimestamp.present) {
      map['current_timestamp'] = Variable<DateTime>(currentTimestamp.value);
    }
    if (lastSyncTime.present) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (visitGuid.present) {
      map['visit_guid'] = Variable<String>(visitGuid.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('VisitSoftwaresCompanion(')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('accuracy: $accuracy, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('imageKey: $imageKey, ')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('id: $id, ')
          ..write('visitGuid: $visitGuid, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $VisitGoodsListsTable extends VisitGoodsLists
    with TableInfo<$VisitGoodsListsTable, VisitGoodsList> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $VisitGoodsListsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _guidMeta = const VerificationMeta('guid');
  @override
  late final GeneratedColumn<String> guid = GeneratedColumn<String>(
      'guid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _timestampMeta =
      const VerificationMeta('timestamp');
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
      'timestamp', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _currentTimestampMeta =
      const VerificationMeta('currentTimestamp');
  @override
  late final GeneratedColumn<DateTime> currentTimestamp =
      GeneratedColumn<DateTime>('current_timestamp', aliasedName, false,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          defaultValue: currentDateAndTime);
  static const VerificationMeta _lastSyncTimeMeta =
      const VerificationMeta('lastSyncTime');
  @override
  late final GeneratedColumn<DateTime> lastSyncTime = GeneratedColumn<DateTime>(
      'last_sync_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _needSyncMeta =
      const VerificationMeta('needSync');
  @override
  late final GeneratedColumn<bool> needSync = GeneratedColumn<bool>(
      'need_sync', aliasedName, false,
      generatedAs: GeneratedAs(
          (isNew & BooleanExpressionOperators(isDeleted).not()) |
              (BooleanExpressionOperators(isNew).not() &
                  ComparableExpr(lastSyncTime).isSmallerThan(timestamp)),
          true),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("need_sync" IN (0, 1))'));
  static const VerificationMeta _isNewMeta = const VerificationMeta('isNew');
  @override
  late final GeneratedColumn<bool> isNew = GeneratedColumn<bool>(
      'is_new', aliasedName, false,
      generatedAs: GeneratedAs(lastSyncTime.isNull(), false),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_new" IN (0, 1))'));
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _goodsListIdMeta =
      const VerificationMeta('goodsListId');
  @override
  late final GeneratedColumn<int> goodsListId = GeneratedColumn<int>(
      'goods_list_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _visitGuidMeta =
      const VerificationMeta('visitGuid');
  @override
  late final GeneratedColumn<String> visitGuid = GeneratedColumn<String>(
      'visit_guid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES visits (guid) ON UPDATE CASCADE ON DELETE CASCADE'));
  @override
  List<GeneratedColumn> get $columns => [
        guid,
        isDeleted,
        timestamp,
        currentTimestamp,
        lastSyncTime,
        needSync,
        isNew,
        id,
        goodsListId,
        visitGuid
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'visit_goods_lists';
  @override
  VerificationContext validateIntegrity(Insertable<VisitGoodsList> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('guid')) {
      context.handle(
          _guidMeta, guid.isAcceptableOrUnknown(data['guid']!, _guidMeta));
    } else if (isInserting) {
      context.missing(_guidMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('timestamp')) {
      context.handle(_timestampMeta,
          timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta));
    }
    if (data.containsKey('current_timestamp')) {
      context.handle(
          _currentTimestampMeta,
          currentTimestamp.isAcceptableOrUnknown(
              data['current_timestamp']!, _currentTimestampMeta));
    }
    if (data.containsKey('last_sync_time')) {
      context.handle(
          _lastSyncTimeMeta,
          lastSyncTime.isAcceptableOrUnknown(
              data['last_sync_time']!, _lastSyncTimeMeta));
    }
    if (data.containsKey('need_sync')) {
      context.handle(_needSyncMeta,
          needSync.isAcceptableOrUnknown(data['need_sync']!, _needSyncMeta));
    }
    if (data.containsKey('is_new')) {
      context.handle(
          _isNewMeta, isNew.isAcceptableOrUnknown(data['is_new']!, _isNewMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('goods_list_id')) {
      context.handle(
          _goodsListIdMeta,
          goodsListId.isAcceptableOrUnknown(
              data['goods_list_id']!, _goodsListIdMeta));
    } else if (isInserting) {
      context.missing(_goodsListIdMeta);
    }
    if (data.containsKey('visit_guid')) {
      context.handle(_visitGuidMeta,
          visitGuid.isAcceptableOrUnknown(data['visit_guid']!, _visitGuidMeta));
    } else if (isInserting) {
      context.missing(_visitGuidMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {guid};
  @override
  VisitGoodsList map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return VisitGoodsList(
      guid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}guid'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      timestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}timestamp'])!,
      currentTimestamp: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}current_timestamp'])!,
      lastSyncTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_sync_time']),
      needSync: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_sync'])!,
      isNew: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_new'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id']),
      goodsListId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}goods_list_id'])!,
      visitGuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}visit_guid'])!,
    );
  }

  @override
  $VisitGoodsListsTable createAlias(String alias) {
    return $VisitGoodsListsTable(attachedDatabase, alias);
  }
}

class VisitGoodsList extends DataClass implements Insertable<VisitGoodsList> {
  final String guid;
  final bool isDeleted;
  final DateTime timestamp;
  final DateTime currentTimestamp;
  final DateTime? lastSyncTime;
  final bool needSync;
  final bool isNew;
  final int? id;
  final int goodsListId;
  final String visitGuid;
  const VisitGoodsList(
      {required this.guid,
      required this.isDeleted,
      required this.timestamp,
      required this.currentTimestamp,
      this.lastSyncTime,
      required this.needSync,
      required this.isNew,
      this.id,
      required this.goodsListId,
      required this.visitGuid});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['guid'] = Variable<String>(guid);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['timestamp'] = Variable<DateTime>(timestamp);
    map['current_timestamp'] = Variable<DateTime>(currentTimestamp);
    if (!nullToAbsent || lastSyncTime != null) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    map['goods_list_id'] = Variable<int>(goodsListId);
    map['visit_guid'] = Variable<String>(visitGuid);
    return map;
  }

  VisitGoodsListsCompanion toCompanion(bool nullToAbsent) {
    return VisitGoodsListsCompanion(
      guid: Value(guid),
      isDeleted: Value(isDeleted),
      timestamp: Value(timestamp),
      currentTimestamp: Value(currentTimestamp),
      lastSyncTime: lastSyncTime == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncTime),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      goodsListId: Value(goodsListId),
      visitGuid: Value(visitGuid),
    );
  }

  factory VisitGoodsList.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return VisitGoodsList(
      guid: serializer.fromJson<String>(json['guid']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      currentTimestamp: serializer.fromJson<DateTime>(json['currentTimestamp']),
      lastSyncTime: serializer.fromJson<DateTime?>(json['lastSyncTime']),
      needSync: serializer.fromJson<bool>(json['needSync']),
      isNew: serializer.fromJson<bool>(json['isNew']),
      id: serializer.fromJson<int?>(json['id']),
      goodsListId: serializer.fromJson<int>(json['goodsListId']),
      visitGuid: serializer.fromJson<String>(json['visitGuid']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'guid': serializer.toJson<String>(guid),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'currentTimestamp': serializer.toJson<DateTime>(currentTimestamp),
      'lastSyncTime': serializer.toJson<DateTime?>(lastSyncTime),
      'needSync': serializer.toJson<bool>(needSync),
      'isNew': serializer.toJson<bool>(isNew),
      'id': serializer.toJson<int?>(id),
      'goodsListId': serializer.toJson<int>(goodsListId),
      'visitGuid': serializer.toJson<String>(visitGuid),
    };
  }

  VisitGoodsList copyWith(
          {String? guid,
          bool? isDeleted,
          DateTime? timestamp,
          DateTime? currentTimestamp,
          Value<DateTime?> lastSyncTime = const Value.absent(),
          bool? needSync,
          bool? isNew,
          Value<int?> id = const Value.absent(),
          int? goodsListId,
          String? visitGuid}) =>
      VisitGoodsList(
        guid: guid ?? this.guid,
        isDeleted: isDeleted ?? this.isDeleted,
        timestamp: timestamp ?? this.timestamp,
        currentTimestamp: currentTimestamp ?? this.currentTimestamp,
        lastSyncTime:
            lastSyncTime.present ? lastSyncTime.value : this.lastSyncTime,
        needSync: needSync ?? this.needSync,
        isNew: isNew ?? this.isNew,
        id: id.present ? id.value : this.id,
        goodsListId: goodsListId ?? this.goodsListId,
        visitGuid: visitGuid ?? this.visitGuid,
      );
  @override
  String toString() {
    return (StringBuffer('VisitGoodsList(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('needSync: $needSync, ')
          ..write('isNew: $isNew, ')
          ..write('id: $id, ')
          ..write('goodsListId: $goodsListId, ')
          ..write('visitGuid: $visitGuid')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(guid, isDeleted, timestamp, currentTimestamp,
      lastSyncTime, needSync, isNew, id, goodsListId, visitGuid);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is VisitGoodsList &&
          other.guid == this.guid &&
          other.isDeleted == this.isDeleted &&
          other.timestamp == this.timestamp &&
          other.currentTimestamp == this.currentTimestamp &&
          other.lastSyncTime == this.lastSyncTime &&
          other.needSync == this.needSync &&
          other.isNew == this.isNew &&
          other.id == this.id &&
          other.goodsListId == this.goodsListId &&
          other.visitGuid == this.visitGuid);
}

class VisitGoodsListsCompanion extends UpdateCompanion<VisitGoodsList> {
  final Value<String> guid;
  final Value<bool> isDeleted;
  final Value<DateTime> timestamp;
  final Value<DateTime> currentTimestamp;
  final Value<DateTime?> lastSyncTime;
  final Value<int?> id;
  final Value<int> goodsListId;
  final Value<String> visitGuid;
  final Value<int> rowid;
  const VisitGoodsListsCompanion({
    this.guid = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    this.goodsListId = const Value.absent(),
    this.visitGuid = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  VisitGoodsListsCompanion.insert({
    required String guid,
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    required int goodsListId,
    required String visitGuid,
    this.rowid = const Value.absent(),
  })  : guid = Value(guid),
        goodsListId = Value(goodsListId),
        visitGuid = Value(visitGuid);
  static Insertable<VisitGoodsList> custom({
    Expression<String>? guid,
    Expression<bool>? isDeleted,
    Expression<DateTime>? timestamp,
    Expression<DateTime>? currentTimestamp,
    Expression<DateTime>? lastSyncTime,
    Expression<int>? id,
    Expression<int>? goodsListId,
    Expression<String>? visitGuid,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (guid != null) 'guid': guid,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (timestamp != null) 'timestamp': timestamp,
      if (currentTimestamp != null) 'current_timestamp': currentTimestamp,
      if (lastSyncTime != null) 'last_sync_time': lastSyncTime,
      if (id != null) 'id': id,
      if (goodsListId != null) 'goods_list_id': goodsListId,
      if (visitGuid != null) 'visit_guid': visitGuid,
      if (rowid != null) 'rowid': rowid,
    });
  }

  VisitGoodsListsCompanion copyWith(
      {Value<String>? guid,
      Value<bool>? isDeleted,
      Value<DateTime>? timestamp,
      Value<DateTime>? currentTimestamp,
      Value<DateTime?>? lastSyncTime,
      Value<int?>? id,
      Value<int>? goodsListId,
      Value<String>? visitGuid,
      Value<int>? rowid}) {
    return VisitGoodsListsCompanion(
      guid: guid ?? this.guid,
      isDeleted: isDeleted ?? this.isDeleted,
      timestamp: timestamp ?? this.timestamp,
      currentTimestamp: currentTimestamp ?? this.currentTimestamp,
      lastSyncTime: lastSyncTime ?? this.lastSyncTime,
      id: id ?? this.id,
      goodsListId: goodsListId ?? this.goodsListId,
      visitGuid: visitGuid ?? this.visitGuid,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (guid.present) {
      map['guid'] = Variable<String>(guid.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (currentTimestamp.present) {
      map['current_timestamp'] = Variable<DateTime>(currentTimestamp.value);
    }
    if (lastSyncTime.present) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (goodsListId.present) {
      map['goods_list_id'] = Variable<int>(goodsListId.value);
    }
    if (visitGuid.present) {
      map['visit_guid'] = Variable<String>(visitGuid.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('VisitGoodsListsCompanion(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('id: $id, ')
          ..write('goodsListId: $goodsListId, ')
          ..write('visitGuid: $visitGuid, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AllVisitGoodsListGoodsTable extends AllVisitGoodsListGoods
    with TableInfo<$AllVisitGoodsListGoodsTable, VisitGoodsListGoods> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AllVisitGoodsListGoodsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _guidMeta = const VerificationMeta('guid');
  @override
  late final GeneratedColumn<String> guid = GeneratedColumn<String>(
      'guid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _timestampMeta =
      const VerificationMeta('timestamp');
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
      'timestamp', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _currentTimestampMeta =
      const VerificationMeta('currentTimestamp');
  @override
  late final GeneratedColumn<DateTime> currentTimestamp =
      GeneratedColumn<DateTime>('current_timestamp', aliasedName, false,
          type: DriftSqlType.dateTime,
          requiredDuringInsert: false,
          defaultValue: currentDateAndTime);
  static const VerificationMeta _lastSyncTimeMeta =
      const VerificationMeta('lastSyncTime');
  @override
  late final GeneratedColumn<DateTime> lastSyncTime = GeneratedColumn<DateTime>(
      'last_sync_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _needSyncMeta =
      const VerificationMeta('needSync');
  @override
  late final GeneratedColumn<bool> needSync = GeneratedColumn<bool>(
      'need_sync', aliasedName, false,
      generatedAs: GeneratedAs(
          (isNew & BooleanExpressionOperators(isDeleted).not()) |
              (BooleanExpressionOperators(isNew).not() &
                  ComparableExpr(lastSyncTime).isSmallerThan(timestamp)),
          true),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("need_sync" IN (0, 1))'));
  static const VerificationMeta _isNewMeta = const VerificationMeta('isNew');
  @override
  late final GeneratedColumn<bool> isNew = GeneratedColumn<bool>(
      'is_new', aliasedName, false,
      generatedAs: GeneratedAs(lastSyncTime.isNull(), false),
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_new" IN (0, 1))'));
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _goodsIdMeta =
      const VerificationMeta('goodsId');
  @override
  late final GeneratedColumn<int> goodsId = GeneratedColumn<int>(
      'goods_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _visitGoodsListGuidMeta =
      const VerificationMeta('visitGoodsListGuid');
  @override
  late final GeneratedColumn<String> visitGoodsListGuid = GeneratedColumn<
          String>('visit_goods_list_guid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES visit_goods_lists (guid) ON UPDATE CASCADE ON DELETE CASCADE'));
  @override
  List<GeneratedColumn> get $columns => [
        guid,
        isDeleted,
        timestamp,
        currentTimestamp,
        lastSyncTime,
        needSync,
        isNew,
        id,
        goodsId,
        visitGoodsListGuid
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'visit_goods_list_goods';
  @override
  VerificationContext validateIntegrity(
      Insertable<VisitGoodsListGoods> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('guid')) {
      context.handle(
          _guidMeta, guid.isAcceptableOrUnknown(data['guid']!, _guidMeta));
    } else if (isInserting) {
      context.missing(_guidMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('timestamp')) {
      context.handle(_timestampMeta,
          timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta));
    }
    if (data.containsKey('current_timestamp')) {
      context.handle(
          _currentTimestampMeta,
          currentTimestamp.isAcceptableOrUnknown(
              data['current_timestamp']!, _currentTimestampMeta));
    }
    if (data.containsKey('last_sync_time')) {
      context.handle(
          _lastSyncTimeMeta,
          lastSyncTime.isAcceptableOrUnknown(
              data['last_sync_time']!, _lastSyncTimeMeta));
    }
    if (data.containsKey('need_sync')) {
      context.handle(_needSyncMeta,
          needSync.isAcceptableOrUnknown(data['need_sync']!, _needSyncMeta));
    }
    if (data.containsKey('is_new')) {
      context.handle(
          _isNewMeta, isNew.isAcceptableOrUnknown(data['is_new']!, _isNewMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('goods_id')) {
      context.handle(_goodsIdMeta,
          goodsId.isAcceptableOrUnknown(data['goods_id']!, _goodsIdMeta));
    } else if (isInserting) {
      context.missing(_goodsIdMeta);
    }
    if (data.containsKey('visit_goods_list_guid')) {
      context.handle(
          _visitGoodsListGuidMeta,
          visitGoodsListGuid.isAcceptableOrUnknown(
              data['visit_goods_list_guid']!, _visitGoodsListGuidMeta));
    } else if (isInserting) {
      context.missing(_visitGoodsListGuidMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {guid};
  @override
  VisitGoodsListGoods map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return VisitGoodsListGoods(
      guid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}guid'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      timestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}timestamp'])!,
      currentTimestamp: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}current_timestamp'])!,
      lastSyncTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_sync_time']),
      needSync: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}need_sync'])!,
      isNew: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_new'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id']),
      goodsId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}goods_id'])!,
      visitGoodsListGuid: attachedDatabase.typeMapping.read(DriftSqlType.string,
          data['${effectivePrefix}visit_goods_list_guid'])!,
    );
  }

  @override
  $AllVisitGoodsListGoodsTable createAlias(String alias) {
    return $AllVisitGoodsListGoodsTable(attachedDatabase, alias);
  }
}

class VisitGoodsListGoods extends DataClass
    implements Insertable<VisitGoodsListGoods> {
  final String guid;
  final bool isDeleted;
  final DateTime timestamp;
  final DateTime currentTimestamp;
  final DateTime? lastSyncTime;
  final bool needSync;
  final bool isNew;
  final int? id;
  final int goodsId;
  final String visitGoodsListGuid;
  const VisitGoodsListGoods(
      {required this.guid,
      required this.isDeleted,
      required this.timestamp,
      required this.currentTimestamp,
      this.lastSyncTime,
      required this.needSync,
      required this.isNew,
      this.id,
      required this.goodsId,
      required this.visitGoodsListGuid});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['guid'] = Variable<String>(guid);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['timestamp'] = Variable<DateTime>(timestamp);
    map['current_timestamp'] = Variable<DateTime>(currentTimestamp);
    if (!nullToAbsent || lastSyncTime != null) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    map['goods_id'] = Variable<int>(goodsId);
    map['visit_goods_list_guid'] = Variable<String>(visitGoodsListGuid);
    return map;
  }

  AllVisitGoodsListGoodsCompanion toCompanion(bool nullToAbsent) {
    return AllVisitGoodsListGoodsCompanion(
      guid: Value(guid),
      isDeleted: Value(isDeleted),
      timestamp: Value(timestamp),
      currentTimestamp: Value(currentTimestamp),
      lastSyncTime: lastSyncTime == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncTime),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      goodsId: Value(goodsId),
      visitGoodsListGuid: Value(visitGoodsListGuid),
    );
  }

  factory VisitGoodsListGoods.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return VisitGoodsListGoods(
      guid: serializer.fromJson<String>(json['guid']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      currentTimestamp: serializer.fromJson<DateTime>(json['currentTimestamp']),
      lastSyncTime: serializer.fromJson<DateTime?>(json['lastSyncTime']),
      needSync: serializer.fromJson<bool>(json['needSync']),
      isNew: serializer.fromJson<bool>(json['isNew']),
      id: serializer.fromJson<int?>(json['id']),
      goodsId: serializer.fromJson<int>(json['goodsId']),
      visitGoodsListGuid:
          serializer.fromJson<String>(json['visitGoodsListGuid']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'guid': serializer.toJson<String>(guid),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'currentTimestamp': serializer.toJson<DateTime>(currentTimestamp),
      'lastSyncTime': serializer.toJson<DateTime?>(lastSyncTime),
      'needSync': serializer.toJson<bool>(needSync),
      'isNew': serializer.toJson<bool>(isNew),
      'id': serializer.toJson<int?>(id),
      'goodsId': serializer.toJson<int>(goodsId),
      'visitGoodsListGuid': serializer.toJson<String>(visitGoodsListGuid),
    };
  }

  VisitGoodsListGoods copyWith(
          {String? guid,
          bool? isDeleted,
          DateTime? timestamp,
          DateTime? currentTimestamp,
          Value<DateTime?> lastSyncTime = const Value.absent(),
          bool? needSync,
          bool? isNew,
          Value<int?> id = const Value.absent(),
          int? goodsId,
          String? visitGoodsListGuid}) =>
      VisitGoodsListGoods(
        guid: guid ?? this.guid,
        isDeleted: isDeleted ?? this.isDeleted,
        timestamp: timestamp ?? this.timestamp,
        currentTimestamp: currentTimestamp ?? this.currentTimestamp,
        lastSyncTime:
            lastSyncTime.present ? lastSyncTime.value : this.lastSyncTime,
        needSync: needSync ?? this.needSync,
        isNew: isNew ?? this.isNew,
        id: id.present ? id.value : this.id,
        goodsId: goodsId ?? this.goodsId,
        visitGoodsListGuid: visitGoodsListGuid ?? this.visitGoodsListGuid,
      );
  @override
  String toString() {
    return (StringBuffer('VisitGoodsListGoods(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('needSync: $needSync, ')
          ..write('isNew: $isNew, ')
          ..write('id: $id, ')
          ..write('goodsId: $goodsId, ')
          ..write('visitGoodsListGuid: $visitGoodsListGuid')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(guid, isDeleted, timestamp, currentTimestamp,
      lastSyncTime, needSync, isNew, id, goodsId, visitGoodsListGuid);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is VisitGoodsListGoods &&
          other.guid == this.guid &&
          other.isDeleted == this.isDeleted &&
          other.timestamp == this.timestamp &&
          other.currentTimestamp == this.currentTimestamp &&
          other.lastSyncTime == this.lastSyncTime &&
          other.needSync == this.needSync &&
          other.isNew == this.isNew &&
          other.id == this.id &&
          other.goodsId == this.goodsId &&
          other.visitGoodsListGuid == this.visitGoodsListGuid);
}

class AllVisitGoodsListGoodsCompanion
    extends UpdateCompanion<VisitGoodsListGoods> {
  final Value<String> guid;
  final Value<bool> isDeleted;
  final Value<DateTime> timestamp;
  final Value<DateTime> currentTimestamp;
  final Value<DateTime?> lastSyncTime;
  final Value<int?> id;
  final Value<int> goodsId;
  final Value<String> visitGoodsListGuid;
  final Value<int> rowid;
  const AllVisitGoodsListGoodsCompanion({
    this.guid = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    this.goodsId = const Value.absent(),
    this.visitGoodsListGuid = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AllVisitGoodsListGoodsCompanion.insert({
    required String guid,
    this.isDeleted = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.currentTimestamp = const Value.absent(),
    this.lastSyncTime = const Value.absent(),
    this.id = const Value.absent(),
    required int goodsId,
    required String visitGoodsListGuid,
    this.rowid = const Value.absent(),
  })  : guid = Value(guid),
        goodsId = Value(goodsId),
        visitGoodsListGuid = Value(visitGoodsListGuid);
  static Insertable<VisitGoodsListGoods> custom({
    Expression<String>? guid,
    Expression<bool>? isDeleted,
    Expression<DateTime>? timestamp,
    Expression<DateTime>? currentTimestamp,
    Expression<DateTime>? lastSyncTime,
    Expression<int>? id,
    Expression<int>? goodsId,
    Expression<String>? visitGoodsListGuid,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (guid != null) 'guid': guid,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (timestamp != null) 'timestamp': timestamp,
      if (currentTimestamp != null) 'current_timestamp': currentTimestamp,
      if (lastSyncTime != null) 'last_sync_time': lastSyncTime,
      if (id != null) 'id': id,
      if (goodsId != null) 'goods_id': goodsId,
      if (visitGoodsListGuid != null)
        'visit_goods_list_guid': visitGoodsListGuid,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AllVisitGoodsListGoodsCompanion copyWith(
      {Value<String>? guid,
      Value<bool>? isDeleted,
      Value<DateTime>? timestamp,
      Value<DateTime>? currentTimestamp,
      Value<DateTime?>? lastSyncTime,
      Value<int?>? id,
      Value<int>? goodsId,
      Value<String>? visitGoodsListGuid,
      Value<int>? rowid}) {
    return AllVisitGoodsListGoodsCompanion(
      guid: guid ?? this.guid,
      isDeleted: isDeleted ?? this.isDeleted,
      timestamp: timestamp ?? this.timestamp,
      currentTimestamp: currentTimestamp ?? this.currentTimestamp,
      lastSyncTime: lastSyncTime ?? this.lastSyncTime,
      id: id ?? this.id,
      goodsId: goodsId ?? this.goodsId,
      visitGoodsListGuid: visitGoodsListGuid ?? this.visitGoodsListGuid,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (guid.present) {
      map['guid'] = Variable<String>(guid.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (currentTimestamp.present) {
      map['current_timestamp'] = Variable<DateTime>(currentTimestamp.value);
    }
    if (lastSyncTime.present) {
      map['last_sync_time'] = Variable<DateTime>(lastSyncTime.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (goodsId.present) {
      map['goods_id'] = Variable<int>(goodsId.value);
    }
    if (visitGoodsListGuid.present) {
      map['visit_goods_list_guid'] = Variable<String>(visitGoodsListGuid.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AllVisitGoodsListGoodsCompanion(')
          ..write('guid: $guid, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('timestamp: $timestamp, ')
          ..write('currentTimestamp: $currentTimestamp, ')
          ..write('lastSyncTime: $lastSyncTime, ')
          ..write('id: $id, ')
          ..write('goodsId: $goodsId, ')
          ..write('visitGoodsListGuid: $visitGoodsListGuid, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDataStore extends GeneratedDatabase {
  _$AppDataStore(QueryExecutor e) : super(e);
  $AppDataStoreManager get managers => $AppDataStoreManager(this);
  late final $UsersTable users = $UsersTable(this);
  late final $PrefsTable prefs = $PrefsTable(this);
  late final $BuyersTable buyers = $BuyersTable(this);
  late final $PartnersTable partners = $PartnersTable(this);
  late final $LocationsTable locations = $LocationsTable(this);
  late final $PointFormatsTable pointFormats = $PointFormatsTable(this);
  late final $PointsTable points = $PointsTable(this);
  late final $PointImagesTable pointImages = $PointImagesTable(this);
  late final $PreEncashmentsTable preEncashments = $PreEncashmentsTable(this);
  late final $DebtsTable debts = $DebtsTable(this);
  late final $DepositsTable deposits = $DepositsTable(this);
  late final $ShipmentsTable shipments = $ShipmentsTable(this);
  late final $ShipmentLinesTable shipmentLines = $ShipmentLinesTable(this);
  late final $IncRequestsTable incRequests = $IncRequestsTable(this);
  late final $AllGoodsTable allGoods = $AllGoodsTable(this);
  late final $WorkdatesTable workdates = $WorkdatesTable(this);
  late final $ShopDepartmentsTable shopDepartments =
      $ShopDepartmentsTable(this);
  late final $CategoriesTable categories = $CategoriesTable(this);
  late final $GoodsFiltersTable goodsFilters = $GoodsFiltersTable(this);
  late final $OrdersTable orders = $OrdersTable(this);
  late final $OrderLinesTable orderLines = $OrderLinesTable(this);
  late final $PreOrdersTable preOrders = $PreOrdersTable(this);
  late final $PreOrderLinesTable preOrderLines = $PreOrderLinesTable(this);
  late final $SeenPreOrdersTable seenPreOrders = $SeenPreOrdersTable(this);
  late final $BonusProgramGroupsTable bonusProgramGroups =
      $BonusProgramGroupsTable(this);
  late final $BonusProgramsTable bonusPrograms = $BonusProgramsTable(this);
  late final $BuyersSetsTable buyersSets = $BuyersSetsTable(this);
  late final $BuyersSetsBonusProgramsTable buyersSetsBonusPrograms =
      $BuyersSetsBonusProgramsTable(this);
  late final $BuyersSetsBuyersTable buyersSetsBuyers =
      $BuyersSetsBuyersTable(this);
  late final $GoodsBonusProgramsTable goodsBonusPrograms =
      $GoodsBonusProgramsTable(this);
  late final $GoodsBonusProgramPricesTable goodsBonusProgramPrices =
      $GoodsBonusProgramPricesTable(this);
  late final $PricelistsTable pricelists = $PricelistsTable(this);
  late final $PricelistSetCategoriesTable pricelistSetCategories =
      $PricelistSetCategoriesTable(this);
  late final $PartnersPricesTable partnersPrices = $PartnersPricesTable(this);
  late final $PricelistPricesTable pricelistPrices =
      $PricelistPricesTable(this);
  late final $PartnersPricelistsTable partnersPricelists =
      $PartnersPricelistsTable(this);
  late final $GoodsRestrictionsTable goodsRestrictions =
      $GoodsRestrictionsTable(this);
  late final $GoodsStocksTable goodsStocks = $GoodsStocksTable(this);
  late final $GoodsPartnersPricelistsTable goodsPartnersPricelists =
      $GoodsPartnersPricelistsTable(this);
  late final $GoodsReturnStocksTable goodsReturnStocks =
      $GoodsReturnStocksTable(this);
  late final $ReturnActsTable returnActs = $ReturnActsTable(this);
  late final $ReturnActLinesTable returnActLines = $ReturnActLinesTable(this);
  late final $ReturnActTypesTable returnActTypes = $ReturnActTypesTable(this);
  late final $PartnersReturnActTypesTable partnersReturnActTypes =
      $PartnersReturnActTypesTable(this);
  late final $RoutePointsTable routePoints = $RoutePointsTable(this);
  late final $VisitSkipReasonsTable visitSkipReasons =
      $VisitSkipReasonsTable(this);
  late final $VisitsTable visits = $VisitsTable(this);
  late final $SitesTable sites = $SitesTable(this);
  late final $NtDeptTypesTable ntDeptTypes = $NtDeptTypesTable(this);
  late final $GoodsListsTable goodsLists = $GoodsListsTable(this);
  late final $AllGoodsListGoodsTable allGoodsListGoods =
      $AllGoodsListGoodsTable(this);
  late final $VisitImagesTable visitImages = $VisitImagesTable(this);
  late final $VisitSoftwaresTable visitSoftwares = $VisitSoftwaresTable(this);
  late final $VisitGoodsListsTable visitGoodsLists =
      $VisitGoodsListsTable(this);
  late final $AllVisitGoodsListGoodsTable allVisitGoodsListGoods =
      $AllVisitGoodsListGoodsTable(this);
  late final BonusProgramsDao bonusProgramsDao =
      BonusProgramsDao(this as AppDataStore);
  late final DebtsDao debtsDao = DebtsDao(this as AppDataStore);
  late final OrdersDao ordersDao = OrdersDao(this as AppDataStore);
  late final PartnersDao partnersDao = PartnersDao(this as AppDataStore);
  late final PointsDao pointsDao = PointsDao(this as AppDataStore);
  late final PricesDao pricesDao = PricesDao(this as AppDataStore);
  late final ShipmentsDao shipmentsDao = ShipmentsDao(this as AppDataStore);
  late final ReturnActsDao returnActsDao = ReturnActsDao(this as AppDataStore);
  late final UsersDao usersDao = UsersDao(this as AppDataStore);
  late final VisitsDao visitsDao = VisitsDao(this as AppDataStore);
  Selectable<AppInfoResult> appInfo() {
    return customSelect(
        'SELECT prefs.*, (SELECT COUNT(*) FROM points WHERE need_sync = 1 OR EXISTS (SELECT 1 FROM point_images WHERE point_guid = points.guid AND need_sync = 1)) AS points_to_sync, (SELECT COUNT(*) FROM orders WHERE need_sync = 1 OR EXISTS (SELECT 1 FROM order_lines WHERE order_guid = orders.guid AND need_sync = 1)) AS orders_to_sync, (SELECT COUNT(*) FROM return_acts WHERE need_sync = 1 OR EXISTS (SELECT 1 FROM return_act_lines WHERE return_act_guid = return_acts.guid AND need_sync = 1)) AS return_acts_to_sync, (SELECT COUNT(*) FROM pre_encashments WHERE need_sync = 1) AS pre_encashments_to_sync, (SELECT COUNT(*) FROM inc_requests WHERE need_sync = 1) AS inc_requests_to_sync, (SELECT COUNT(*) FROM partners_prices WHERE need_sync = 1) AS partner_prices_to_sync, (SELECT COUNT(*) FROM partners_pricelists WHERE need_sync = 1) AS partners_pricelists_to_sync, (SELECT COUNT(*) FROM route_points) AS route_points_total, (SELECT COUNT(*) FROM points) AS points_total, (SELECT COUNT(*) FROM pre_encashments) AS pre_encashments_total, (SELECT COUNT(*) FROM shipments) AS shipments_total, (SELECT COUNT(*) FROM orders) AS orders_total, (SELECT COUNT(*) FROM pre_orders) AS pre_orders_total, (SELECT COUNT(*) FROM return_acts) AS return_acts_total FROM prefs',
        variables: [],
        readsFrom: {
          points,
          pointImages,
          orders,
          orderLines,
          returnActs,
          returnActLines,
          preEncashments,
          incRequests,
          partnersPrices,
          partnersPricelists,
          routePoints,
          shipments,
          preOrders,
          prefs,
        }).map((QueryRow row) => AppInfoResult(
          showLocalImage: row.read<bool>('show_local_image'),
          showWithPrice: row.read<bool>('show_with_price'),
          lastLoadTime: row.readNullable<DateTime>('last_load_time'),
          pointsToSync: row.read<int>('points_to_sync'),
          ordersToSync: row.read<int>('orders_to_sync'),
          returnActsToSync: row.read<int>('return_acts_to_sync'),
          preEncashmentsToSync: row.read<int>('pre_encashments_to_sync'),
          incRequestsToSync: row.read<int>('inc_requests_to_sync'),
          partnerPricesToSync: row.read<int>('partner_prices_to_sync'),
          partnersPricelistsToSync:
              row.read<int>('partners_pricelists_to_sync'),
          routePointsTotal: row.read<int>('route_points_total'),
          pointsTotal: row.read<int>('points_total'),
          preEncashmentsTotal: row.read<int>('pre_encashments_total'),
          shipmentsTotal: row.read<int>('shipments_total'),
          ordersTotal: row.read<int>('orders_total'),
          preOrdersTotal: row.read<int>('pre_orders_total'),
          returnActsTotal: row.read<int>('return_acts_total'),
        ));
  }

  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
        users,
        prefs,
        buyers,
        partners,
        locations,
        pointFormats,
        points,
        pointImages,
        preEncashments,
        debts,
        deposits,
        shipments,
        shipmentLines,
        incRequests,
        allGoods,
        workdates,
        shopDepartments,
        categories,
        goodsFilters,
        orders,
        orderLines,
        preOrders,
        preOrderLines,
        seenPreOrders,
        bonusProgramGroups,
        bonusPrograms,
        buyersSets,
        buyersSetsBonusPrograms,
        buyersSetsBuyers,
        goodsBonusPrograms,
        goodsBonusProgramPrices,
        pricelists,
        pricelistSetCategories,
        partnersPrices,
        pricelistPrices,
        partnersPricelists,
        goodsRestrictions,
        goodsStocks,
        goodsPartnersPricelists,
        goodsReturnStocks,
        returnActs,
        returnActLines,
        returnActTypes,
        partnersReturnActTypes,
        routePoints,
        visitSkipReasons,
        visits,
        sites,
        ntDeptTypes,
        goodsLists,
        allGoodsListGoods,
        visitImages,
        visitSoftwares,
        visitGoodsLists,
        allVisitGoodsListGoods
      ];
  @override
  StreamQueryUpdateRules get streamUpdateRules => const StreamQueryUpdateRules(
        [
          WritePropagation(
            on: TableUpdateQuery.onTableName('points',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('point_images', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('points',
                limitUpdateKind: UpdateKind.update),
            result: [
              TableUpdate('point_images', kind: UpdateKind.update),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('orders',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('order_lines', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('orders',
                limitUpdateKind: UpdateKind.update),
            result: [
              TableUpdate('order_lines', kind: UpdateKind.update),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('return_acts',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('return_act_lines', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('return_acts',
                limitUpdateKind: UpdateKind.update),
            result: [
              TableUpdate('return_act_lines', kind: UpdateKind.update),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('visits',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('visit_images', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('visits',
                limitUpdateKind: UpdateKind.update),
            result: [
              TableUpdate('visit_images', kind: UpdateKind.update),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('visits',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('visit_softwares', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('visits',
                limitUpdateKind: UpdateKind.update),
            result: [
              TableUpdate('visit_softwares', kind: UpdateKind.update),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('visits',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('visit_goods_lists', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('visits',
                limitUpdateKind: UpdateKind.update),
            result: [
              TableUpdate('visit_goods_lists', kind: UpdateKind.update),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('visit_goods_lists',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('visit_goods_list_goods', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('visit_goods_lists',
                limitUpdateKind: UpdateKind.update),
            result: [
              TableUpdate('visit_goods_list_goods', kind: UpdateKind.update),
            ],
          ),
        ],
      );
}

typedef $$UsersTableCreateCompanionBuilder = UsersCompanion Function({
  Value<int> id,
  required String username,
  required String salesmanName,
  required bool preOrderMode,
  required bool closed,
  required String email,
  required String version,
});
typedef $$UsersTableUpdateCompanionBuilder = UsersCompanion Function({
  Value<int> id,
  Value<String> username,
  Value<String> salesmanName,
  Value<bool> preOrderMode,
  Value<bool> closed,
  Value<String> email,
  Value<String> version,
});

class $$UsersTableFilterComposer extends Composer<_$AppDataStore, $UsersTable> {
  $$UsersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get username => $composableBuilder(
      column: $table.username, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get salesmanName => $composableBuilder(
      column: $table.salesmanName, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get preOrderMode => $composableBuilder(
      column: $table.preOrderMode, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get closed => $composableBuilder(
      column: $table.closed, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get email => $composableBuilder(
      column: $table.email, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get version => $composableBuilder(
      column: $table.version, builder: (column) => ColumnFilters(column));
}

class $$UsersTableOrderingComposer
    extends Composer<_$AppDataStore, $UsersTable> {
  $$UsersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get username => $composableBuilder(
      column: $table.username, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get salesmanName => $composableBuilder(
      column: $table.salesmanName,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get preOrderMode => $composableBuilder(
      column: $table.preOrderMode,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get closed => $composableBuilder(
      column: $table.closed, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get email => $composableBuilder(
      column: $table.email, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get version => $composableBuilder(
      column: $table.version, builder: (column) => ColumnOrderings(column));
}

class $$UsersTableAnnotationComposer
    extends Composer<_$AppDataStore, $UsersTable> {
  $$UsersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get username =>
      $composableBuilder(column: $table.username, builder: (column) => column);

  GeneratedColumn<String> get salesmanName => $composableBuilder(
      column: $table.salesmanName, builder: (column) => column);

  GeneratedColumn<bool> get preOrderMode => $composableBuilder(
      column: $table.preOrderMode, builder: (column) => column);

  GeneratedColumn<bool> get closed =>
      $composableBuilder(column: $table.closed, builder: (column) => column);

  GeneratedColumn<String> get email =>
      $composableBuilder(column: $table.email, builder: (column) => column);

  GeneratedColumn<String> get version =>
      $composableBuilder(column: $table.version, builder: (column) => column);
}

class $$UsersTableTableManager extends RootTableManager<
    _$AppDataStore,
    $UsersTable,
    User,
    $$UsersTableFilterComposer,
    $$UsersTableOrderingComposer,
    $$UsersTableAnnotationComposer,
    $$UsersTableCreateCompanionBuilder,
    $$UsersTableUpdateCompanionBuilder,
    (User, BaseReferences<_$AppDataStore, $UsersTable, User>),
    User,
    PrefetchHooks Function()> {
  $$UsersTableTableManager(_$AppDataStore db, $UsersTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$UsersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$UsersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$UsersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> username = const Value.absent(),
            Value<String> salesmanName = const Value.absent(),
            Value<bool> preOrderMode = const Value.absent(),
            Value<bool> closed = const Value.absent(),
            Value<String> email = const Value.absent(),
            Value<String> version = const Value.absent(),
          }) =>
              UsersCompanion(
            id: id,
            username: username,
            salesmanName: salesmanName,
            preOrderMode: preOrderMode,
            closed: closed,
            email: email,
            version: version,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String username,
            required String salesmanName,
            required bool preOrderMode,
            required bool closed,
            required String email,
            required String version,
          }) =>
              UsersCompanion.insert(
            id: id,
            username: username,
            salesmanName: salesmanName,
            preOrderMode: preOrderMode,
            closed: closed,
            email: email,
            version: version,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$UsersTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $UsersTable,
    User,
    $$UsersTableFilterComposer,
    $$UsersTableOrderingComposer,
    $$UsersTableAnnotationComposer,
    $$UsersTableCreateCompanionBuilder,
    $$UsersTableUpdateCompanionBuilder,
    (User, BaseReferences<_$AppDataStore, $UsersTable, User>),
    User,
    PrefetchHooks Function()>;
typedef $$PrefsTableCreateCompanionBuilder = PrefsCompanion Function({
  required bool showLocalImage,
  required bool showWithPrice,
  Value<DateTime?> lastLoadTime,
  Value<int> rowid,
});
typedef $$PrefsTableUpdateCompanionBuilder = PrefsCompanion Function({
  Value<bool> showLocalImage,
  Value<bool> showWithPrice,
  Value<DateTime?> lastLoadTime,
  Value<int> rowid,
});

class $$PrefsTableFilterComposer extends Composer<_$AppDataStore, $PrefsTable> {
  $$PrefsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get showLocalImage => $composableBuilder(
      column: $table.showLocalImage,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get showWithPrice => $composableBuilder(
      column: $table.showWithPrice, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastLoadTime => $composableBuilder(
      column: $table.lastLoadTime, builder: (column) => ColumnFilters(column));
}

class $$PrefsTableOrderingComposer
    extends Composer<_$AppDataStore, $PrefsTable> {
  $$PrefsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get showLocalImage => $composableBuilder(
      column: $table.showLocalImage,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get showWithPrice => $composableBuilder(
      column: $table.showWithPrice,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastLoadTime => $composableBuilder(
      column: $table.lastLoadTime,
      builder: (column) => ColumnOrderings(column));
}

class $$PrefsTableAnnotationComposer
    extends Composer<_$AppDataStore, $PrefsTable> {
  $$PrefsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get showLocalImage => $composableBuilder(
      column: $table.showLocalImage, builder: (column) => column);

  GeneratedColumn<bool> get showWithPrice => $composableBuilder(
      column: $table.showWithPrice, builder: (column) => column);

  GeneratedColumn<DateTime> get lastLoadTime => $composableBuilder(
      column: $table.lastLoadTime, builder: (column) => column);
}

class $$PrefsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $PrefsTable,
    Pref,
    $$PrefsTableFilterComposer,
    $$PrefsTableOrderingComposer,
    $$PrefsTableAnnotationComposer,
    $$PrefsTableCreateCompanionBuilder,
    $$PrefsTableUpdateCompanionBuilder,
    (Pref, BaseReferences<_$AppDataStore, $PrefsTable, Pref>),
    Pref,
    PrefetchHooks Function()> {
  $$PrefsTableTableManager(_$AppDataStore db, $PrefsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PrefsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PrefsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PrefsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<bool> showLocalImage = const Value.absent(),
            Value<bool> showWithPrice = const Value.absent(),
            Value<DateTime?> lastLoadTime = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              PrefsCompanion(
            showLocalImage: showLocalImage,
            showWithPrice: showWithPrice,
            lastLoadTime: lastLoadTime,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required bool showLocalImage,
            required bool showWithPrice,
            Value<DateTime?> lastLoadTime = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              PrefsCompanion.insert(
            showLocalImage: showLocalImage,
            showWithPrice: showWithPrice,
            lastLoadTime: lastLoadTime,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$PrefsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $PrefsTable,
    Pref,
    $$PrefsTableFilterComposer,
    $$PrefsTableOrderingComposer,
    $$PrefsTableAnnotationComposer,
    $$PrefsTableCreateCompanionBuilder,
    $$PrefsTableUpdateCompanionBuilder,
    (Pref, BaseReferences<_$AppDataStore, $PrefsTable, Pref>),
    Pref,
    PrefetchHooks Function()>;
typedef $$BuyersTableCreateCompanionBuilder = BuyersCompanion Function({
  Value<int> id,
  required String name,
  required String loadto,
  required int partnerId,
  required int siteId,
  Value<int?> pointId,
  required EqualList<bool> weekdays,
});
typedef $$BuyersTableUpdateCompanionBuilder = BuyersCompanion Function({
  Value<int> id,
  Value<String> name,
  Value<String> loadto,
  Value<int> partnerId,
  Value<int> siteId,
  Value<int?> pointId,
  Value<EqualList<bool>> weekdays,
});

class $$BuyersTableFilterComposer
    extends Composer<_$AppDataStore, $BuyersTable> {
  $$BuyersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get loadto => $composableBuilder(
      column: $table.loadto, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get partnerId => $composableBuilder(
      column: $table.partnerId, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get siteId => $composableBuilder(
      column: $table.siteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get pointId => $composableBuilder(
      column: $table.pointId, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<EqualList<bool>, EqualList<bool>, String>
      get weekdays => $composableBuilder(
          column: $table.weekdays,
          builder: (column) => ColumnWithTypeConverterFilters(column));
}

class $$BuyersTableOrderingComposer
    extends Composer<_$AppDataStore, $BuyersTable> {
  $$BuyersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get loadto => $composableBuilder(
      column: $table.loadto, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get partnerId => $composableBuilder(
      column: $table.partnerId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get siteId => $composableBuilder(
      column: $table.siteId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get pointId => $composableBuilder(
      column: $table.pointId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get weekdays => $composableBuilder(
      column: $table.weekdays, builder: (column) => ColumnOrderings(column));
}

class $$BuyersTableAnnotationComposer
    extends Composer<_$AppDataStore, $BuyersTable> {
  $$BuyersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get loadto =>
      $composableBuilder(column: $table.loadto, builder: (column) => column);

  GeneratedColumn<int> get partnerId =>
      $composableBuilder(column: $table.partnerId, builder: (column) => column);

  GeneratedColumn<int> get siteId =>
      $composableBuilder(column: $table.siteId, builder: (column) => column);

  GeneratedColumn<int> get pointId =>
      $composableBuilder(column: $table.pointId, builder: (column) => column);

  GeneratedColumnWithTypeConverter<EqualList<bool>, String> get weekdays =>
      $composableBuilder(column: $table.weekdays, builder: (column) => column);
}

class $$BuyersTableTableManager extends RootTableManager<
    _$AppDataStore,
    $BuyersTable,
    Buyer,
    $$BuyersTableFilterComposer,
    $$BuyersTableOrderingComposer,
    $$BuyersTableAnnotationComposer,
    $$BuyersTableCreateCompanionBuilder,
    $$BuyersTableUpdateCompanionBuilder,
    (Buyer, BaseReferences<_$AppDataStore, $BuyersTable, Buyer>),
    Buyer,
    PrefetchHooks Function()> {
  $$BuyersTableTableManager(_$AppDataStore db, $BuyersTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BuyersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BuyersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BuyersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String> loadto = const Value.absent(),
            Value<int> partnerId = const Value.absent(),
            Value<int> siteId = const Value.absent(),
            Value<int?> pointId = const Value.absent(),
            Value<EqualList<bool>> weekdays = const Value.absent(),
          }) =>
              BuyersCompanion(
            id: id,
            name: name,
            loadto: loadto,
            partnerId: partnerId,
            siteId: siteId,
            pointId: pointId,
            weekdays: weekdays,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String name,
            required String loadto,
            required int partnerId,
            required int siteId,
            Value<int?> pointId = const Value.absent(),
            required EqualList<bool> weekdays,
          }) =>
              BuyersCompanion.insert(
            id: id,
            name: name,
            loadto: loadto,
            partnerId: partnerId,
            siteId: siteId,
            pointId: pointId,
            weekdays: weekdays,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$BuyersTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $BuyersTable,
    Buyer,
    $$BuyersTableFilterComposer,
    $$BuyersTableOrderingComposer,
    $$BuyersTableAnnotationComposer,
    $$BuyersTableCreateCompanionBuilder,
    $$BuyersTableUpdateCompanionBuilder,
    (Buyer, BaseReferences<_$AppDataStore, $BuyersTable, Buyer>),
    Buyer,
    PrefetchHooks Function()>;
typedef $$PartnersTableCreateCompanionBuilder = PartnersCompanion Function({
  Value<int> id,
  required String name,
});
typedef $$PartnersTableUpdateCompanionBuilder = PartnersCompanion Function({
  Value<int> id,
  Value<String> name,
});

class $$PartnersTableFilterComposer
    extends Composer<_$AppDataStore, $PartnersTable> {
  $$PartnersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));
}

class $$PartnersTableOrderingComposer
    extends Composer<_$AppDataStore, $PartnersTable> {
  $$PartnersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));
}

class $$PartnersTableAnnotationComposer
    extends Composer<_$AppDataStore, $PartnersTable> {
  $$PartnersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);
}

class $$PartnersTableTableManager extends RootTableManager<
    _$AppDataStore,
    $PartnersTable,
    Partner,
    $$PartnersTableFilterComposer,
    $$PartnersTableOrderingComposer,
    $$PartnersTableAnnotationComposer,
    $$PartnersTableCreateCompanionBuilder,
    $$PartnersTableUpdateCompanionBuilder,
    (Partner, BaseReferences<_$AppDataStore, $PartnersTable, Partner>),
    Partner,
    PrefetchHooks Function()> {
  $$PartnersTableTableManager(_$AppDataStore db, $PartnersTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PartnersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PartnersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PartnersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> name = const Value.absent(),
          }) =>
              PartnersCompanion(
            id: id,
            name: name,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String name,
          }) =>
              PartnersCompanion.insert(
            id: id,
            name: name,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$PartnersTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $PartnersTable,
    Partner,
    $$PartnersTableFilterComposer,
    $$PartnersTableOrderingComposer,
    $$PartnersTableAnnotationComposer,
    $$PartnersTableCreateCompanionBuilder,
    $$PartnersTableUpdateCompanionBuilder,
    (Partner, BaseReferences<_$AppDataStore, $PartnersTable, Partner>),
    Partner,
    PrefetchHooks Function()>;
typedef $$LocationsTableCreateCompanionBuilder = LocationsCompanion Function({
  Value<int> id,
  required double latitude,
  required double longitude,
  required double accuracy,
  required double altitude,
  required double heading,
  required double speed,
  required DateTime timestamp,
  required int batteryLevel,
  required String batteryState,
});
typedef $$LocationsTableUpdateCompanionBuilder = LocationsCompanion Function({
  Value<int> id,
  Value<double> latitude,
  Value<double> longitude,
  Value<double> accuracy,
  Value<double> altitude,
  Value<double> heading,
  Value<double> speed,
  Value<DateTime> timestamp,
  Value<int> batteryLevel,
  Value<String> batteryState,
});

class $$LocationsTableFilterComposer
    extends Composer<_$AppDataStore, $LocationsTable> {
  $$LocationsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get latitude => $composableBuilder(
      column: $table.latitude, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get longitude => $composableBuilder(
      column: $table.longitude, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get accuracy => $composableBuilder(
      column: $table.accuracy, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get altitude => $composableBuilder(
      column: $table.altitude, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get heading => $composableBuilder(
      column: $table.heading, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get speed => $composableBuilder(
      column: $table.speed, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get batteryLevel => $composableBuilder(
      column: $table.batteryLevel, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get batteryState => $composableBuilder(
      column: $table.batteryState, builder: (column) => ColumnFilters(column));
}

class $$LocationsTableOrderingComposer
    extends Composer<_$AppDataStore, $LocationsTable> {
  $$LocationsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get latitude => $composableBuilder(
      column: $table.latitude, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get longitude => $composableBuilder(
      column: $table.longitude, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get accuracy => $composableBuilder(
      column: $table.accuracy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get altitude => $composableBuilder(
      column: $table.altitude, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get heading => $composableBuilder(
      column: $table.heading, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get speed => $composableBuilder(
      column: $table.speed, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get batteryLevel => $composableBuilder(
      column: $table.batteryLevel,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get batteryState => $composableBuilder(
      column: $table.batteryState,
      builder: (column) => ColumnOrderings(column));
}

class $$LocationsTableAnnotationComposer
    extends Composer<_$AppDataStore, $LocationsTable> {
  $$LocationsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get latitude =>
      $composableBuilder(column: $table.latitude, builder: (column) => column);

  GeneratedColumn<double> get longitude =>
      $composableBuilder(column: $table.longitude, builder: (column) => column);

  GeneratedColumn<double> get accuracy =>
      $composableBuilder(column: $table.accuracy, builder: (column) => column);

  GeneratedColumn<double> get altitude =>
      $composableBuilder(column: $table.altitude, builder: (column) => column);

  GeneratedColumn<double> get heading =>
      $composableBuilder(column: $table.heading, builder: (column) => column);

  GeneratedColumn<double> get speed =>
      $composableBuilder(column: $table.speed, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<int> get batteryLevel => $composableBuilder(
      column: $table.batteryLevel, builder: (column) => column);

  GeneratedColumn<String> get batteryState => $composableBuilder(
      column: $table.batteryState, builder: (column) => column);
}

class $$LocationsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $LocationsTable,
    Location,
    $$LocationsTableFilterComposer,
    $$LocationsTableOrderingComposer,
    $$LocationsTableAnnotationComposer,
    $$LocationsTableCreateCompanionBuilder,
    $$LocationsTableUpdateCompanionBuilder,
    (Location, BaseReferences<_$AppDataStore, $LocationsTable, Location>),
    Location,
    PrefetchHooks Function()> {
  $$LocationsTableTableManager(_$AppDataStore db, $LocationsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$LocationsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$LocationsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$LocationsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<double> latitude = const Value.absent(),
            Value<double> longitude = const Value.absent(),
            Value<double> accuracy = const Value.absent(),
            Value<double> altitude = const Value.absent(),
            Value<double> heading = const Value.absent(),
            Value<double> speed = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<int> batteryLevel = const Value.absent(),
            Value<String> batteryState = const Value.absent(),
          }) =>
              LocationsCompanion(
            id: id,
            latitude: latitude,
            longitude: longitude,
            accuracy: accuracy,
            altitude: altitude,
            heading: heading,
            speed: speed,
            timestamp: timestamp,
            batteryLevel: batteryLevel,
            batteryState: batteryState,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required double latitude,
            required double longitude,
            required double accuracy,
            required double altitude,
            required double heading,
            required double speed,
            required DateTime timestamp,
            required int batteryLevel,
            required String batteryState,
          }) =>
              LocationsCompanion.insert(
            id: id,
            latitude: latitude,
            longitude: longitude,
            accuracy: accuracy,
            altitude: altitude,
            heading: heading,
            speed: speed,
            timestamp: timestamp,
            batteryLevel: batteryLevel,
            batteryState: batteryState,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$LocationsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $LocationsTable,
    Location,
    $$LocationsTableFilterComposer,
    $$LocationsTableOrderingComposer,
    $$LocationsTableAnnotationComposer,
    $$LocationsTableCreateCompanionBuilder,
    $$LocationsTableUpdateCompanionBuilder,
    (Location, BaseReferences<_$AppDataStore, $LocationsTable, Location>),
    Location,
    PrefetchHooks Function()>;
typedef $$PointFormatsTableCreateCompanionBuilder = PointFormatsCompanion
    Function({
  Value<int> id,
  required String name,
});
typedef $$PointFormatsTableUpdateCompanionBuilder = PointFormatsCompanion
    Function({
  Value<int> id,
  Value<String> name,
});

class $$PointFormatsTableFilterComposer
    extends Composer<_$AppDataStore, $PointFormatsTable> {
  $$PointFormatsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));
}

class $$PointFormatsTableOrderingComposer
    extends Composer<_$AppDataStore, $PointFormatsTable> {
  $$PointFormatsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));
}

class $$PointFormatsTableAnnotationComposer
    extends Composer<_$AppDataStore, $PointFormatsTable> {
  $$PointFormatsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);
}

class $$PointFormatsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $PointFormatsTable,
    PointFormat,
    $$PointFormatsTableFilterComposer,
    $$PointFormatsTableOrderingComposer,
    $$PointFormatsTableAnnotationComposer,
    $$PointFormatsTableCreateCompanionBuilder,
    $$PointFormatsTableUpdateCompanionBuilder,
    (
      PointFormat,
      BaseReferences<_$AppDataStore, $PointFormatsTable, PointFormat>
    ),
    PointFormat,
    PrefetchHooks Function()> {
  $$PointFormatsTableTableManager(_$AppDataStore db, $PointFormatsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PointFormatsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PointFormatsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PointFormatsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> name = const Value.absent(),
          }) =>
              PointFormatsCompanion(
            id: id,
            name: name,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String name,
          }) =>
              PointFormatsCompanion.insert(
            id: id,
            name: name,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$PointFormatsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $PointFormatsTable,
    PointFormat,
    $$PointFormatsTableFilterComposer,
    $$PointFormatsTableOrderingComposer,
    $$PointFormatsTableAnnotationComposer,
    $$PointFormatsTableCreateCompanionBuilder,
    $$PointFormatsTableUpdateCompanionBuilder,
    (
      PointFormat,
      BaseReferences<_$AppDataStore, $PointFormatsTable, PointFormat>
    ),
    PointFormat,
    PrefetchHooks Function()>;
typedef $$PointsTableCreateCompanionBuilder = PointsCompanion Function({
  required String guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  required String name,
  Value<String?> address,
  required String buyerName,
  required String reason,
  Value<double?> latitude,
  Value<double?> longitude,
  Value<int?> pointFormat,
  Value<int?> numberOfCdesks,
  Value<String?> emailOnlineCheck,
  Value<String?> email,
  Value<String?> phoneOnlineCheck,
  Value<String?> inn,
  Value<String?> jur,
  Value<int?> plong,
  Value<int?> maxdebt,
  Value<int?> nds10,
  Value<int?> nds20,
  Value<String?> formsLink,
  Value<int?> ntDeptTypeId,
  Value<int> rowid,
});
typedef $$PointsTableUpdateCompanionBuilder = PointsCompanion Function({
  Value<String> guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  Value<String> name,
  Value<String?> address,
  Value<String> buyerName,
  Value<String> reason,
  Value<double?> latitude,
  Value<double?> longitude,
  Value<int?> pointFormat,
  Value<int?> numberOfCdesks,
  Value<String?> emailOnlineCheck,
  Value<String?> email,
  Value<String?> phoneOnlineCheck,
  Value<String?> inn,
  Value<String?> jur,
  Value<int?> plong,
  Value<int?> maxdebt,
  Value<int?> nds10,
  Value<int?> nds20,
  Value<String?> formsLink,
  Value<int?> ntDeptTypeId,
  Value<int> rowid,
});

final class $$PointsTableReferences
    extends BaseReferences<_$AppDataStore, $PointsTable, Point> {
  $$PointsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$PointImagesTable, List<PointImage>>
      _pointImagesRefsTable(_$AppDataStore db) => MultiTypedResultKey.fromTable(
          db.pointImages,
          aliasName:
              $_aliasNameGenerator(db.points.guid, db.pointImages.pointGuid));

  $$PointImagesTableProcessedTableManager get pointImagesRefs {
    final manager = $$PointImagesTableTableManager($_db, $_db.pointImages)
        .filter(
            (f) => f.pointGuid.guid.sqlEquals($_itemColumn<String>('guid')!));

    final cache = $_typedResult.readTableOrNull(_pointImagesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$PointsTableFilterComposer
    extends Composer<_$AppDataStore, $PointsTable> {
  $$PointsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get address => $composableBuilder(
      column: $table.address, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get buyerName => $composableBuilder(
      column: $table.buyerName, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get reason => $composableBuilder(
      column: $table.reason, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get latitude => $composableBuilder(
      column: $table.latitude, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get longitude => $composableBuilder(
      column: $table.longitude, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get pointFormat => $composableBuilder(
      column: $table.pointFormat, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get numberOfCdesks => $composableBuilder(
      column: $table.numberOfCdesks,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get emailOnlineCheck => $composableBuilder(
      column: $table.emailOnlineCheck,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get email => $composableBuilder(
      column: $table.email, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get phoneOnlineCheck => $composableBuilder(
      column: $table.phoneOnlineCheck,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get inn => $composableBuilder(
      column: $table.inn, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get jur => $composableBuilder(
      column: $table.jur, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get plong => $composableBuilder(
      column: $table.plong, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get maxdebt => $composableBuilder(
      column: $table.maxdebt, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get nds10 => $composableBuilder(
      column: $table.nds10, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get nds20 => $composableBuilder(
      column: $table.nds20, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get formsLink => $composableBuilder(
      column: $table.formsLink, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get ntDeptTypeId => $composableBuilder(
      column: $table.ntDeptTypeId, builder: (column) => ColumnFilters(column));

  Expression<bool> pointImagesRefs(
      Expression<bool> Function($$PointImagesTableFilterComposer f) f) {
    final $$PointImagesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.guid,
        referencedTable: $db.pointImages,
        getReferencedColumn: (t) => t.pointGuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$PointImagesTableFilterComposer(
              $db: $db,
              $table: $db.pointImages,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$PointsTableOrderingComposer
    extends Composer<_$AppDataStore, $PointsTable> {
  $$PointsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get address => $composableBuilder(
      column: $table.address, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get buyerName => $composableBuilder(
      column: $table.buyerName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get reason => $composableBuilder(
      column: $table.reason, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get latitude => $composableBuilder(
      column: $table.latitude, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get longitude => $composableBuilder(
      column: $table.longitude, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get pointFormat => $composableBuilder(
      column: $table.pointFormat, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get numberOfCdesks => $composableBuilder(
      column: $table.numberOfCdesks,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get emailOnlineCheck => $composableBuilder(
      column: $table.emailOnlineCheck,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get email => $composableBuilder(
      column: $table.email, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get phoneOnlineCheck => $composableBuilder(
      column: $table.phoneOnlineCheck,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get inn => $composableBuilder(
      column: $table.inn, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get jur => $composableBuilder(
      column: $table.jur, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get plong => $composableBuilder(
      column: $table.plong, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get maxdebt => $composableBuilder(
      column: $table.maxdebt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get nds10 => $composableBuilder(
      column: $table.nds10, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get nds20 => $composableBuilder(
      column: $table.nds20, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get formsLink => $composableBuilder(
      column: $table.formsLink, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get ntDeptTypeId => $composableBuilder(
      column: $table.ntDeptTypeId,
      builder: (column) => ColumnOrderings(column));
}

class $$PointsTableAnnotationComposer
    extends Composer<_$AppDataStore, $PointsTable> {
  $$PointsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get guid =>
      $composableBuilder(column: $table.guid, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => column);

  GeneratedColumn<bool> get needSync =>
      $composableBuilder(column: $table.needSync, builder: (column) => column);

  GeneratedColumn<bool> get isNew =>
      $composableBuilder(column: $table.isNew, builder: (column) => column);

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get address =>
      $composableBuilder(column: $table.address, builder: (column) => column);

  GeneratedColumn<String> get buyerName =>
      $composableBuilder(column: $table.buyerName, builder: (column) => column);

  GeneratedColumn<String> get reason =>
      $composableBuilder(column: $table.reason, builder: (column) => column);

  GeneratedColumn<double> get latitude =>
      $composableBuilder(column: $table.latitude, builder: (column) => column);

  GeneratedColumn<double> get longitude =>
      $composableBuilder(column: $table.longitude, builder: (column) => column);

  GeneratedColumn<int> get pointFormat => $composableBuilder(
      column: $table.pointFormat, builder: (column) => column);

  GeneratedColumn<int> get numberOfCdesks => $composableBuilder(
      column: $table.numberOfCdesks, builder: (column) => column);

  GeneratedColumn<String> get emailOnlineCheck => $composableBuilder(
      column: $table.emailOnlineCheck, builder: (column) => column);

  GeneratedColumn<String> get email =>
      $composableBuilder(column: $table.email, builder: (column) => column);

  GeneratedColumn<String> get phoneOnlineCheck => $composableBuilder(
      column: $table.phoneOnlineCheck, builder: (column) => column);

  GeneratedColumn<String> get inn =>
      $composableBuilder(column: $table.inn, builder: (column) => column);

  GeneratedColumn<String> get jur =>
      $composableBuilder(column: $table.jur, builder: (column) => column);

  GeneratedColumn<int> get plong =>
      $composableBuilder(column: $table.plong, builder: (column) => column);

  GeneratedColumn<int> get maxdebt =>
      $composableBuilder(column: $table.maxdebt, builder: (column) => column);

  GeneratedColumn<int> get nds10 =>
      $composableBuilder(column: $table.nds10, builder: (column) => column);

  GeneratedColumn<int> get nds20 =>
      $composableBuilder(column: $table.nds20, builder: (column) => column);

  GeneratedColumn<String> get formsLink =>
      $composableBuilder(column: $table.formsLink, builder: (column) => column);

  GeneratedColumn<int> get ntDeptTypeId => $composableBuilder(
      column: $table.ntDeptTypeId, builder: (column) => column);

  Expression<T> pointImagesRefs<T extends Object>(
      Expression<T> Function($$PointImagesTableAnnotationComposer a) f) {
    final $$PointImagesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.guid,
        referencedTable: $db.pointImages,
        getReferencedColumn: (t) => t.pointGuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$PointImagesTableAnnotationComposer(
              $db: $db,
              $table: $db.pointImages,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$PointsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $PointsTable,
    Point,
    $$PointsTableFilterComposer,
    $$PointsTableOrderingComposer,
    $$PointsTableAnnotationComposer,
    $$PointsTableCreateCompanionBuilder,
    $$PointsTableUpdateCompanionBuilder,
    (Point, $$PointsTableReferences),
    Point,
    PrefetchHooks Function({bool pointImagesRefs})> {
  $$PointsTableTableManager(_$AppDataStore db, $PointsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PointsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PointsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PointsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> guid = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String?> address = const Value.absent(),
            Value<String> buyerName = const Value.absent(),
            Value<String> reason = const Value.absent(),
            Value<double?> latitude = const Value.absent(),
            Value<double?> longitude = const Value.absent(),
            Value<int?> pointFormat = const Value.absent(),
            Value<int?> numberOfCdesks = const Value.absent(),
            Value<String?> emailOnlineCheck = const Value.absent(),
            Value<String?> email = const Value.absent(),
            Value<String?> phoneOnlineCheck = const Value.absent(),
            Value<String?> inn = const Value.absent(),
            Value<String?> jur = const Value.absent(),
            Value<int?> plong = const Value.absent(),
            Value<int?> maxdebt = const Value.absent(),
            Value<int?> nds10 = const Value.absent(),
            Value<int?> nds20 = const Value.absent(),
            Value<String?> formsLink = const Value.absent(),
            Value<int?> ntDeptTypeId = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              PointsCompanion(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            name: name,
            address: address,
            buyerName: buyerName,
            reason: reason,
            latitude: latitude,
            longitude: longitude,
            pointFormat: pointFormat,
            numberOfCdesks: numberOfCdesks,
            emailOnlineCheck: emailOnlineCheck,
            email: email,
            phoneOnlineCheck: phoneOnlineCheck,
            inn: inn,
            jur: jur,
            plong: plong,
            maxdebt: maxdebt,
            nds10: nds10,
            nds20: nds20,
            formsLink: formsLink,
            ntDeptTypeId: ntDeptTypeId,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String guid,
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            required String name,
            Value<String?> address = const Value.absent(),
            required String buyerName,
            required String reason,
            Value<double?> latitude = const Value.absent(),
            Value<double?> longitude = const Value.absent(),
            Value<int?> pointFormat = const Value.absent(),
            Value<int?> numberOfCdesks = const Value.absent(),
            Value<String?> emailOnlineCheck = const Value.absent(),
            Value<String?> email = const Value.absent(),
            Value<String?> phoneOnlineCheck = const Value.absent(),
            Value<String?> inn = const Value.absent(),
            Value<String?> jur = const Value.absent(),
            Value<int?> plong = const Value.absent(),
            Value<int?> maxdebt = const Value.absent(),
            Value<int?> nds10 = const Value.absent(),
            Value<int?> nds20 = const Value.absent(),
            Value<String?> formsLink = const Value.absent(),
            Value<int?> ntDeptTypeId = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              PointsCompanion.insert(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            name: name,
            address: address,
            buyerName: buyerName,
            reason: reason,
            latitude: latitude,
            longitude: longitude,
            pointFormat: pointFormat,
            numberOfCdesks: numberOfCdesks,
            emailOnlineCheck: emailOnlineCheck,
            email: email,
            phoneOnlineCheck: phoneOnlineCheck,
            inn: inn,
            jur: jur,
            plong: plong,
            maxdebt: maxdebt,
            nds10: nds10,
            nds20: nds20,
            formsLink: formsLink,
            ntDeptTypeId: ntDeptTypeId,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $$PointsTableReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: ({pointImagesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (pointImagesRefs) db.pointImages],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (pointImagesRefs)
                    await $_getPrefetchedData(
                        currentTable: table,
                        referencedTable:
                            $$PointsTableReferences._pointImagesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$PointsTableReferences(db, table, p0)
                                .pointImagesRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.pointGuid == item.guid),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$PointsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $PointsTable,
    Point,
    $$PointsTableFilterComposer,
    $$PointsTableOrderingComposer,
    $$PointsTableAnnotationComposer,
    $$PointsTableCreateCompanionBuilder,
    $$PointsTableUpdateCompanionBuilder,
    (Point, $$PointsTableReferences),
    Point,
    PrefetchHooks Function({bool pointImagesRefs})>;
typedef $$PointImagesTableCreateCompanionBuilder = PointImagesCompanion
    Function({
  required String guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  required double latitude,
  required double longitude,
  required double accuracy,
  required String imageUrl,
  required String imageKey,
  Value<int?> id,
  required String pointGuid,
  Value<int> rowid,
});
typedef $$PointImagesTableUpdateCompanionBuilder = PointImagesCompanion
    Function({
  Value<String> guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<double> latitude,
  Value<double> longitude,
  Value<double> accuracy,
  Value<String> imageUrl,
  Value<String> imageKey,
  Value<int?> id,
  Value<String> pointGuid,
  Value<int> rowid,
});

final class $$PointImagesTableReferences
    extends BaseReferences<_$AppDataStore, $PointImagesTable, PointImage> {
  $$PointImagesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $PointsTable _pointGuidTable(_$AppDataStore db) =>
      db.points.createAlias(
          $_aliasNameGenerator(db.pointImages.pointGuid, db.points.guid));

  $$PointsTableProcessedTableManager get pointGuid {
    final $_column = $_itemColumn<String>('point_guid')!;

    final manager = $$PointsTableTableManager($_db, $_db.points)
        .filter((f) => f.guid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_pointGuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$PointImagesTableFilterComposer
    extends Composer<_$AppDataStore, $PointImagesTable> {
  $$PointImagesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get latitude => $composableBuilder(
      column: $table.latitude, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get longitude => $composableBuilder(
      column: $table.longitude, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get accuracy => $composableBuilder(
      column: $table.accuracy, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get imageUrl => $composableBuilder(
      column: $table.imageUrl, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get imageKey => $composableBuilder(
      column: $table.imageKey, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  $$PointsTableFilterComposer get pointGuid {
    final $$PointsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.pointGuid,
        referencedTable: $db.points,
        getReferencedColumn: (t) => t.guid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$PointsTableFilterComposer(
              $db: $db,
              $table: $db.points,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$PointImagesTableOrderingComposer
    extends Composer<_$AppDataStore, $PointImagesTable> {
  $$PointImagesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get latitude => $composableBuilder(
      column: $table.latitude, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get longitude => $composableBuilder(
      column: $table.longitude, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get accuracy => $composableBuilder(
      column: $table.accuracy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get imageUrl => $composableBuilder(
      column: $table.imageUrl, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get imageKey => $composableBuilder(
      column: $table.imageKey, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  $$PointsTableOrderingComposer get pointGuid {
    final $$PointsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.pointGuid,
        referencedTable: $db.points,
        getReferencedColumn: (t) => t.guid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$PointsTableOrderingComposer(
              $db: $db,
              $table: $db.points,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$PointImagesTableAnnotationComposer
    extends Composer<_$AppDataStore, $PointImagesTable> {
  $$PointImagesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get guid =>
      $composableBuilder(column: $table.guid, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => column);

  GeneratedColumn<bool> get needSync =>
      $composableBuilder(column: $table.needSync, builder: (column) => column);

  GeneratedColumn<bool> get isNew =>
      $composableBuilder(column: $table.isNew, builder: (column) => column);

  GeneratedColumn<double> get latitude =>
      $composableBuilder(column: $table.latitude, builder: (column) => column);

  GeneratedColumn<double> get longitude =>
      $composableBuilder(column: $table.longitude, builder: (column) => column);

  GeneratedColumn<double> get accuracy =>
      $composableBuilder(column: $table.accuracy, builder: (column) => column);

  GeneratedColumn<String> get imageUrl =>
      $composableBuilder(column: $table.imageUrl, builder: (column) => column);

  GeneratedColumn<String> get imageKey =>
      $composableBuilder(column: $table.imageKey, builder: (column) => column);

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  $$PointsTableAnnotationComposer get pointGuid {
    final $$PointsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.pointGuid,
        referencedTable: $db.points,
        getReferencedColumn: (t) => t.guid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$PointsTableAnnotationComposer(
              $db: $db,
              $table: $db.points,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$PointImagesTableTableManager extends RootTableManager<
    _$AppDataStore,
    $PointImagesTable,
    PointImage,
    $$PointImagesTableFilterComposer,
    $$PointImagesTableOrderingComposer,
    $$PointImagesTableAnnotationComposer,
    $$PointImagesTableCreateCompanionBuilder,
    $$PointImagesTableUpdateCompanionBuilder,
    (PointImage, $$PointImagesTableReferences),
    PointImage,
    PrefetchHooks Function({bool pointGuid})> {
  $$PointImagesTableTableManager(_$AppDataStore db, $PointImagesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PointImagesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PointImagesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PointImagesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> guid = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<double> latitude = const Value.absent(),
            Value<double> longitude = const Value.absent(),
            Value<double> accuracy = const Value.absent(),
            Value<String> imageUrl = const Value.absent(),
            Value<String> imageKey = const Value.absent(),
            Value<int?> id = const Value.absent(),
            Value<String> pointGuid = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              PointImagesCompanion(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            latitude: latitude,
            longitude: longitude,
            accuracy: accuracy,
            imageUrl: imageUrl,
            imageKey: imageKey,
            id: id,
            pointGuid: pointGuid,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String guid,
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            required double latitude,
            required double longitude,
            required double accuracy,
            required String imageUrl,
            required String imageKey,
            Value<int?> id = const Value.absent(),
            required String pointGuid,
            Value<int> rowid = const Value.absent(),
          }) =>
              PointImagesCompanion.insert(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            latitude: latitude,
            longitude: longitude,
            accuracy: accuracy,
            imageUrl: imageUrl,
            imageKey: imageKey,
            id: id,
            pointGuid: pointGuid,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$PointImagesTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({pointGuid = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (pointGuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.pointGuid,
                    referencedTable:
                        $$PointImagesTableReferences._pointGuidTable(db),
                    referencedColumn:
                        $$PointImagesTableReferences._pointGuidTable(db).guid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$PointImagesTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $PointImagesTable,
    PointImage,
    $$PointImagesTableFilterComposer,
    $$PointImagesTableOrderingComposer,
    $$PointImagesTableAnnotationComposer,
    $$PointImagesTableCreateCompanionBuilder,
    $$PointImagesTableUpdateCompanionBuilder,
    (PointImage, $$PointImagesTableReferences),
    PointImage,
    PrefetchHooks Function({bool pointGuid})>;
typedef $$PreEncashmentsTableCreateCompanionBuilder = PreEncashmentsCompanion
    Function({
  required String guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  required DateTime date,
  required bool needReceipt,
  required int debtId,
  required int buyerId,
  Value<String?> info,
  Value<double?> encSum,
  Value<int> rowid,
});
typedef $$PreEncashmentsTableUpdateCompanionBuilder = PreEncashmentsCompanion
    Function({
  Value<String> guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  Value<DateTime> date,
  Value<bool> needReceipt,
  Value<int> debtId,
  Value<int> buyerId,
  Value<String?> info,
  Value<double?> encSum,
  Value<int> rowid,
});

class $$PreEncashmentsTableFilterComposer
    extends Composer<_$AppDataStore, $PreEncashmentsTable> {
  $$PreEncashmentsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needReceipt => $composableBuilder(
      column: $table.needReceipt, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get debtId => $composableBuilder(
      column: $table.debtId, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get info => $composableBuilder(
      column: $table.info, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get encSum => $composableBuilder(
      column: $table.encSum, builder: (column) => ColumnFilters(column));
}

class $$PreEncashmentsTableOrderingComposer
    extends Composer<_$AppDataStore, $PreEncashmentsTable> {
  $$PreEncashmentsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needReceipt => $composableBuilder(
      column: $table.needReceipt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get debtId => $composableBuilder(
      column: $table.debtId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get info => $composableBuilder(
      column: $table.info, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get encSum => $composableBuilder(
      column: $table.encSum, builder: (column) => ColumnOrderings(column));
}

class $$PreEncashmentsTableAnnotationComposer
    extends Composer<_$AppDataStore, $PreEncashmentsTable> {
  $$PreEncashmentsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get guid =>
      $composableBuilder(column: $table.guid, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => column);

  GeneratedColumn<bool> get needSync =>
      $composableBuilder(column: $table.needSync, builder: (column) => column);

  GeneratedColumn<bool> get isNew =>
      $composableBuilder(column: $table.isNew, builder: (column) => column);

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  GeneratedColumn<bool> get needReceipt => $composableBuilder(
      column: $table.needReceipt, builder: (column) => column);

  GeneratedColumn<int> get debtId =>
      $composableBuilder(column: $table.debtId, builder: (column) => column);

  GeneratedColumn<int> get buyerId =>
      $composableBuilder(column: $table.buyerId, builder: (column) => column);

  GeneratedColumn<String> get info =>
      $composableBuilder(column: $table.info, builder: (column) => column);

  GeneratedColumn<double> get encSum =>
      $composableBuilder(column: $table.encSum, builder: (column) => column);
}

class $$PreEncashmentsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $PreEncashmentsTable,
    PreEncashment,
    $$PreEncashmentsTableFilterComposer,
    $$PreEncashmentsTableOrderingComposer,
    $$PreEncashmentsTableAnnotationComposer,
    $$PreEncashmentsTableCreateCompanionBuilder,
    $$PreEncashmentsTableUpdateCompanionBuilder,
    (
      PreEncashment,
      BaseReferences<_$AppDataStore, $PreEncashmentsTable, PreEncashment>
    ),
    PreEncashment,
    PrefetchHooks Function()> {
  $$PreEncashmentsTableTableManager(
      _$AppDataStore db, $PreEncashmentsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PreEncashmentsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PreEncashmentsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PreEncashmentsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> guid = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            Value<DateTime> date = const Value.absent(),
            Value<bool> needReceipt = const Value.absent(),
            Value<int> debtId = const Value.absent(),
            Value<int> buyerId = const Value.absent(),
            Value<String?> info = const Value.absent(),
            Value<double?> encSum = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              PreEncashmentsCompanion(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            date: date,
            needReceipt: needReceipt,
            debtId: debtId,
            buyerId: buyerId,
            info: info,
            encSum: encSum,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String guid,
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            required DateTime date,
            required bool needReceipt,
            required int debtId,
            required int buyerId,
            Value<String?> info = const Value.absent(),
            Value<double?> encSum = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              PreEncashmentsCompanion.insert(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            date: date,
            needReceipt: needReceipt,
            debtId: debtId,
            buyerId: buyerId,
            info: info,
            encSum: encSum,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$PreEncashmentsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $PreEncashmentsTable,
    PreEncashment,
    $$PreEncashmentsTableFilterComposer,
    $$PreEncashmentsTableOrderingComposer,
    $$PreEncashmentsTableAnnotationComposer,
    $$PreEncashmentsTableCreateCompanionBuilder,
    $$PreEncashmentsTableUpdateCompanionBuilder,
    (
      PreEncashment,
      BaseReferences<_$AppDataStore, $PreEncashmentsTable, PreEncashment>
    ),
    PreEncashment,
    PrefetchHooks Function()>;
typedef $$DebtsTableCreateCompanionBuilder = DebtsCompanion Function({
  Value<int> id,
  required DateTime date,
  required int buyerId,
  Value<String?> info,
  required double debtSum,
  required double orderSum,
  required bool needReceipt,
  required DateTime dateUntil,
  required bool overdue,
});
typedef $$DebtsTableUpdateCompanionBuilder = DebtsCompanion Function({
  Value<int> id,
  Value<DateTime> date,
  Value<int> buyerId,
  Value<String?> info,
  Value<double> debtSum,
  Value<double> orderSum,
  Value<bool> needReceipt,
  Value<DateTime> dateUntil,
  Value<bool> overdue,
});

class $$DebtsTableFilterComposer extends Composer<_$AppDataStore, $DebtsTable> {
  $$DebtsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get info => $composableBuilder(
      column: $table.info, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get debtSum => $composableBuilder(
      column: $table.debtSum, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get orderSum => $composableBuilder(
      column: $table.orderSum, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needReceipt => $composableBuilder(
      column: $table.needReceipt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get dateUntil => $composableBuilder(
      column: $table.dateUntil, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get overdue => $composableBuilder(
      column: $table.overdue, builder: (column) => ColumnFilters(column));
}

class $$DebtsTableOrderingComposer
    extends Composer<_$AppDataStore, $DebtsTable> {
  $$DebtsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get info => $composableBuilder(
      column: $table.info, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get debtSum => $composableBuilder(
      column: $table.debtSum, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get orderSum => $composableBuilder(
      column: $table.orderSum, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needReceipt => $composableBuilder(
      column: $table.needReceipt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get dateUntil => $composableBuilder(
      column: $table.dateUntil, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get overdue => $composableBuilder(
      column: $table.overdue, builder: (column) => ColumnOrderings(column));
}

class $$DebtsTableAnnotationComposer
    extends Composer<_$AppDataStore, $DebtsTable> {
  $$DebtsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  GeneratedColumn<int> get buyerId =>
      $composableBuilder(column: $table.buyerId, builder: (column) => column);

  GeneratedColumn<String> get info =>
      $composableBuilder(column: $table.info, builder: (column) => column);

  GeneratedColumn<double> get debtSum =>
      $composableBuilder(column: $table.debtSum, builder: (column) => column);

  GeneratedColumn<double> get orderSum =>
      $composableBuilder(column: $table.orderSum, builder: (column) => column);

  GeneratedColumn<bool> get needReceipt => $composableBuilder(
      column: $table.needReceipt, builder: (column) => column);

  GeneratedColumn<DateTime> get dateUntil =>
      $composableBuilder(column: $table.dateUntil, builder: (column) => column);

  GeneratedColumn<bool> get overdue =>
      $composableBuilder(column: $table.overdue, builder: (column) => column);
}

class $$DebtsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $DebtsTable,
    Debt,
    $$DebtsTableFilterComposer,
    $$DebtsTableOrderingComposer,
    $$DebtsTableAnnotationComposer,
    $$DebtsTableCreateCompanionBuilder,
    $$DebtsTableUpdateCompanionBuilder,
    (Debt, BaseReferences<_$AppDataStore, $DebtsTable, Debt>),
    Debt,
    PrefetchHooks Function()> {
  $$DebtsTableTableManager(_$AppDataStore db, $DebtsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$DebtsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$DebtsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$DebtsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<DateTime> date = const Value.absent(),
            Value<int> buyerId = const Value.absent(),
            Value<String?> info = const Value.absent(),
            Value<double> debtSum = const Value.absent(),
            Value<double> orderSum = const Value.absent(),
            Value<bool> needReceipt = const Value.absent(),
            Value<DateTime> dateUntil = const Value.absent(),
            Value<bool> overdue = const Value.absent(),
          }) =>
              DebtsCompanion(
            id: id,
            date: date,
            buyerId: buyerId,
            info: info,
            debtSum: debtSum,
            orderSum: orderSum,
            needReceipt: needReceipt,
            dateUntil: dateUntil,
            overdue: overdue,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required DateTime date,
            required int buyerId,
            Value<String?> info = const Value.absent(),
            required double debtSum,
            required double orderSum,
            required bool needReceipt,
            required DateTime dateUntil,
            required bool overdue,
          }) =>
              DebtsCompanion.insert(
            id: id,
            date: date,
            buyerId: buyerId,
            info: info,
            debtSum: debtSum,
            orderSum: orderSum,
            needReceipt: needReceipt,
            dateUntil: dateUntil,
            overdue: overdue,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$DebtsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $DebtsTable,
    Debt,
    $$DebtsTableFilterComposer,
    $$DebtsTableOrderingComposer,
    $$DebtsTableAnnotationComposer,
    $$DebtsTableCreateCompanionBuilder,
    $$DebtsTableUpdateCompanionBuilder,
    (Debt, BaseReferences<_$AppDataStore, $DebtsTable, Debt>),
    Debt,
    PrefetchHooks Function()>;
typedef $$DepositsTableCreateCompanionBuilder = DepositsCompanion Function({
  required int id,
  required DateTime date,
  required double totalSum,
  required double checkTotalSum,
  Value<int> rowid,
});
typedef $$DepositsTableUpdateCompanionBuilder = DepositsCompanion Function({
  Value<int> id,
  Value<DateTime> date,
  Value<double> totalSum,
  Value<double> checkTotalSum,
  Value<int> rowid,
});

class $$DepositsTableFilterComposer
    extends Composer<_$AppDataStore, $DepositsTable> {
  $$DepositsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get totalSum => $composableBuilder(
      column: $table.totalSum, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get checkTotalSum => $composableBuilder(
      column: $table.checkTotalSum, builder: (column) => ColumnFilters(column));
}

class $$DepositsTableOrderingComposer
    extends Composer<_$AppDataStore, $DepositsTable> {
  $$DepositsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get totalSum => $composableBuilder(
      column: $table.totalSum, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get checkTotalSum => $composableBuilder(
      column: $table.checkTotalSum,
      builder: (column) => ColumnOrderings(column));
}

class $$DepositsTableAnnotationComposer
    extends Composer<_$AppDataStore, $DepositsTable> {
  $$DepositsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  GeneratedColumn<double> get totalSum =>
      $composableBuilder(column: $table.totalSum, builder: (column) => column);

  GeneratedColumn<double> get checkTotalSum => $composableBuilder(
      column: $table.checkTotalSum, builder: (column) => column);
}

class $$DepositsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $DepositsTable,
    Deposit,
    $$DepositsTableFilterComposer,
    $$DepositsTableOrderingComposer,
    $$DepositsTableAnnotationComposer,
    $$DepositsTableCreateCompanionBuilder,
    $$DepositsTableUpdateCompanionBuilder,
    (Deposit, BaseReferences<_$AppDataStore, $DepositsTable, Deposit>),
    Deposit,
    PrefetchHooks Function()> {
  $$DepositsTableTableManager(_$AppDataStore db, $DepositsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$DepositsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$DepositsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$DepositsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<DateTime> date = const Value.absent(),
            Value<double> totalSum = const Value.absent(),
            Value<double> checkTotalSum = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DepositsCompanion(
            id: id,
            date: date,
            totalSum: totalSum,
            checkTotalSum: checkTotalSum,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required int id,
            required DateTime date,
            required double totalSum,
            required double checkTotalSum,
            Value<int> rowid = const Value.absent(),
          }) =>
              DepositsCompanion.insert(
            id: id,
            date: date,
            totalSum: totalSum,
            checkTotalSum: checkTotalSum,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$DepositsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $DepositsTable,
    Deposit,
    $$DepositsTableFilterComposer,
    $$DepositsTableOrderingComposer,
    $$DepositsTableAnnotationComposer,
    $$DepositsTableCreateCompanionBuilder,
    $$DepositsTableUpdateCompanionBuilder,
    (Deposit, BaseReferences<_$AppDataStore, $DepositsTable, Deposit>),
    Deposit,
    PrefetchHooks Function()>;
typedef $$ShipmentsTableCreateCompanionBuilder = ShipmentsCompanion Function({
  Value<int> id,
  required DateTime date,
  required String ndoc,
  required String info,
  required String status,
  Value<double?> debtSum,
  required double shipmentSum,
  required int buyerId,
});
typedef $$ShipmentsTableUpdateCompanionBuilder = ShipmentsCompanion Function({
  Value<int> id,
  Value<DateTime> date,
  Value<String> ndoc,
  Value<String> info,
  Value<String> status,
  Value<double?> debtSum,
  Value<double> shipmentSum,
  Value<int> buyerId,
});

class $$ShipmentsTableFilterComposer
    extends Composer<_$AppDataStore, $ShipmentsTable> {
  $$ShipmentsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get ndoc => $composableBuilder(
      column: $table.ndoc, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get info => $composableBuilder(
      column: $table.info, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get debtSum => $composableBuilder(
      column: $table.debtSum, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get shipmentSum => $composableBuilder(
      column: $table.shipmentSum, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnFilters(column));
}

class $$ShipmentsTableOrderingComposer
    extends Composer<_$AppDataStore, $ShipmentsTable> {
  $$ShipmentsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get ndoc => $composableBuilder(
      column: $table.ndoc, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get info => $composableBuilder(
      column: $table.info, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get debtSum => $composableBuilder(
      column: $table.debtSum, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get shipmentSum => $composableBuilder(
      column: $table.shipmentSum, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnOrderings(column));
}

class $$ShipmentsTableAnnotationComposer
    extends Composer<_$AppDataStore, $ShipmentsTable> {
  $$ShipmentsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  GeneratedColumn<String> get ndoc =>
      $composableBuilder(column: $table.ndoc, builder: (column) => column);

  GeneratedColumn<String> get info =>
      $composableBuilder(column: $table.info, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<double> get debtSum =>
      $composableBuilder(column: $table.debtSum, builder: (column) => column);

  GeneratedColumn<double> get shipmentSum => $composableBuilder(
      column: $table.shipmentSum, builder: (column) => column);

  GeneratedColumn<int> get buyerId =>
      $composableBuilder(column: $table.buyerId, builder: (column) => column);
}

class $$ShipmentsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $ShipmentsTable,
    Shipment,
    $$ShipmentsTableFilterComposer,
    $$ShipmentsTableOrderingComposer,
    $$ShipmentsTableAnnotationComposer,
    $$ShipmentsTableCreateCompanionBuilder,
    $$ShipmentsTableUpdateCompanionBuilder,
    (Shipment, BaseReferences<_$AppDataStore, $ShipmentsTable, Shipment>),
    Shipment,
    PrefetchHooks Function()> {
  $$ShipmentsTableTableManager(_$AppDataStore db, $ShipmentsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ShipmentsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ShipmentsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ShipmentsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<DateTime> date = const Value.absent(),
            Value<String> ndoc = const Value.absent(),
            Value<String> info = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<double?> debtSum = const Value.absent(),
            Value<double> shipmentSum = const Value.absent(),
            Value<int> buyerId = const Value.absent(),
          }) =>
              ShipmentsCompanion(
            id: id,
            date: date,
            ndoc: ndoc,
            info: info,
            status: status,
            debtSum: debtSum,
            shipmentSum: shipmentSum,
            buyerId: buyerId,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required DateTime date,
            required String ndoc,
            required String info,
            required String status,
            Value<double?> debtSum = const Value.absent(),
            required double shipmentSum,
            required int buyerId,
          }) =>
              ShipmentsCompanion.insert(
            id: id,
            date: date,
            ndoc: ndoc,
            info: info,
            status: status,
            debtSum: debtSum,
            shipmentSum: shipmentSum,
            buyerId: buyerId,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$ShipmentsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $ShipmentsTable,
    Shipment,
    $$ShipmentsTableFilterComposer,
    $$ShipmentsTableOrderingComposer,
    $$ShipmentsTableAnnotationComposer,
    $$ShipmentsTableCreateCompanionBuilder,
    $$ShipmentsTableUpdateCompanionBuilder,
    (Shipment, BaseReferences<_$AppDataStore, $ShipmentsTable, Shipment>),
    Shipment,
    PrefetchHooks Function()>;
typedef $$ShipmentLinesTableCreateCompanionBuilder = ShipmentLinesCompanion
    Function({
  Value<int> id,
  required int shipmentId,
  required int goodsId,
  required double vol,
  required double price,
});
typedef $$ShipmentLinesTableUpdateCompanionBuilder = ShipmentLinesCompanion
    Function({
  Value<int> id,
  Value<int> shipmentId,
  Value<int> goodsId,
  Value<double> vol,
  Value<double> price,
});

class $$ShipmentLinesTableFilterComposer
    extends Composer<_$AppDataStore, $ShipmentLinesTable> {
  $$ShipmentLinesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get shipmentId => $composableBuilder(
      column: $table.shipmentId, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get vol => $composableBuilder(
      column: $table.vol, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnFilters(column));
}

class $$ShipmentLinesTableOrderingComposer
    extends Composer<_$AppDataStore, $ShipmentLinesTable> {
  $$ShipmentLinesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get shipmentId => $composableBuilder(
      column: $table.shipmentId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get vol => $composableBuilder(
      column: $table.vol, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnOrderings(column));
}

class $$ShipmentLinesTableAnnotationComposer
    extends Composer<_$AppDataStore, $ShipmentLinesTable> {
  $$ShipmentLinesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get shipmentId => $composableBuilder(
      column: $table.shipmentId, builder: (column) => column);

  GeneratedColumn<int> get goodsId =>
      $composableBuilder(column: $table.goodsId, builder: (column) => column);

  GeneratedColumn<double> get vol =>
      $composableBuilder(column: $table.vol, builder: (column) => column);

  GeneratedColumn<double> get price =>
      $composableBuilder(column: $table.price, builder: (column) => column);
}

class $$ShipmentLinesTableTableManager extends RootTableManager<
    _$AppDataStore,
    $ShipmentLinesTable,
    ShipmentLine,
    $$ShipmentLinesTableFilterComposer,
    $$ShipmentLinesTableOrderingComposer,
    $$ShipmentLinesTableAnnotationComposer,
    $$ShipmentLinesTableCreateCompanionBuilder,
    $$ShipmentLinesTableUpdateCompanionBuilder,
    (
      ShipmentLine,
      BaseReferences<_$AppDataStore, $ShipmentLinesTable, ShipmentLine>
    ),
    ShipmentLine,
    PrefetchHooks Function()> {
  $$ShipmentLinesTableTableManager(_$AppDataStore db, $ShipmentLinesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ShipmentLinesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ShipmentLinesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ShipmentLinesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<int> shipmentId = const Value.absent(),
            Value<int> goodsId = const Value.absent(),
            Value<double> vol = const Value.absent(),
            Value<double> price = const Value.absent(),
          }) =>
              ShipmentLinesCompanion(
            id: id,
            shipmentId: shipmentId,
            goodsId: goodsId,
            vol: vol,
            price: price,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required int shipmentId,
            required int goodsId,
            required double vol,
            required double price,
          }) =>
              ShipmentLinesCompanion.insert(
            id: id,
            shipmentId: shipmentId,
            goodsId: goodsId,
            vol: vol,
            price: price,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$ShipmentLinesTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $ShipmentLinesTable,
    ShipmentLine,
    $$ShipmentLinesTableFilterComposer,
    $$ShipmentLinesTableOrderingComposer,
    $$ShipmentLinesTableAnnotationComposer,
    $$ShipmentLinesTableCreateCompanionBuilder,
    $$ShipmentLinesTableUpdateCompanionBuilder,
    (
      ShipmentLine,
      BaseReferences<_$AppDataStore, $ShipmentLinesTable, ShipmentLine>
    ),
    ShipmentLine,
    PrefetchHooks Function()>;
typedef $$IncRequestsTableCreateCompanionBuilder = IncRequestsCompanion
    Function({
  required String guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  Value<DateTime?> date,
  Value<int?> buyerId,
  Value<double?> incSum,
  Value<String?> info,
  required String status,
  Value<int> rowid,
});
typedef $$IncRequestsTableUpdateCompanionBuilder = IncRequestsCompanion
    Function({
  Value<String> guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  Value<DateTime?> date,
  Value<int?> buyerId,
  Value<double?> incSum,
  Value<String?> info,
  Value<String> status,
  Value<int> rowid,
});

class $$IncRequestsTableFilterComposer
    extends Composer<_$AppDataStore, $IncRequestsTable> {
  $$IncRequestsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get incSum => $composableBuilder(
      column: $table.incSum, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get info => $composableBuilder(
      column: $table.info, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));
}

class $$IncRequestsTableOrderingComposer
    extends Composer<_$AppDataStore, $IncRequestsTable> {
  $$IncRequestsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get incSum => $composableBuilder(
      column: $table.incSum, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get info => $composableBuilder(
      column: $table.info, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));
}

class $$IncRequestsTableAnnotationComposer
    extends Composer<_$AppDataStore, $IncRequestsTable> {
  $$IncRequestsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get guid =>
      $composableBuilder(column: $table.guid, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => column);

  GeneratedColumn<bool> get needSync =>
      $composableBuilder(column: $table.needSync, builder: (column) => column);

  GeneratedColumn<bool> get isNew =>
      $composableBuilder(column: $table.isNew, builder: (column) => column);

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  GeneratedColumn<int> get buyerId =>
      $composableBuilder(column: $table.buyerId, builder: (column) => column);

  GeneratedColumn<double> get incSum =>
      $composableBuilder(column: $table.incSum, builder: (column) => column);

  GeneratedColumn<String> get info =>
      $composableBuilder(column: $table.info, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);
}

class $$IncRequestsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $IncRequestsTable,
    IncRequest,
    $$IncRequestsTableFilterComposer,
    $$IncRequestsTableOrderingComposer,
    $$IncRequestsTableAnnotationComposer,
    $$IncRequestsTableCreateCompanionBuilder,
    $$IncRequestsTableUpdateCompanionBuilder,
    (IncRequest, BaseReferences<_$AppDataStore, $IncRequestsTable, IncRequest>),
    IncRequest,
    PrefetchHooks Function()> {
  $$IncRequestsTableTableManager(_$AppDataStore db, $IncRequestsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$IncRequestsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$IncRequestsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$IncRequestsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> guid = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            Value<DateTime?> date = const Value.absent(),
            Value<int?> buyerId = const Value.absent(),
            Value<double?> incSum = const Value.absent(),
            Value<String?> info = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              IncRequestsCompanion(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            date: date,
            buyerId: buyerId,
            incSum: incSum,
            info: info,
            status: status,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String guid,
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            Value<DateTime?> date = const Value.absent(),
            Value<int?> buyerId = const Value.absent(),
            Value<double?> incSum = const Value.absent(),
            Value<String?> info = const Value.absent(),
            required String status,
            Value<int> rowid = const Value.absent(),
          }) =>
              IncRequestsCompanion.insert(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            date: date,
            buyerId: buyerId,
            incSum: incSum,
            info: info,
            status: status,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$IncRequestsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $IncRequestsTable,
    IncRequest,
    $$IncRequestsTableFilterComposer,
    $$IncRequestsTableOrderingComposer,
    $$IncRequestsTableAnnotationComposer,
    $$IncRequestsTableCreateCompanionBuilder,
    $$IncRequestsTableUpdateCompanionBuilder,
    (IncRequest, BaseReferences<_$AppDataStore, $IncRequestsTable, IncRequest>),
    IncRequest,
    PrefetchHooks Function()>;
typedef $$AllGoodsTableCreateCompanionBuilder = AllGoodsCompanion Function({
  required String imageUrl,
  required String imageKey,
  Value<int> id,
  required String name,
  required int categoryId,
  Value<String?> manufacturer,
  required bool isLatest,
  required bool isOrderable,
  required int pricelistSetId,
  required double cost,
  required double minPrice,
  required String extraLabel,
  required int orderRel,
  required int orderPackage,
  required int categoryBoxRel,
  required int categoryBlockRel,
  required double weight,
  required double volume,
  required bool forPhysical,
  required bool onlyWithDocs,
  required int shelfLife,
  required String shelfLifeTypeName,
  required EqualList<String> barcodes,
});
typedef $$AllGoodsTableUpdateCompanionBuilder = AllGoodsCompanion Function({
  Value<String> imageUrl,
  Value<String> imageKey,
  Value<int> id,
  Value<String> name,
  Value<int> categoryId,
  Value<String?> manufacturer,
  Value<bool> isLatest,
  Value<bool> isOrderable,
  Value<int> pricelistSetId,
  Value<double> cost,
  Value<double> minPrice,
  Value<String> extraLabel,
  Value<int> orderRel,
  Value<int> orderPackage,
  Value<int> categoryBoxRel,
  Value<int> categoryBlockRel,
  Value<double> weight,
  Value<double> volume,
  Value<bool> forPhysical,
  Value<bool> onlyWithDocs,
  Value<int> shelfLife,
  Value<String> shelfLifeTypeName,
  Value<EqualList<String>> barcodes,
});

class $$AllGoodsTableFilterComposer
    extends Composer<_$AppDataStore, $AllGoodsTable> {
  $$AllGoodsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get imageUrl => $composableBuilder(
      column: $table.imageUrl, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get imageKey => $composableBuilder(
      column: $table.imageKey, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get categoryId => $composableBuilder(
      column: $table.categoryId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get manufacturer => $composableBuilder(
      column: $table.manufacturer, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isLatest => $composableBuilder(
      column: $table.isLatest, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isOrderable => $composableBuilder(
      column: $table.isOrderable, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get pricelistSetId => $composableBuilder(
      column: $table.pricelistSetId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get cost => $composableBuilder(
      column: $table.cost, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get minPrice => $composableBuilder(
      column: $table.minPrice, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get extraLabel => $composableBuilder(
      column: $table.extraLabel, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get orderRel => $composableBuilder(
      column: $table.orderRel, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get orderPackage => $composableBuilder(
      column: $table.orderPackage, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get categoryBoxRel => $composableBuilder(
      column: $table.categoryBoxRel,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get categoryBlockRel => $composableBuilder(
      column: $table.categoryBlockRel,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get weight => $composableBuilder(
      column: $table.weight, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get volume => $composableBuilder(
      column: $table.volume, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get forPhysical => $composableBuilder(
      column: $table.forPhysical, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get onlyWithDocs => $composableBuilder(
      column: $table.onlyWithDocs, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get shelfLife => $composableBuilder(
      column: $table.shelfLife, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get shelfLifeTypeName => $composableBuilder(
      column: $table.shelfLifeTypeName,
      builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<EqualList<String>, EqualList<String>, String>
      get barcodes => $composableBuilder(
          column: $table.barcodes,
          builder: (column) => ColumnWithTypeConverterFilters(column));
}

class $$AllGoodsTableOrderingComposer
    extends Composer<_$AppDataStore, $AllGoodsTable> {
  $$AllGoodsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get imageUrl => $composableBuilder(
      column: $table.imageUrl, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get imageKey => $composableBuilder(
      column: $table.imageKey, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get categoryId => $composableBuilder(
      column: $table.categoryId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get manufacturer => $composableBuilder(
      column: $table.manufacturer,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isLatest => $composableBuilder(
      column: $table.isLatest, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isOrderable => $composableBuilder(
      column: $table.isOrderable, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get pricelistSetId => $composableBuilder(
      column: $table.pricelistSetId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get cost => $composableBuilder(
      column: $table.cost, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get minPrice => $composableBuilder(
      column: $table.minPrice, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get extraLabel => $composableBuilder(
      column: $table.extraLabel, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get orderRel => $composableBuilder(
      column: $table.orderRel, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get orderPackage => $composableBuilder(
      column: $table.orderPackage,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get categoryBoxRel => $composableBuilder(
      column: $table.categoryBoxRel,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get categoryBlockRel => $composableBuilder(
      column: $table.categoryBlockRel,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get weight => $composableBuilder(
      column: $table.weight, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get volume => $composableBuilder(
      column: $table.volume, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get forPhysical => $composableBuilder(
      column: $table.forPhysical, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get onlyWithDocs => $composableBuilder(
      column: $table.onlyWithDocs,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get shelfLife => $composableBuilder(
      column: $table.shelfLife, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get shelfLifeTypeName => $composableBuilder(
      column: $table.shelfLifeTypeName,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get barcodes => $composableBuilder(
      column: $table.barcodes, builder: (column) => ColumnOrderings(column));
}

class $$AllGoodsTableAnnotationComposer
    extends Composer<_$AppDataStore, $AllGoodsTable> {
  $$AllGoodsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get imageUrl =>
      $composableBuilder(column: $table.imageUrl, builder: (column) => column);

  GeneratedColumn<String> get imageKey =>
      $composableBuilder(column: $table.imageKey, builder: (column) => column);

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<int> get categoryId => $composableBuilder(
      column: $table.categoryId, builder: (column) => column);

  GeneratedColumn<String> get manufacturer => $composableBuilder(
      column: $table.manufacturer, builder: (column) => column);

  GeneratedColumn<bool> get isLatest =>
      $composableBuilder(column: $table.isLatest, builder: (column) => column);

  GeneratedColumn<bool> get isOrderable => $composableBuilder(
      column: $table.isOrderable, builder: (column) => column);

  GeneratedColumn<int> get pricelistSetId => $composableBuilder(
      column: $table.pricelistSetId, builder: (column) => column);

  GeneratedColumn<double> get cost =>
      $composableBuilder(column: $table.cost, builder: (column) => column);

  GeneratedColumn<double> get minPrice =>
      $composableBuilder(column: $table.minPrice, builder: (column) => column);

  GeneratedColumn<String> get extraLabel => $composableBuilder(
      column: $table.extraLabel, builder: (column) => column);

  GeneratedColumn<int> get orderRel =>
      $composableBuilder(column: $table.orderRel, builder: (column) => column);

  GeneratedColumn<int> get orderPackage => $composableBuilder(
      column: $table.orderPackage, builder: (column) => column);

  GeneratedColumn<int> get categoryBoxRel => $composableBuilder(
      column: $table.categoryBoxRel, builder: (column) => column);

  GeneratedColumn<int> get categoryBlockRel => $composableBuilder(
      column: $table.categoryBlockRel, builder: (column) => column);

  GeneratedColumn<double> get weight =>
      $composableBuilder(column: $table.weight, builder: (column) => column);

  GeneratedColumn<double> get volume =>
      $composableBuilder(column: $table.volume, builder: (column) => column);

  GeneratedColumn<bool> get forPhysical => $composableBuilder(
      column: $table.forPhysical, builder: (column) => column);

  GeneratedColumn<bool> get onlyWithDocs => $composableBuilder(
      column: $table.onlyWithDocs, builder: (column) => column);

  GeneratedColumn<int> get shelfLife =>
      $composableBuilder(column: $table.shelfLife, builder: (column) => column);

  GeneratedColumn<String> get shelfLifeTypeName => $composableBuilder(
      column: $table.shelfLifeTypeName, builder: (column) => column);

  GeneratedColumnWithTypeConverter<EqualList<String>, String> get barcodes =>
      $composableBuilder(column: $table.barcodes, builder: (column) => column);
}

class $$AllGoodsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $AllGoodsTable,
    Goods,
    $$AllGoodsTableFilterComposer,
    $$AllGoodsTableOrderingComposer,
    $$AllGoodsTableAnnotationComposer,
    $$AllGoodsTableCreateCompanionBuilder,
    $$AllGoodsTableUpdateCompanionBuilder,
    (Goods, BaseReferences<_$AppDataStore, $AllGoodsTable, Goods>),
    Goods,
    PrefetchHooks Function()> {
  $$AllGoodsTableTableManager(_$AppDataStore db, $AllGoodsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AllGoodsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AllGoodsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AllGoodsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> imageUrl = const Value.absent(),
            Value<String> imageKey = const Value.absent(),
            Value<int> id = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<int> categoryId = const Value.absent(),
            Value<String?> manufacturer = const Value.absent(),
            Value<bool> isLatest = const Value.absent(),
            Value<bool> isOrderable = const Value.absent(),
            Value<int> pricelistSetId = const Value.absent(),
            Value<double> cost = const Value.absent(),
            Value<double> minPrice = const Value.absent(),
            Value<String> extraLabel = const Value.absent(),
            Value<int> orderRel = const Value.absent(),
            Value<int> orderPackage = const Value.absent(),
            Value<int> categoryBoxRel = const Value.absent(),
            Value<int> categoryBlockRel = const Value.absent(),
            Value<double> weight = const Value.absent(),
            Value<double> volume = const Value.absent(),
            Value<bool> forPhysical = const Value.absent(),
            Value<bool> onlyWithDocs = const Value.absent(),
            Value<int> shelfLife = const Value.absent(),
            Value<String> shelfLifeTypeName = const Value.absent(),
            Value<EqualList<String>> barcodes = const Value.absent(),
          }) =>
              AllGoodsCompanion(
            imageUrl: imageUrl,
            imageKey: imageKey,
            id: id,
            name: name,
            categoryId: categoryId,
            manufacturer: manufacturer,
            isLatest: isLatest,
            isOrderable: isOrderable,
            pricelistSetId: pricelistSetId,
            cost: cost,
            minPrice: minPrice,
            extraLabel: extraLabel,
            orderRel: orderRel,
            orderPackage: orderPackage,
            categoryBoxRel: categoryBoxRel,
            categoryBlockRel: categoryBlockRel,
            weight: weight,
            volume: volume,
            forPhysical: forPhysical,
            onlyWithDocs: onlyWithDocs,
            shelfLife: shelfLife,
            shelfLifeTypeName: shelfLifeTypeName,
            barcodes: barcodes,
          ),
          createCompanionCallback: ({
            required String imageUrl,
            required String imageKey,
            Value<int> id = const Value.absent(),
            required String name,
            required int categoryId,
            Value<String?> manufacturer = const Value.absent(),
            required bool isLatest,
            required bool isOrderable,
            required int pricelistSetId,
            required double cost,
            required double minPrice,
            required String extraLabel,
            required int orderRel,
            required int orderPackage,
            required int categoryBoxRel,
            required int categoryBlockRel,
            required double weight,
            required double volume,
            required bool forPhysical,
            required bool onlyWithDocs,
            required int shelfLife,
            required String shelfLifeTypeName,
            required EqualList<String> barcodes,
          }) =>
              AllGoodsCompanion.insert(
            imageUrl: imageUrl,
            imageKey: imageKey,
            id: id,
            name: name,
            categoryId: categoryId,
            manufacturer: manufacturer,
            isLatest: isLatest,
            isOrderable: isOrderable,
            pricelistSetId: pricelistSetId,
            cost: cost,
            minPrice: minPrice,
            extraLabel: extraLabel,
            orderRel: orderRel,
            orderPackage: orderPackage,
            categoryBoxRel: categoryBoxRel,
            categoryBlockRel: categoryBlockRel,
            weight: weight,
            volume: volume,
            forPhysical: forPhysical,
            onlyWithDocs: onlyWithDocs,
            shelfLife: shelfLife,
            shelfLifeTypeName: shelfLifeTypeName,
            barcodes: barcodes,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$AllGoodsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $AllGoodsTable,
    Goods,
    $$AllGoodsTableFilterComposer,
    $$AllGoodsTableOrderingComposer,
    $$AllGoodsTableAnnotationComposer,
    $$AllGoodsTableCreateCompanionBuilder,
    $$AllGoodsTableUpdateCompanionBuilder,
    (Goods, BaseReferences<_$AppDataStore, $AllGoodsTable, Goods>),
    Goods,
    PrefetchHooks Function()>;
typedef $$WorkdatesTableCreateCompanionBuilder = WorkdatesCompanion Function({
  required DateTime date,
  Value<int> rowid,
});
typedef $$WorkdatesTableUpdateCompanionBuilder = WorkdatesCompanion Function({
  Value<DateTime> date,
  Value<int> rowid,
});

class $$WorkdatesTableFilterComposer
    extends Composer<_$AppDataStore, $WorkdatesTable> {
  $$WorkdatesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnFilters(column));
}

class $$WorkdatesTableOrderingComposer
    extends Composer<_$AppDataStore, $WorkdatesTable> {
  $$WorkdatesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnOrderings(column));
}

class $$WorkdatesTableAnnotationComposer
    extends Composer<_$AppDataStore, $WorkdatesTable> {
  $$WorkdatesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);
}

class $$WorkdatesTableTableManager extends RootTableManager<
    _$AppDataStore,
    $WorkdatesTable,
    Workdate,
    $$WorkdatesTableFilterComposer,
    $$WorkdatesTableOrderingComposer,
    $$WorkdatesTableAnnotationComposer,
    $$WorkdatesTableCreateCompanionBuilder,
    $$WorkdatesTableUpdateCompanionBuilder,
    (Workdate, BaseReferences<_$AppDataStore, $WorkdatesTable, Workdate>),
    Workdate,
    PrefetchHooks Function()> {
  $$WorkdatesTableTableManager(_$AppDataStore db, $WorkdatesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$WorkdatesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$WorkdatesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$WorkdatesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<DateTime> date = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              WorkdatesCompanion(
            date: date,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required DateTime date,
            Value<int> rowid = const Value.absent(),
          }) =>
              WorkdatesCompanion.insert(
            date: date,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$WorkdatesTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $WorkdatesTable,
    Workdate,
    $$WorkdatesTableFilterComposer,
    $$WorkdatesTableOrderingComposer,
    $$WorkdatesTableAnnotationComposer,
    $$WorkdatesTableCreateCompanionBuilder,
    $$WorkdatesTableUpdateCompanionBuilder,
    (Workdate, BaseReferences<_$AppDataStore, $WorkdatesTable, Workdate>),
    Workdate,
    PrefetchHooks Function()>;
typedef $$ShopDepartmentsTableCreateCompanionBuilder = ShopDepartmentsCompanion
    Function({
  Value<int> id,
  required String name,
  required int ord,
});
typedef $$ShopDepartmentsTableUpdateCompanionBuilder = ShopDepartmentsCompanion
    Function({
  Value<int> id,
  Value<String> name,
  Value<int> ord,
});

class $$ShopDepartmentsTableFilterComposer
    extends Composer<_$AppDataStore, $ShopDepartmentsTable> {
  $$ShopDepartmentsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get ord => $composableBuilder(
      column: $table.ord, builder: (column) => ColumnFilters(column));
}

class $$ShopDepartmentsTableOrderingComposer
    extends Composer<_$AppDataStore, $ShopDepartmentsTable> {
  $$ShopDepartmentsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get ord => $composableBuilder(
      column: $table.ord, builder: (column) => ColumnOrderings(column));
}

class $$ShopDepartmentsTableAnnotationComposer
    extends Composer<_$AppDataStore, $ShopDepartmentsTable> {
  $$ShopDepartmentsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<int> get ord =>
      $composableBuilder(column: $table.ord, builder: (column) => column);
}

class $$ShopDepartmentsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $ShopDepartmentsTable,
    ShopDepartment,
    $$ShopDepartmentsTableFilterComposer,
    $$ShopDepartmentsTableOrderingComposer,
    $$ShopDepartmentsTableAnnotationComposer,
    $$ShopDepartmentsTableCreateCompanionBuilder,
    $$ShopDepartmentsTableUpdateCompanionBuilder,
    (
      ShopDepartment,
      BaseReferences<_$AppDataStore, $ShopDepartmentsTable, ShopDepartment>
    ),
    ShopDepartment,
    PrefetchHooks Function()> {
  $$ShopDepartmentsTableTableManager(
      _$AppDataStore db, $ShopDepartmentsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ShopDepartmentsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ShopDepartmentsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ShopDepartmentsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<int> ord = const Value.absent(),
          }) =>
              ShopDepartmentsCompanion(
            id: id,
            name: name,
            ord: ord,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String name,
            required int ord,
          }) =>
              ShopDepartmentsCompanion.insert(
            id: id,
            name: name,
            ord: ord,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$ShopDepartmentsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $ShopDepartmentsTable,
    ShopDepartment,
    $$ShopDepartmentsTableFilterComposer,
    $$ShopDepartmentsTableOrderingComposer,
    $$ShopDepartmentsTableAnnotationComposer,
    $$ShopDepartmentsTableCreateCompanionBuilder,
    $$ShopDepartmentsTableUpdateCompanionBuilder,
    (
      ShopDepartment,
      BaseReferences<_$AppDataStore, $ShopDepartmentsTable, ShopDepartment>
    ),
    ShopDepartment,
    PrefetchHooks Function()>;
typedef $$CategoriesTableCreateCompanionBuilder = CategoriesCompanion Function({
  Value<int> id,
  required String name,
  required int ord,
  required int shopDepartmentId,
});
typedef $$CategoriesTableUpdateCompanionBuilder = CategoriesCompanion Function({
  Value<int> id,
  Value<String> name,
  Value<int> ord,
  Value<int> shopDepartmentId,
});

class $$CategoriesTableFilterComposer
    extends Composer<_$AppDataStore, $CategoriesTable> {
  $$CategoriesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get ord => $composableBuilder(
      column: $table.ord, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get shopDepartmentId => $composableBuilder(
      column: $table.shopDepartmentId,
      builder: (column) => ColumnFilters(column));
}

class $$CategoriesTableOrderingComposer
    extends Composer<_$AppDataStore, $CategoriesTable> {
  $$CategoriesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get ord => $composableBuilder(
      column: $table.ord, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get shopDepartmentId => $composableBuilder(
      column: $table.shopDepartmentId,
      builder: (column) => ColumnOrderings(column));
}

class $$CategoriesTableAnnotationComposer
    extends Composer<_$AppDataStore, $CategoriesTable> {
  $$CategoriesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<int> get ord =>
      $composableBuilder(column: $table.ord, builder: (column) => column);

  GeneratedColumn<int> get shopDepartmentId => $composableBuilder(
      column: $table.shopDepartmentId, builder: (column) => column);
}

class $$CategoriesTableTableManager extends RootTableManager<
    _$AppDataStore,
    $CategoriesTable,
    Category,
    $$CategoriesTableFilterComposer,
    $$CategoriesTableOrderingComposer,
    $$CategoriesTableAnnotationComposer,
    $$CategoriesTableCreateCompanionBuilder,
    $$CategoriesTableUpdateCompanionBuilder,
    (Category, BaseReferences<_$AppDataStore, $CategoriesTable, Category>),
    Category,
    PrefetchHooks Function()> {
  $$CategoriesTableTableManager(_$AppDataStore db, $CategoriesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CategoriesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CategoriesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CategoriesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<int> ord = const Value.absent(),
            Value<int> shopDepartmentId = const Value.absent(),
          }) =>
              CategoriesCompanion(
            id: id,
            name: name,
            ord: ord,
            shopDepartmentId: shopDepartmentId,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String name,
            required int ord,
            required int shopDepartmentId,
          }) =>
              CategoriesCompanion.insert(
            id: id,
            name: name,
            ord: ord,
            shopDepartmentId: shopDepartmentId,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$CategoriesTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $CategoriesTable,
    Category,
    $$CategoriesTableFilterComposer,
    $$CategoriesTableOrderingComposer,
    $$CategoriesTableAnnotationComposer,
    $$CategoriesTableCreateCompanionBuilder,
    $$CategoriesTableUpdateCompanionBuilder,
    (Category, BaseReferences<_$AppDataStore, $CategoriesTable, Category>),
    Category,
    PrefetchHooks Function()>;
typedef $$GoodsFiltersTableCreateCompanionBuilder = GoodsFiltersCompanion
    Function({
  Value<int> id,
  required String name,
  required String value,
});
typedef $$GoodsFiltersTableUpdateCompanionBuilder = GoodsFiltersCompanion
    Function({
  Value<int> id,
  Value<String> name,
  Value<String> value,
});

class $$GoodsFiltersTableFilterComposer
    extends Composer<_$AppDataStore, $GoodsFiltersTable> {
  $$GoodsFiltersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get value => $composableBuilder(
      column: $table.value, builder: (column) => ColumnFilters(column));
}

class $$GoodsFiltersTableOrderingComposer
    extends Composer<_$AppDataStore, $GoodsFiltersTable> {
  $$GoodsFiltersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get value => $composableBuilder(
      column: $table.value, builder: (column) => ColumnOrderings(column));
}

class $$GoodsFiltersTableAnnotationComposer
    extends Composer<_$AppDataStore, $GoodsFiltersTable> {
  $$GoodsFiltersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get value =>
      $composableBuilder(column: $table.value, builder: (column) => column);
}

class $$GoodsFiltersTableTableManager extends RootTableManager<
    _$AppDataStore,
    $GoodsFiltersTable,
    GoodsFilter,
    $$GoodsFiltersTableFilterComposer,
    $$GoodsFiltersTableOrderingComposer,
    $$GoodsFiltersTableAnnotationComposer,
    $$GoodsFiltersTableCreateCompanionBuilder,
    $$GoodsFiltersTableUpdateCompanionBuilder,
    (
      GoodsFilter,
      BaseReferences<_$AppDataStore, $GoodsFiltersTable, GoodsFilter>
    ),
    GoodsFilter,
    PrefetchHooks Function()> {
  $$GoodsFiltersTableTableManager(_$AppDataStore db, $GoodsFiltersTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$GoodsFiltersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$GoodsFiltersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$GoodsFiltersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String> value = const Value.absent(),
          }) =>
              GoodsFiltersCompanion(
            id: id,
            name: name,
            value: value,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String name,
            required String value,
          }) =>
              GoodsFiltersCompanion.insert(
            id: id,
            name: name,
            value: value,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$GoodsFiltersTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $GoodsFiltersTable,
    GoodsFilter,
    $$GoodsFiltersTableFilterComposer,
    $$GoodsFiltersTableOrderingComposer,
    $$GoodsFiltersTableAnnotationComposer,
    $$GoodsFiltersTableCreateCompanionBuilder,
    $$GoodsFiltersTableUpdateCompanionBuilder,
    (
      GoodsFilter,
      BaseReferences<_$AppDataStore, $GoodsFiltersTable, GoodsFilter>
    ),
    GoodsFilter,
    PrefetchHooks Function()>;
typedef $$OrdersTableCreateCompanionBuilder = OrdersCompanion Function({
  required String guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  Value<DateTime?> date,
  required String status,
  Value<int?> preOrderId,
  required bool needDocs,
  required bool needInc,
  required bool isPhysical,
  Value<int?> buyerId,
  Value<String?> info,
  required bool needProcessing,
  required bool isEditable,
  Value<int> rowid,
});
typedef $$OrdersTableUpdateCompanionBuilder = OrdersCompanion Function({
  Value<String> guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  Value<DateTime?> date,
  Value<String> status,
  Value<int?> preOrderId,
  Value<bool> needDocs,
  Value<bool> needInc,
  Value<bool> isPhysical,
  Value<int?> buyerId,
  Value<String?> info,
  Value<bool> needProcessing,
  Value<bool> isEditable,
  Value<int> rowid,
});

final class $$OrdersTableReferences
    extends BaseReferences<_$AppDataStore, $OrdersTable, Order> {
  $$OrdersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$OrderLinesTable, List<OrderLine>>
      _orderLinesRefsTable(_$AppDataStore db) => MultiTypedResultKey.fromTable(
          db.orderLines,
          aliasName:
              $_aliasNameGenerator(db.orders.guid, db.orderLines.orderGuid));

  $$OrderLinesTableProcessedTableManager get orderLinesRefs {
    final manager = $$OrderLinesTableTableManager($_db, $_db.orderLines).filter(
        (f) => f.orderGuid.guid.sqlEquals($_itemColumn<String>('guid')!));

    final cache = $_typedResult.readTableOrNull(_orderLinesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$OrdersTableFilterComposer
    extends Composer<_$AppDataStore, $OrdersTable> {
  $$OrdersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get preOrderId => $composableBuilder(
      column: $table.preOrderId, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needDocs => $composableBuilder(
      column: $table.needDocs, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needInc => $composableBuilder(
      column: $table.needInc, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isPhysical => $composableBuilder(
      column: $table.isPhysical, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get info => $composableBuilder(
      column: $table.info, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needProcessing => $composableBuilder(
      column: $table.needProcessing,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isEditable => $composableBuilder(
      column: $table.isEditable, builder: (column) => ColumnFilters(column));

  Expression<bool> orderLinesRefs(
      Expression<bool> Function($$OrderLinesTableFilterComposer f) f) {
    final $$OrderLinesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.guid,
        referencedTable: $db.orderLines,
        getReferencedColumn: (t) => t.orderGuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrderLinesTableFilterComposer(
              $db: $db,
              $table: $db.orderLines,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$OrdersTableOrderingComposer
    extends Composer<_$AppDataStore, $OrdersTable> {
  $$OrdersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get preOrderId => $composableBuilder(
      column: $table.preOrderId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needDocs => $composableBuilder(
      column: $table.needDocs, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needInc => $composableBuilder(
      column: $table.needInc, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isPhysical => $composableBuilder(
      column: $table.isPhysical, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get info => $composableBuilder(
      column: $table.info, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needProcessing => $composableBuilder(
      column: $table.needProcessing,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isEditable => $composableBuilder(
      column: $table.isEditable, builder: (column) => ColumnOrderings(column));
}

class $$OrdersTableAnnotationComposer
    extends Composer<_$AppDataStore, $OrdersTable> {
  $$OrdersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get guid =>
      $composableBuilder(column: $table.guid, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => column);

  GeneratedColumn<bool> get needSync =>
      $composableBuilder(column: $table.needSync, builder: (column) => column);

  GeneratedColumn<bool> get isNew =>
      $composableBuilder(column: $table.isNew, builder: (column) => column);

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<int> get preOrderId => $composableBuilder(
      column: $table.preOrderId, builder: (column) => column);

  GeneratedColumn<bool> get needDocs =>
      $composableBuilder(column: $table.needDocs, builder: (column) => column);

  GeneratedColumn<bool> get needInc =>
      $composableBuilder(column: $table.needInc, builder: (column) => column);

  GeneratedColumn<bool> get isPhysical => $composableBuilder(
      column: $table.isPhysical, builder: (column) => column);

  GeneratedColumn<int> get buyerId =>
      $composableBuilder(column: $table.buyerId, builder: (column) => column);

  GeneratedColumn<String> get info =>
      $composableBuilder(column: $table.info, builder: (column) => column);

  GeneratedColumn<bool> get needProcessing => $composableBuilder(
      column: $table.needProcessing, builder: (column) => column);

  GeneratedColumn<bool> get isEditable => $composableBuilder(
      column: $table.isEditable, builder: (column) => column);

  Expression<T> orderLinesRefs<T extends Object>(
      Expression<T> Function($$OrderLinesTableAnnotationComposer a) f) {
    final $$OrderLinesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.guid,
        referencedTable: $db.orderLines,
        getReferencedColumn: (t) => t.orderGuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrderLinesTableAnnotationComposer(
              $db: $db,
              $table: $db.orderLines,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$OrdersTableTableManager extends RootTableManager<
    _$AppDataStore,
    $OrdersTable,
    Order,
    $$OrdersTableFilterComposer,
    $$OrdersTableOrderingComposer,
    $$OrdersTableAnnotationComposer,
    $$OrdersTableCreateCompanionBuilder,
    $$OrdersTableUpdateCompanionBuilder,
    (Order, $$OrdersTableReferences),
    Order,
    PrefetchHooks Function({bool orderLinesRefs})> {
  $$OrdersTableTableManager(_$AppDataStore db, $OrdersTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OrdersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OrdersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OrdersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> guid = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            Value<DateTime?> date = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<int?> preOrderId = const Value.absent(),
            Value<bool> needDocs = const Value.absent(),
            Value<bool> needInc = const Value.absent(),
            Value<bool> isPhysical = const Value.absent(),
            Value<int?> buyerId = const Value.absent(),
            Value<String?> info = const Value.absent(),
            Value<bool> needProcessing = const Value.absent(),
            Value<bool> isEditable = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              OrdersCompanion(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            date: date,
            status: status,
            preOrderId: preOrderId,
            needDocs: needDocs,
            needInc: needInc,
            isPhysical: isPhysical,
            buyerId: buyerId,
            info: info,
            needProcessing: needProcessing,
            isEditable: isEditable,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String guid,
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            Value<DateTime?> date = const Value.absent(),
            required String status,
            Value<int?> preOrderId = const Value.absent(),
            required bool needDocs,
            required bool needInc,
            required bool isPhysical,
            Value<int?> buyerId = const Value.absent(),
            Value<String?> info = const Value.absent(),
            required bool needProcessing,
            required bool isEditable,
            Value<int> rowid = const Value.absent(),
          }) =>
              OrdersCompanion.insert(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            date: date,
            status: status,
            preOrderId: preOrderId,
            needDocs: needDocs,
            needInc: needInc,
            isPhysical: isPhysical,
            buyerId: buyerId,
            info: info,
            needProcessing: needProcessing,
            isEditable: isEditable,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $$OrdersTableReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: ({orderLinesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (orderLinesRefs) db.orderLines],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (orderLinesRefs)
                    await $_getPrefetchedData(
                        currentTable: table,
                        referencedTable:
                            $$OrdersTableReferences._orderLinesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$OrdersTableReferences(db, table, p0)
                                .orderLinesRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.orderGuid == item.guid),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$OrdersTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $OrdersTable,
    Order,
    $$OrdersTableFilterComposer,
    $$OrdersTableOrderingComposer,
    $$OrdersTableAnnotationComposer,
    $$OrdersTableCreateCompanionBuilder,
    $$OrdersTableUpdateCompanionBuilder,
    (Order, $$OrdersTableReferences),
    Order,
    PrefetchHooks Function({bool orderLinesRefs})>;
typedef $$OrderLinesTableCreateCompanionBuilder = OrderLinesCompanion Function({
  required String guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  required String orderGuid,
  required int goodsId,
  required double vol,
  required double price,
  required double priceOriginal,
  required int package,
  required int rel,
  Value<int> rowid,
});
typedef $$OrderLinesTableUpdateCompanionBuilder = OrderLinesCompanion Function({
  Value<String> guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  Value<String> orderGuid,
  Value<int> goodsId,
  Value<double> vol,
  Value<double> price,
  Value<double> priceOriginal,
  Value<int> package,
  Value<int> rel,
  Value<int> rowid,
});

final class $$OrderLinesTableReferences
    extends BaseReferences<_$AppDataStore, $OrderLinesTable, OrderLine> {
  $$OrderLinesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $OrdersTable _orderGuidTable(_$AppDataStore db) =>
      db.orders.createAlias(
          $_aliasNameGenerator(db.orderLines.orderGuid, db.orders.guid));

  $$OrdersTableProcessedTableManager get orderGuid {
    final $_column = $_itemColumn<String>('order_guid')!;

    final manager = $$OrdersTableTableManager($_db, $_db.orders)
        .filter((f) => f.guid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_orderGuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$OrderLinesTableFilterComposer
    extends Composer<_$AppDataStore, $OrderLinesTable> {
  $$OrderLinesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get vol => $composableBuilder(
      column: $table.vol, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get priceOriginal => $composableBuilder(
      column: $table.priceOriginal, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get package => $composableBuilder(
      column: $table.package, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get rel => $composableBuilder(
      column: $table.rel, builder: (column) => ColumnFilters(column));

  $$OrdersTableFilterComposer get orderGuid {
    final $$OrdersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orderGuid,
        referencedTable: $db.orders,
        getReferencedColumn: (t) => t.guid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrdersTableFilterComposer(
              $db: $db,
              $table: $db.orders,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$OrderLinesTableOrderingComposer
    extends Composer<_$AppDataStore, $OrderLinesTable> {
  $$OrderLinesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get vol => $composableBuilder(
      column: $table.vol, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get priceOriginal => $composableBuilder(
      column: $table.priceOriginal,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get package => $composableBuilder(
      column: $table.package, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get rel => $composableBuilder(
      column: $table.rel, builder: (column) => ColumnOrderings(column));

  $$OrdersTableOrderingComposer get orderGuid {
    final $$OrdersTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orderGuid,
        referencedTable: $db.orders,
        getReferencedColumn: (t) => t.guid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrdersTableOrderingComposer(
              $db: $db,
              $table: $db.orders,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$OrderLinesTableAnnotationComposer
    extends Composer<_$AppDataStore, $OrderLinesTable> {
  $$OrderLinesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get guid =>
      $composableBuilder(column: $table.guid, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => column);

  GeneratedColumn<bool> get needSync =>
      $composableBuilder(column: $table.needSync, builder: (column) => column);

  GeneratedColumn<bool> get isNew =>
      $composableBuilder(column: $table.isNew, builder: (column) => column);

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get goodsId =>
      $composableBuilder(column: $table.goodsId, builder: (column) => column);

  GeneratedColumn<double> get vol =>
      $composableBuilder(column: $table.vol, builder: (column) => column);

  GeneratedColumn<double> get price =>
      $composableBuilder(column: $table.price, builder: (column) => column);

  GeneratedColumn<double> get priceOriginal => $composableBuilder(
      column: $table.priceOriginal, builder: (column) => column);

  GeneratedColumn<int> get package =>
      $composableBuilder(column: $table.package, builder: (column) => column);

  GeneratedColumn<int> get rel =>
      $composableBuilder(column: $table.rel, builder: (column) => column);

  $$OrdersTableAnnotationComposer get orderGuid {
    final $$OrdersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orderGuid,
        referencedTable: $db.orders,
        getReferencedColumn: (t) => t.guid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrdersTableAnnotationComposer(
              $db: $db,
              $table: $db.orders,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$OrderLinesTableTableManager extends RootTableManager<
    _$AppDataStore,
    $OrderLinesTable,
    OrderLine,
    $$OrderLinesTableFilterComposer,
    $$OrderLinesTableOrderingComposer,
    $$OrderLinesTableAnnotationComposer,
    $$OrderLinesTableCreateCompanionBuilder,
    $$OrderLinesTableUpdateCompanionBuilder,
    (OrderLine, $$OrderLinesTableReferences),
    OrderLine,
    PrefetchHooks Function({bool orderGuid})> {
  $$OrderLinesTableTableManager(_$AppDataStore db, $OrderLinesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OrderLinesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OrderLinesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OrderLinesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> guid = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            Value<String> orderGuid = const Value.absent(),
            Value<int> goodsId = const Value.absent(),
            Value<double> vol = const Value.absent(),
            Value<double> price = const Value.absent(),
            Value<double> priceOriginal = const Value.absent(),
            Value<int> package = const Value.absent(),
            Value<int> rel = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              OrderLinesCompanion(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            orderGuid: orderGuid,
            goodsId: goodsId,
            vol: vol,
            price: price,
            priceOriginal: priceOriginal,
            package: package,
            rel: rel,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String guid,
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            required String orderGuid,
            required int goodsId,
            required double vol,
            required double price,
            required double priceOriginal,
            required int package,
            required int rel,
            Value<int> rowid = const Value.absent(),
          }) =>
              OrderLinesCompanion.insert(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            orderGuid: orderGuid,
            goodsId: goodsId,
            vol: vol,
            price: price,
            priceOriginal: priceOriginal,
            package: package,
            rel: rel,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$OrderLinesTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({orderGuid = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (orderGuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.orderGuid,
                    referencedTable:
                        $$OrderLinesTableReferences._orderGuidTable(db),
                    referencedColumn:
                        $$OrderLinesTableReferences._orderGuidTable(db).guid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$OrderLinesTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $OrderLinesTable,
    OrderLine,
    $$OrderLinesTableFilterComposer,
    $$OrderLinesTableOrderingComposer,
    $$OrderLinesTableAnnotationComposer,
    $$OrderLinesTableCreateCompanionBuilder,
    $$OrderLinesTableUpdateCompanionBuilder,
    (OrderLine, $$OrderLinesTableReferences),
    OrderLine,
    PrefetchHooks Function({bool orderGuid})>;
typedef $$PreOrdersTableCreateCompanionBuilder = PreOrdersCompanion Function({
  Value<int> id,
  required DateTime date,
  required int buyerId,
  required bool needDocs,
  Value<String?> info,
});
typedef $$PreOrdersTableUpdateCompanionBuilder = PreOrdersCompanion Function({
  Value<int> id,
  Value<DateTime> date,
  Value<int> buyerId,
  Value<bool> needDocs,
  Value<String?> info,
});

class $$PreOrdersTableFilterComposer
    extends Composer<_$AppDataStore, $PreOrdersTable> {
  $$PreOrdersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needDocs => $composableBuilder(
      column: $table.needDocs, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get info => $composableBuilder(
      column: $table.info, builder: (column) => ColumnFilters(column));
}

class $$PreOrdersTableOrderingComposer
    extends Composer<_$AppDataStore, $PreOrdersTable> {
  $$PreOrdersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needDocs => $composableBuilder(
      column: $table.needDocs, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get info => $composableBuilder(
      column: $table.info, builder: (column) => ColumnOrderings(column));
}

class $$PreOrdersTableAnnotationComposer
    extends Composer<_$AppDataStore, $PreOrdersTable> {
  $$PreOrdersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  GeneratedColumn<int> get buyerId =>
      $composableBuilder(column: $table.buyerId, builder: (column) => column);

  GeneratedColumn<bool> get needDocs =>
      $composableBuilder(column: $table.needDocs, builder: (column) => column);

  GeneratedColumn<String> get info =>
      $composableBuilder(column: $table.info, builder: (column) => column);
}

class $$PreOrdersTableTableManager extends RootTableManager<
    _$AppDataStore,
    $PreOrdersTable,
    PreOrder,
    $$PreOrdersTableFilterComposer,
    $$PreOrdersTableOrderingComposer,
    $$PreOrdersTableAnnotationComposer,
    $$PreOrdersTableCreateCompanionBuilder,
    $$PreOrdersTableUpdateCompanionBuilder,
    (PreOrder, BaseReferences<_$AppDataStore, $PreOrdersTable, PreOrder>),
    PreOrder,
    PrefetchHooks Function()> {
  $$PreOrdersTableTableManager(_$AppDataStore db, $PreOrdersTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PreOrdersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PreOrdersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PreOrdersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<DateTime> date = const Value.absent(),
            Value<int> buyerId = const Value.absent(),
            Value<bool> needDocs = const Value.absent(),
            Value<String?> info = const Value.absent(),
          }) =>
              PreOrdersCompanion(
            id: id,
            date: date,
            buyerId: buyerId,
            needDocs: needDocs,
            info: info,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required DateTime date,
            required int buyerId,
            required bool needDocs,
            Value<String?> info = const Value.absent(),
          }) =>
              PreOrdersCompanion.insert(
            id: id,
            date: date,
            buyerId: buyerId,
            needDocs: needDocs,
            info: info,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$PreOrdersTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $PreOrdersTable,
    PreOrder,
    $$PreOrdersTableFilterComposer,
    $$PreOrdersTableOrderingComposer,
    $$PreOrdersTableAnnotationComposer,
    $$PreOrdersTableCreateCompanionBuilder,
    $$PreOrdersTableUpdateCompanionBuilder,
    (PreOrder, BaseReferences<_$AppDataStore, $PreOrdersTable, PreOrder>),
    PreOrder,
    PrefetchHooks Function()>;
typedef $$PreOrderLinesTableCreateCompanionBuilder = PreOrderLinesCompanion
    Function({
  Value<int> id,
  required int preOrderId,
  required int goodsId,
  required double vol,
  required double price,
  required int package,
  required int rel,
});
typedef $$PreOrderLinesTableUpdateCompanionBuilder = PreOrderLinesCompanion
    Function({
  Value<int> id,
  Value<int> preOrderId,
  Value<int> goodsId,
  Value<double> vol,
  Value<double> price,
  Value<int> package,
  Value<int> rel,
});

class $$PreOrderLinesTableFilterComposer
    extends Composer<_$AppDataStore, $PreOrderLinesTable> {
  $$PreOrderLinesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get preOrderId => $composableBuilder(
      column: $table.preOrderId, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get vol => $composableBuilder(
      column: $table.vol, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get package => $composableBuilder(
      column: $table.package, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get rel => $composableBuilder(
      column: $table.rel, builder: (column) => ColumnFilters(column));
}

class $$PreOrderLinesTableOrderingComposer
    extends Composer<_$AppDataStore, $PreOrderLinesTable> {
  $$PreOrderLinesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get preOrderId => $composableBuilder(
      column: $table.preOrderId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get vol => $composableBuilder(
      column: $table.vol, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get package => $composableBuilder(
      column: $table.package, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get rel => $composableBuilder(
      column: $table.rel, builder: (column) => ColumnOrderings(column));
}

class $$PreOrderLinesTableAnnotationComposer
    extends Composer<_$AppDataStore, $PreOrderLinesTable> {
  $$PreOrderLinesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get preOrderId => $composableBuilder(
      column: $table.preOrderId, builder: (column) => column);

  GeneratedColumn<int> get goodsId =>
      $composableBuilder(column: $table.goodsId, builder: (column) => column);

  GeneratedColumn<double> get vol =>
      $composableBuilder(column: $table.vol, builder: (column) => column);

  GeneratedColumn<double> get price =>
      $composableBuilder(column: $table.price, builder: (column) => column);

  GeneratedColumn<int> get package =>
      $composableBuilder(column: $table.package, builder: (column) => column);

  GeneratedColumn<int> get rel =>
      $composableBuilder(column: $table.rel, builder: (column) => column);
}

class $$PreOrderLinesTableTableManager extends RootTableManager<
    _$AppDataStore,
    $PreOrderLinesTable,
    PreOrderLine,
    $$PreOrderLinesTableFilterComposer,
    $$PreOrderLinesTableOrderingComposer,
    $$PreOrderLinesTableAnnotationComposer,
    $$PreOrderLinesTableCreateCompanionBuilder,
    $$PreOrderLinesTableUpdateCompanionBuilder,
    (
      PreOrderLine,
      BaseReferences<_$AppDataStore, $PreOrderLinesTable, PreOrderLine>
    ),
    PreOrderLine,
    PrefetchHooks Function()> {
  $$PreOrderLinesTableTableManager(_$AppDataStore db, $PreOrderLinesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PreOrderLinesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PreOrderLinesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PreOrderLinesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<int> preOrderId = const Value.absent(),
            Value<int> goodsId = const Value.absent(),
            Value<double> vol = const Value.absent(),
            Value<double> price = const Value.absent(),
            Value<int> package = const Value.absent(),
            Value<int> rel = const Value.absent(),
          }) =>
              PreOrderLinesCompanion(
            id: id,
            preOrderId: preOrderId,
            goodsId: goodsId,
            vol: vol,
            price: price,
            package: package,
            rel: rel,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required int preOrderId,
            required int goodsId,
            required double vol,
            required double price,
            required int package,
            required int rel,
          }) =>
              PreOrderLinesCompanion.insert(
            id: id,
            preOrderId: preOrderId,
            goodsId: goodsId,
            vol: vol,
            price: price,
            package: package,
            rel: rel,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$PreOrderLinesTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $PreOrderLinesTable,
    PreOrderLine,
    $$PreOrderLinesTableFilterComposer,
    $$PreOrderLinesTableOrderingComposer,
    $$PreOrderLinesTableAnnotationComposer,
    $$PreOrderLinesTableCreateCompanionBuilder,
    $$PreOrderLinesTableUpdateCompanionBuilder,
    (
      PreOrderLine,
      BaseReferences<_$AppDataStore, $PreOrderLinesTable, PreOrderLine>
    ),
    PreOrderLine,
    PrefetchHooks Function()>;
typedef $$SeenPreOrdersTableCreateCompanionBuilder = SeenPreOrdersCompanion
    Function({
  Value<int> id,
});
typedef $$SeenPreOrdersTableUpdateCompanionBuilder = SeenPreOrdersCompanion
    Function({
  Value<int> id,
});

class $$SeenPreOrdersTableFilterComposer
    extends Composer<_$AppDataStore, $SeenPreOrdersTable> {
  $$SeenPreOrdersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));
}

class $$SeenPreOrdersTableOrderingComposer
    extends Composer<_$AppDataStore, $SeenPreOrdersTable> {
  $$SeenPreOrdersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));
}

class $$SeenPreOrdersTableAnnotationComposer
    extends Composer<_$AppDataStore, $SeenPreOrdersTable> {
  $$SeenPreOrdersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);
}

class $$SeenPreOrdersTableTableManager extends RootTableManager<
    _$AppDataStore,
    $SeenPreOrdersTable,
    SeenPreOrder,
    $$SeenPreOrdersTableFilterComposer,
    $$SeenPreOrdersTableOrderingComposer,
    $$SeenPreOrdersTableAnnotationComposer,
    $$SeenPreOrdersTableCreateCompanionBuilder,
    $$SeenPreOrdersTableUpdateCompanionBuilder,
    (
      SeenPreOrder,
      BaseReferences<_$AppDataStore, $SeenPreOrdersTable, SeenPreOrder>
    ),
    SeenPreOrder,
    PrefetchHooks Function()> {
  $$SeenPreOrdersTableTableManager(_$AppDataStore db, $SeenPreOrdersTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SeenPreOrdersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SeenPreOrdersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SeenPreOrdersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
          }) =>
              SeenPreOrdersCompanion(
            id: id,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
          }) =>
              SeenPreOrdersCompanion.insert(
            id: id,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$SeenPreOrdersTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $SeenPreOrdersTable,
    SeenPreOrder,
    $$SeenPreOrdersTableFilterComposer,
    $$SeenPreOrdersTableOrderingComposer,
    $$SeenPreOrdersTableAnnotationComposer,
    $$SeenPreOrdersTableCreateCompanionBuilder,
    $$SeenPreOrdersTableUpdateCompanionBuilder,
    (
      SeenPreOrder,
      BaseReferences<_$AppDataStore, $SeenPreOrdersTable, SeenPreOrder>
    ),
    SeenPreOrder,
    PrefetchHooks Function()>;
typedef $$BonusProgramGroupsTableCreateCompanionBuilder
    = BonusProgramGroupsCompanion Function({
  Value<int> id,
  required String name,
});
typedef $$BonusProgramGroupsTableUpdateCompanionBuilder
    = BonusProgramGroupsCompanion Function({
  Value<int> id,
  Value<String> name,
});

class $$BonusProgramGroupsTableFilterComposer
    extends Composer<_$AppDataStore, $BonusProgramGroupsTable> {
  $$BonusProgramGroupsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));
}

class $$BonusProgramGroupsTableOrderingComposer
    extends Composer<_$AppDataStore, $BonusProgramGroupsTable> {
  $$BonusProgramGroupsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));
}

class $$BonusProgramGroupsTableAnnotationComposer
    extends Composer<_$AppDataStore, $BonusProgramGroupsTable> {
  $$BonusProgramGroupsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);
}

class $$BonusProgramGroupsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $BonusProgramGroupsTable,
    BonusProgramGroup,
    $$BonusProgramGroupsTableFilterComposer,
    $$BonusProgramGroupsTableOrderingComposer,
    $$BonusProgramGroupsTableAnnotationComposer,
    $$BonusProgramGroupsTableCreateCompanionBuilder,
    $$BonusProgramGroupsTableUpdateCompanionBuilder,
    (
      BonusProgramGroup,
      BaseReferences<_$AppDataStore, $BonusProgramGroupsTable,
          BonusProgramGroup>
    ),
    BonusProgramGroup,
    PrefetchHooks Function()> {
  $$BonusProgramGroupsTableTableManager(
      _$AppDataStore db, $BonusProgramGroupsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BonusProgramGroupsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BonusProgramGroupsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BonusProgramGroupsTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> name = const Value.absent(),
          }) =>
              BonusProgramGroupsCompanion(
            id: id,
            name: name,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String name,
          }) =>
              BonusProgramGroupsCompanion.insert(
            id: id,
            name: name,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$BonusProgramGroupsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $BonusProgramGroupsTable,
    BonusProgramGroup,
    $$BonusProgramGroupsTableFilterComposer,
    $$BonusProgramGroupsTableOrderingComposer,
    $$BonusProgramGroupsTableAnnotationComposer,
    $$BonusProgramGroupsTableCreateCompanionBuilder,
    $$BonusProgramGroupsTableUpdateCompanionBuilder,
    (
      BonusProgramGroup,
      BaseReferences<_$AppDataStore, $BonusProgramGroupsTable,
          BonusProgramGroup>
    ),
    BonusProgramGroup,
    PrefetchHooks Function()>;
typedef $$BonusProgramsTableCreateCompanionBuilder = BonusProgramsCompanion
    Function({
  Value<int> id,
  required String name,
  required DateTime dateFrom,
  required DateTime dateTo,
  required String condition,
  required String present,
  required String tagText,
  required double discount,
  required double coef,
  required int conditionalDiscount,
  required int bonusProgramGroupId,
});
typedef $$BonusProgramsTableUpdateCompanionBuilder = BonusProgramsCompanion
    Function({
  Value<int> id,
  Value<String> name,
  Value<DateTime> dateFrom,
  Value<DateTime> dateTo,
  Value<String> condition,
  Value<String> present,
  Value<String> tagText,
  Value<double> discount,
  Value<double> coef,
  Value<int> conditionalDiscount,
  Value<int> bonusProgramGroupId,
});

class $$BonusProgramsTableFilterComposer
    extends Composer<_$AppDataStore, $BonusProgramsTable> {
  $$BonusProgramsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get dateFrom => $composableBuilder(
      column: $table.dateFrom, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get dateTo => $composableBuilder(
      column: $table.dateTo, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get condition => $composableBuilder(
      column: $table.condition, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get present => $composableBuilder(
      column: $table.present, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get tagText => $composableBuilder(
      column: $table.tagText, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get discount => $composableBuilder(
      column: $table.discount, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get coef => $composableBuilder(
      column: $table.coef, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get conditionalDiscount => $composableBuilder(
      column: $table.conditionalDiscount,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get bonusProgramGroupId => $composableBuilder(
      column: $table.bonusProgramGroupId,
      builder: (column) => ColumnFilters(column));
}

class $$BonusProgramsTableOrderingComposer
    extends Composer<_$AppDataStore, $BonusProgramsTable> {
  $$BonusProgramsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get dateFrom => $composableBuilder(
      column: $table.dateFrom, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get dateTo => $composableBuilder(
      column: $table.dateTo, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get condition => $composableBuilder(
      column: $table.condition, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get present => $composableBuilder(
      column: $table.present, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get tagText => $composableBuilder(
      column: $table.tagText, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get discount => $composableBuilder(
      column: $table.discount, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get coef => $composableBuilder(
      column: $table.coef, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get conditionalDiscount => $composableBuilder(
      column: $table.conditionalDiscount,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get bonusProgramGroupId => $composableBuilder(
      column: $table.bonusProgramGroupId,
      builder: (column) => ColumnOrderings(column));
}

class $$BonusProgramsTableAnnotationComposer
    extends Composer<_$AppDataStore, $BonusProgramsTable> {
  $$BonusProgramsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<DateTime> get dateFrom =>
      $composableBuilder(column: $table.dateFrom, builder: (column) => column);

  GeneratedColumn<DateTime> get dateTo =>
      $composableBuilder(column: $table.dateTo, builder: (column) => column);

  GeneratedColumn<String> get condition =>
      $composableBuilder(column: $table.condition, builder: (column) => column);

  GeneratedColumn<String> get present =>
      $composableBuilder(column: $table.present, builder: (column) => column);

  GeneratedColumn<String> get tagText =>
      $composableBuilder(column: $table.tagText, builder: (column) => column);

  GeneratedColumn<double> get discount =>
      $composableBuilder(column: $table.discount, builder: (column) => column);

  GeneratedColumn<double> get coef =>
      $composableBuilder(column: $table.coef, builder: (column) => column);

  GeneratedColumn<int> get conditionalDiscount => $composableBuilder(
      column: $table.conditionalDiscount, builder: (column) => column);

  GeneratedColumn<int> get bonusProgramGroupId => $composableBuilder(
      column: $table.bonusProgramGroupId, builder: (column) => column);
}

class $$BonusProgramsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $BonusProgramsTable,
    BonusProgram,
    $$BonusProgramsTableFilterComposer,
    $$BonusProgramsTableOrderingComposer,
    $$BonusProgramsTableAnnotationComposer,
    $$BonusProgramsTableCreateCompanionBuilder,
    $$BonusProgramsTableUpdateCompanionBuilder,
    (
      BonusProgram,
      BaseReferences<_$AppDataStore, $BonusProgramsTable, BonusProgram>
    ),
    BonusProgram,
    PrefetchHooks Function()> {
  $$BonusProgramsTableTableManager(_$AppDataStore db, $BonusProgramsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BonusProgramsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BonusProgramsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BonusProgramsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<DateTime> dateFrom = const Value.absent(),
            Value<DateTime> dateTo = const Value.absent(),
            Value<String> condition = const Value.absent(),
            Value<String> present = const Value.absent(),
            Value<String> tagText = const Value.absent(),
            Value<double> discount = const Value.absent(),
            Value<double> coef = const Value.absent(),
            Value<int> conditionalDiscount = const Value.absent(),
            Value<int> bonusProgramGroupId = const Value.absent(),
          }) =>
              BonusProgramsCompanion(
            id: id,
            name: name,
            dateFrom: dateFrom,
            dateTo: dateTo,
            condition: condition,
            present: present,
            tagText: tagText,
            discount: discount,
            coef: coef,
            conditionalDiscount: conditionalDiscount,
            bonusProgramGroupId: bonusProgramGroupId,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String name,
            required DateTime dateFrom,
            required DateTime dateTo,
            required String condition,
            required String present,
            required String tagText,
            required double discount,
            required double coef,
            required int conditionalDiscount,
            required int bonusProgramGroupId,
          }) =>
              BonusProgramsCompanion.insert(
            id: id,
            name: name,
            dateFrom: dateFrom,
            dateTo: dateTo,
            condition: condition,
            present: present,
            tagText: tagText,
            discount: discount,
            coef: coef,
            conditionalDiscount: conditionalDiscount,
            bonusProgramGroupId: bonusProgramGroupId,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$BonusProgramsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $BonusProgramsTable,
    BonusProgram,
    $$BonusProgramsTableFilterComposer,
    $$BonusProgramsTableOrderingComposer,
    $$BonusProgramsTableAnnotationComposer,
    $$BonusProgramsTableCreateCompanionBuilder,
    $$BonusProgramsTableUpdateCompanionBuilder,
    (
      BonusProgram,
      BaseReferences<_$AppDataStore, $BonusProgramsTable, BonusProgram>
    ),
    BonusProgram,
    PrefetchHooks Function()>;
typedef $$BuyersSetsTableCreateCompanionBuilder = BuyersSetsCompanion Function({
  Value<int> id,
  required String name,
});
typedef $$BuyersSetsTableUpdateCompanionBuilder = BuyersSetsCompanion Function({
  Value<int> id,
  Value<String> name,
});

class $$BuyersSetsTableFilterComposer
    extends Composer<_$AppDataStore, $BuyersSetsTable> {
  $$BuyersSetsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));
}

class $$BuyersSetsTableOrderingComposer
    extends Composer<_$AppDataStore, $BuyersSetsTable> {
  $$BuyersSetsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));
}

class $$BuyersSetsTableAnnotationComposer
    extends Composer<_$AppDataStore, $BuyersSetsTable> {
  $$BuyersSetsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);
}

class $$BuyersSetsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $BuyersSetsTable,
    BuyersSet,
    $$BuyersSetsTableFilterComposer,
    $$BuyersSetsTableOrderingComposer,
    $$BuyersSetsTableAnnotationComposer,
    $$BuyersSetsTableCreateCompanionBuilder,
    $$BuyersSetsTableUpdateCompanionBuilder,
    (BuyersSet, BaseReferences<_$AppDataStore, $BuyersSetsTable, BuyersSet>),
    BuyersSet,
    PrefetchHooks Function()> {
  $$BuyersSetsTableTableManager(_$AppDataStore db, $BuyersSetsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BuyersSetsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BuyersSetsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BuyersSetsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> name = const Value.absent(),
          }) =>
              BuyersSetsCompanion(
            id: id,
            name: name,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String name,
          }) =>
              BuyersSetsCompanion.insert(
            id: id,
            name: name,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$BuyersSetsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $BuyersSetsTable,
    BuyersSet,
    $$BuyersSetsTableFilterComposer,
    $$BuyersSetsTableOrderingComposer,
    $$BuyersSetsTableAnnotationComposer,
    $$BuyersSetsTableCreateCompanionBuilder,
    $$BuyersSetsTableUpdateCompanionBuilder,
    (BuyersSet, BaseReferences<_$AppDataStore, $BuyersSetsTable, BuyersSet>),
    BuyersSet,
    PrefetchHooks Function()>;
typedef $$BuyersSetsBonusProgramsTableCreateCompanionBuilder
    = BuyersSetsBonusProgramsCompanion Function({
  required int buyersSetId,
  required int bonusProgramId,
  Value<int> rowid,
});
typedef $$BuyersSetsBonusProgramsTableUpdateCompanionBuilder
    = BuyersSetsBonusProgramsCompanion Function({
  Value<int> buyersSetId,
  Value<int> bonusProgramId,
  Value<int> rowid,
});

class $$BuyersSetsBonusProgramsTableFilterComposer
    extends Composer<_$AppDataStore, $BuyersSetsBonusProgramsTable> {
  $$BuyersSetsBonusProgramsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get buyersSetId => $composableBuilder(
      column: $table.buyersSetId, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get bonusProgramId => $composableBuilder(
      column: $table.bonusProgramId,
      builder: (column) => ColumnFilters(column));
}

class $$BuyersSetsBonusProgramsTableOrderingComposer
    extends Composer<_$AppDataStore, $BuyersSetsBonusProgramsTable> {
  $$BuyersSetsBonusProgramsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get buyersSetId => $composableBuilder(
      column: $table.buyersSetId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get bonusProgramId => $composableBuilder(
      column: $table.bonusProgramId,
      builder: (column) => ColumnOrderings(column));
}

class $$BuyersSetsBonusProgramsTableAnnotationComposer
    extends Composer<_$AppDataStore, $BuyersSetsBonusProgramsTable> {
  $$BuyersSetsBonusProgramsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get buyersSetId => $composableBuilder(
      column: $table.buyersSetId, builder: (column) => column);

  GeneratedColumn<int> get bonusProgramId => $composableBuilder(
      column: $table.bonusProgramId, builder: (column) => column);
}

class $$BuyersSetsBonusProgramsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $BuyersSetsBonusProgramsTable,
    BuyersSetsBonusProgram,
    $$BuyersSetsBonusProgramsTableFilterComposer,
    $$BuyersSetsBonusProgramsTableOrderingComposer,
    $$BuyersSetsBonusProgramsTableAnnotationComposer,
    $$BuyersSetsBonusProgramsTableCreateCompanionBuilder,
    $$BuyersSetsBonusProgramsTableUpdateCompanionBuilder,
    (
      BuyersSetsBonusProgram,
      BaseReferences<_$AppDataStore, $BuyersSetsBonusProgramsTable,
          BuyersSetsBonusProgram>
    ),
    BuyersSetsBonusProgram,
    PrefetchHooks Function()> {
  $$BuyersSetsBonusProgramsTableTableManager(
      _$AppDataStore db, $BuyersSetsBonusProgramsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BuyersSetsBonusProgramsTableFilterComposer(
                  $db: db, $table: table),
          createOrderingComposer: () =>
              $$BuyersSetsBonusProgramsTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BuyersSetsBonusProgramsTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> buyersSetId = const Value.absent(),
            Value<int> bonusProgramId = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              BuyersSetsBonusProgramsCompanion(
            buyersSetId: buyersSetId,
            bonusProgramId: bonusProgramId,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required int buyersSetId,
            required int bonusProgramId,
            Value<int> rowid = const Value.absent(),
          }) =>
              BuyersSetsBonusProgramsCompanion.insert(
            buyersSetId: buyersSetId,
            bonusProgramId: bonusProgramId,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$BuyersSetsBonusProgramsTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDataStore,
        $BuyersSetsBonusProgramsTable,
        BuyersSetsBonusProgram,
        $$BuyersSetsBonusProgramsTableFilterComposer,
        $$BuyersSetsBonusProgramsTableOrderingComposer,
        $$BuyersSetsBonusProgramsTableAnnotationComposer,
        $$BuyersSetsBonusProgramsTableCreateCompanionBuilder,
        $$BuyersSetsBonusProgramsTableUpdateCompanionBuilder,
        (
          BuyersSetsBonusProgram,
          BaseReferences<_$AppDataStore, $BuyersSetsBonusProgramsTable,
              BuyersSetsBonusProgram>
        ),
        BuyersSetsBonusProgram,
        PrefetchHooks Function()>;
typedef $$BuyersSetsBuyersTableCreateCompanionBuilder
    = BuyersSetsBuyersCompanion Function({
  required int buyersSetId,
  required int buyerId,
  Value<int> rowid,
});
typedef $$BuyersSetsBuyersTableUpdateCompanionBuilder
    = BuyersSetsBuyersCompanion Function({
  Value<int> buyersSetId,
  Value<int> buyerId,
  Value<int> rowid,
});

class $$BuyersSetsBuyersTableFilterComposer
    extends Composer<_$AppDataStore, $BuyersSetsBuyersTable> {
  $$BuyersSetsBuyersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get buyersSetId => $composableBuilder(
      column: $table.buyersSetId, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnFilters(column));
}

class $$BuyersSetsBuyersTableOrderingComposer
    extends Composer<_$AppDataStore, $BuyersSetsBuyersTable> {
  $$BuyersSetsBuyersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get buyersSetId => $composableBuilder(
      column: $table.buyersSetId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnOrderings(column));
}

class $$BuyersSetsBuyersTableAnnotationComposer
    extends Composer<_$AppDataStore, $BuyersSetsBuyersTable> {
  $$BuyersSetsBuyersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get buyersSetId => $composableBuilder(
      column: $table.buyersSetId, builder: (column) => column);

  GeneratedColumn<int> get buyerId =>
      $composableBuilder(column: $table.buyerId, builder: (column) => column);
}

class $$BuyersSetsBuyersTableTableManager extends RootTableManager<
    _$AppDataStore,
    $BuyersSetsBuyersTable,
    BuyersSetsBuyer,
    $$BuyersSetsBuyersTableFilterComposer,
    $$BuyersSetsBuyersTableOrderingComposer,
    $$BuyersSetsBuyersTableAnnotationComposer,
    $$BuyersSetsBuyersTableCreateCompanionBuilder,
    $$BuyersSetsBuyersTableUpdateCompanionBuilder,
    (
      BuyersSetsBuyer,
      BaseReferences<_$AppDataStore, $BuyersSetsBuyersTable, BuyersSetsBuyer>
    ),
    BuyersSetsBuyer,
    PrefetchHooks Function()> {
  $$BuyersSetsBuyersTableTableManager(
      _$AppDataStore db, $BuyersSetsBuyersTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BuyersSetsBuyersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BuyersSetsBuyersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BuyersSetsBuyersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> buyersSetId = const Value.absent(),
            Value<int> buyerId = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              BuyersSetsBuyersCompanion(
            buyersSetId: buyersSetId,
            buyerId: buyerId,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required int buyersSetId,
            required int buyerId,
            Value<int> rowid = const Value.absent(),
          }) =>
              BuyersSetsBuyersCompanion.insert(
            buyersSetId: buyersSetId,
            buyerId: buyerId,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$BuyersSetsBuyersTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $BuyersSetsBuyersTable,
    BuyersSetsBuyer,
    $$BuyersSetsBuyersTableFilterComposer,
    $$BuyersSetsBuyersTableOrderingComposer,
    $$BuyersSetsBuyersTableAnnotationComposer,
    $$BuyersSetsBuyersTableCreateCompanionBuilder,
    $$BuyersSetsBuyersTableUpdateCompanionBuilder,
    (
      BuyersSetsBuyer,
      BaseReferences<_$AppDataStore, $BuyersSetsBuyersTable, BuyersSetsBuyer>
    ),
    BuyersSetsBuyer,
    PrefetchHooks Function()>;
typedef $$GoodsBonusProgramsTableCreateCompanionBuilder
    = GoodsBonusProgramsCompanion Function({
  required int bonusProgramId,
  required int goodsId,
  Value<int> rowid,
});
typedef $$GoodsBonusProgramsTableUpdateCompanionBuilder
    = GoodsBonusProgramsCompanion Function({
  Value<int> bonusProgramId,
  Value<int> goodsId,
  Value<int> rowid,
});

class $$GoodsBonusProgramsTableFilterComposer
    extends Composer<_$AppDataStore, $GoodsBonusProgramsTable> {
  $$GoodsBonusProgramsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get bonusProgramId => $composableBuilder(
      column: $table.bonusProgramId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnFilters(column));
}

class $$GoodsBonusProgramsTableOrderingComposer
    extends Composer<_$AppDataStore, $GoodsBonusProgramsTable> {
  $$GoodsBonusProgramsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get bonusProgramId => $composableBuilder(
      column: $table.bonusProgramId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnOrderings(column));
}

class $$GoodsBonusProgramsTableAnnotationComposer
    extends Composer<_$AppDataStore, $GoodsBonusProgramsTable> {
  $$GoodsBonusProgramsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get bonusProgramId => $composableBuilder(
      column: $table.bonusProgramId, builder: (column) => column);

  GeneratedColumn<int> get goodsId =>
      $composableBuilder(column: $table.goodsId, builder: (column) => column);
}

class $$GoodsBonusProgramsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $GoodsBonusProgramsTable,
    GoodsBonusProgram,
    $$GoodsBonusProgramsTableFilterComposer,
    $$GoodsBonusProgramsTableOrderingComposer,
    $$GoodsBonusProgramsTableAnnotationComposer,
    $$GoodsBonusProgramsTableCreateCompanionBuilder,
    $$GoodsBonusProgramsTableUpdateCompanionBuilder,
    (
      GoodsBonusProgram,
      BaseReferences<_$AppDataStore, $GoodsBonusProgramsTable,
          GoodsBonusProgram>
    ),
    GoodsBonusProgram,
    PrefetchHooks Function()> {
  $$GoodsBonusProgramsTableTableManager(
      _$AppDataStore db, $GoodsBonusProgramsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$GoodsBonusProgramsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$GoodsBonusProgramsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$GoodsBonusProgramsTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> bonusProgramId = const Value.absent(),
            Value<int> goodsId = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              GoodsBonusProgramsCompanion(
            bonusProgramId: bonusProgramId,
            goodsId: goodsId,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required int bonusProgramId,
            required int goodsId,
            Value<int> rowid = const Value.absent(),
          }) =>
              GoodsBonusProgramsCompanion.insert(
            bonusProgramId: bonusProgramId,
            goodsId: goodsId,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$GoodsBonusProgramsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $GoodsBonusProgramsTable,
    GoodsBonusProgram,
    $$GoodsBonusProgramsTableFilterComposer,
    $$GoodsBonusProgramsTableOrderingComposer,
    $$GoodsBonusProgramsTableAnnotationComposer,
    $$GoodsBonusProgramsTableCreateCompanionBuilder,
    $$GoodsBonusProgramsTableUpdateCompanionBuilder,
    (
      GoodsBonusProgram,
      BaseReferences<_$AppDataStore, $GoodsBonusProgramsTable,
          GoodsBonusProgram>
    ),
    GoodsBonusProgram,
    PrefetchHooks Function()>;
typedef $$GoodsBonusProgramPricesTableCreateCompanionBuilder
    = GoodsBonusProgramPricesCompanion Function({
  required int bonusProgramId,
  required int goodsId,
  required double price,
  Value<int> rowid,
});
typedef $$GoodsBonusProgramPricesTableUpdateCompanionBuilder
    = GoodsBonusProgramPricesCompanion Function({
  Value<int> bonusProgramId,
  Value<int> goodsId,
  Value<double> price,
  Value<int> rowid,
});

class $$GoodsBonusProgramPricesTableFilterComposer
    extends Composer<_$AppDataStore, $GoodsBonusProgramPricesTable> {
  $$GoodsBonusProgramPricesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get bonusProgramId => $composableBuilder(
      column: $table.bonusProgramId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnFilters(column));
}

class $$GoodsBonusProgramPricesTableOrderingComposer
    extends Composer<_$AppDataStore, $GoodsBonusProgramPricesTable> {
  $$GoodsBonusProgramPricesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get bonusProgramId => $composableBuilder(
      column: $table.bonusProgramId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnOrderings(column));
}

class $$GoodsBonusProgramPricesTableAnnotationComposer
    extends Composer<_$AppDataStore, $GoodsBonusProgramPricesTable> {
  $$GoodsBonusProgramPricesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get bonusProgramId => $composableBuilder(
      column: $table.bonusProgramId, builder: (column) => column);

  GeneratedColumn<int> get goodsId =>
      $composableBuilder(column: $table.goodsId, builder: (column) => column);

  GeneratedColumn<double> get price =>
      $composableBuilder(column: $table.price, builder: (column) => column);
}

class $$GoodsBonusProgramPricesTableTableManager extends RootTableManager<
    _$AppDataStore,
    $GoodsBonusProgramPricesTable,
    GoodsBonusProgramPrice,
    $$GoodsBonusProgramPricesTableFilterComposer,
    $$GoodsBonusProgramPricesTableOrderingComposer,
    $$GoodsBonusProgramPricesTableAnnotationComposer,
    $$GoodsBonusProgramPricesTableCreateCompanionBuilder,
    $$GoodsBonusProgramPricesTableUpdateCompanionBuilder,
    (
      GoodsBonusProgramPrice,
      BaseReferences<_$AppDataStore, $GoodsBonusProgramPricesTable,
          GoodsBonusProgramPrice>
    ),
    GoodsBonusProgramPrice,
    PrefetchHooks Function()> {
  $$GoodsBonusProgramPricesTableTableManager(
      _$AppDataStore db, $GoodsBonusProgramPricesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$GoodsBonusProgramPricesTableFilterComposer(
                  $db: db, $table: table),
          createOrderingComposer: () =>
              $$GoodsBonusProgramPricesTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$GoodsBonusProgramPricesTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> bonusProgramId = const Value.absent(),
            Value<int> goodsId = const Value.absent(),
            Value<double> price = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              GoodsBonusProgramPricesCompanion(
            bonusProgramId: bonusProgramId,
            goodsId: goodsId,
            price: price,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required int bonusProgramId,
            required int goodsId,
            required double price,
            Value<int> rowid = const Value.absent(),
          }) =>
              GoodsBonusProgramPricesCompanion.insert(
            bonusProgramId: bonusProgramId,
            goodsId: goodsId,
            price: price,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$GoodsBonusProgramPricesTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDataStore,
        $GoodsBonusProgramPricesTable,
        GoodsBonusProgramPrice,
        $$GoodsBonusProgramPricesTableFilterComposer,
        $$GoodsBonusProgramPricesTableOrderingComposer,
        $$GoodsBonusProgramPricesTableAnnotationComposer,
        $$GoodsBonusProgramPricesTableCreateCompanionBuilder,
        $$GoodsBonusProgramPricesTableUpdateCompanionBuilder,
        (
          GoodsBonusProgramPrice,
          BaseReferences<_$AppDataStore, $GoodsBonusProgramPricesTable,
              GoodsBonusProgramPrice>
        ),
        GoodsBonusProgramPrice,
        PrefetchHooks Function()>;
typedef $$PricelistsTableCreateCompanionBuilder = PricelistsCompanion Function({
  Value<int> id,
  required String name,
  required bool permit,
});
typedef $$PricelistsTableUpdateCompanionBuilder = PricelistsCompanion Function({
  Value<int> id,
  Value<String> name,
  Value<bool> permit,
});

class $$PricelistsTableFilterComposer
    extends Composer<_$AppDataStore, $PricelistsTable> {
  $$PricelistsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get permit => $composableBuilder(
      column: $table.permit, builder: (column) => ColumnFilters(column));
}

class $$PricelistsTableOrderingComposer
    extends Composer<_$AppDataStore, $PricelistsTable> {
  $$PricelistsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get permit => $composableBuilder(
      column: $table.permit, builder: (column) => ColumnOrderings(column));
}

class $$PricelistsTableAnnotationComposer
    extends Composer<_$AppDataStore, $PricelistsTable> {
  $$PricelistsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<bool> get permit =>
      $composableBuilder(column: $table.permit, builder: (column) => column);
}

class $$PricelistsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $PricelistsTable,
    Pricelist,
    $$PricelistsTableFilterComposer,
    $$PricelistsTableOrderingComposer,
    $$PricelistsTableAnnotationComposer,
    $$PricelistsTableCreateCompanionBuilder,
    $$PricelistsTableUpdateCompanionBuilder,
    (Pricelist, BaseReferences<_$AppDataStore, $PricelistsTable, Pricelist>),
    Pricelist,
    PrefetchHooks Function()> {
  $$PricelistsTableTableManager(_$AppDataStore db, $PricelistsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PricelistsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PricelistsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PricelistsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<bool> permit = const Value.absent(),
          }) =>
              PricelistsCompanion(
            id: id,
            name: name,
            permit: permit,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String name,
            required bool permit,
          }) =>
              PricelistsCompanion.insert(
            id: id,
            name: name,
            permit: permit,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$PricelistsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $PricelistsTable,
    Pricelist,
    $$PricelistsTableFilterComposer,
    $$PricelistsTableOrderingComposer,
    $$PricelistsTableAnnotationComposer,
    $$PricelistsTableCreateCompanionBuilder,
    $$PricelistsTableUpdateCompanionBuilder,
    (Pricelist, BaseReferences<_$AppDataStore, $PricelistsTable, Pricelist>),
    Pricelist,
    PrefetchHooks Function()>;
typedef $$PricelistSetCategoriesTableCreateCompanionBuilder
    = PricelistSetCategoriesCompanion Function({
  required int pricelistSetId,
  required int categoryId,
  Value<int> rowid,
});
typedef $$PricelistSetCategoriesTableUpdateCompanionBuilder
    = PricelistSetCategoriesCompanion Function({
  Value<int> pricelistSetId,
  Value<int> categoryId,
  Value<int> rowid,
});

class $$PricelistSetCategoriesTableFilterComposer
    extends Composer<_$AppDataStore, $PricelistSetCategoriesTable> {
  $$PricelistSetCategoriesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get pricelistSetId => $composableBuilder(
      column: $table.pricelistSetId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get categoryId => $composableBuilder(
      column: $table.categoryId, builder: (column) => ColumnFilters(column));
}

class $$PricelistSetCategoriesTableOrderingComposer
    extends Composer<_$AppDataStore, $PricelistSetCategoriesTable> {
  $$PricelistSetCategoriesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get pricelistSetId => $composableBuilder(
      column: $table.pricelistSetId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get categoryId => $composableBuilder(
      column: $table.categoryId, builder: (column) => ColumnOrderings(column));
}

class $$PricelistSetCategoriesTableAnnotationComposer
    extends Composer<_$AppDataStore, $PricelistSetCategoriesTable> {
  $$PricelistSetCategoriesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get pricelistSetId => $composableBuilder(
      column: $table.pricelistSetId, builder: (column) => column);

  GeneratedColumn<int> get categoryId => $composableBuilder(
      column: $table.categoryId, builder: (column) => column);
}

class $$PricelistSetCategoriesTableTableManager extends RootTableManager<
    _$AppDataStore,
    $PricelistSetCategoriesTable,
    PricelistSetCategory,
    $$PricelistSetCategoriesTableFilterComposer,
    $$PricelistSetCategoriesTableOrderingComposer,
    $$PricelistSetCategoriesTableAnnotationComposer,
    $$PricelistSetCategoriesTableCreateCompanionBuilder,
    $$PricelistSetCategoriesTableUpdateCompanionBuilder,
    (
      PricelistSetCategory,
      BaseReferences<_$AppDataStore, $PricelistSetCategoriesTable,
          PricelistSetCategory>
    ),
    PricelistSetCategory,
    PrefetchHooks Function()> {
  $$PricelistSetCategoriesTableTableManager(
      _$AppDataStore db, $PricelistSetCategoriesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PricelistSetCategoriesTableFilterComposer(
                  $db: db, $table: table),
          createOrderingComposer: () =>
              $$PricelistSetCategoriesTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PricelistSetCategoriesTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> pricelistSetId = const Value.absent(),
            Value<int> categoryId = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              PricelistSetCategoriesCompanion(
            pricelistSetId: pricelistSetId,
            categoryId: categoryId,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required int pricelistSetId,
            required int categoryId,
            Value<int> rowid = const Value.absent(),
          }) =>
              PricelistSetCategoriesCompanion.insert(
            pricelistSetId: pricelistSetId,
            categoryId: categoryId,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$PricelistSetCategoriesTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDataStore,
        $PricelistSetCategoriesTable,
        PricelistSetCategory,
        $$PricelistSetCategoriesTableFilterComposer,
        $$PricelistSetCategoriesTableOrderingComposer,
        $$PricelistSetCategoriesTableAnnotationComposer,
        $$PricelistSetCategoriesTableCreateCompanionBuilder,
        $$PricelistSetCategoriesTableUpdateCompanionBuilder,
        (
          PricelistSetCategory,
          BaseReferences<_$AppDataStore, $PricelistSetCategoriesTable,
              PricelistSetCategory>
        ),
        PricelistSetCategory,
        PrefetchHooks Function()>;
typedef $$PartnersPricesTableCreateCompanionBuilder = PartnersPricesCompanion
    Function({
  required String guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  required int goodsId,
  required int partnerId,
  required double price,
  required DateTime dateFrom,
  required DateTime dateTo,
  Value<int> rowid,
});
typedef $$PartnersPricesTableUpdateCompanionBuilder = PartnersPricesCompanion
    Function({
  Value<String> guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  Value<int> goodsId,
  Value<int> partnerId,
  Value<double> price,
  Value<DateTime> dateFrom,
  Value<DateTime> dateTo,
  Value<int> rowid,
});

class $$PartnersPricesTableFilterComposer
    extends Composer<_$AppDataStore, $PartnersPricesTable> {
  $$PartnersPricesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get partnerId => $composableBuilder(
      column: $table.partnerId, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get dateFrom => $composableBuilder(
      column: $table.dateFrom, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get dateTo => $composableBuilder(
      column: $table.dateTo, builder: (column) => ColumnFilters(column));
}

class $$PartnersPricesTableOrderingComposer
    extends Composer<_$AppDataStore, $PartnersPricesTable> {
  $$PartnersPricesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get partnerId => $composableBuilder(
      column: $table.partnerId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get dateFrom => $composableBuilder(
      column: $table.dateFrom, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get dateTo => $composableBuilder(
      column: $table.dateTo, builder: (column) => ColumnOrderings(column));
}

class $$PartnersPricesTableAnnotationComposer
    extends Composer<_$AppDataStore, $PartnersPricesTable> {
  $$PartnersPricesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get guid =>
      $composableBuilder(column: $table.guid, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => column);

  GeneratedColumn<bool> get needSync =>
      $composableBuilder(column: $table.needSync, builder: (column) => column);

  GeneratedColumn<bool> get isNew =>
      $composableBuilder(column: $table.isNew, builder: (column) => column);

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get goodsId =>
      $composableBuilder(column: $table.goodsId, builder: (column) => column);

  GeneratedColumn<int> get partnerId =>
      $composableBuilder(column: $table.partnerId, builder: (column) => column);

  GeneratedColumn<double> get price =>
      $composableBuilder(column: $table.price, builder: (column) => column);

  GeneratedColumn<DateTime> get dateFrom =>
      $composableBuilder(column: $table.dateFrom, builder: (column) => column);

  GeneratedColumn<DateTime> get dateTo =>
      $composableBuilder(column: $table.dateTo, builder: (column) => column);
}

class $$PartnersPricesTableTableManager extends RootTableManager<
    _$AppDataStore,
    $PartnersPricesTable,
    PartnersPrice,
    $$PartnersPricesTableFilterComposer,
    $$PartnersPricesTableOrderingComposer,
    $$PartnersPricesTableAnnotationComposer,
    $$PartnersPricesTableCreateCompanionBuilder,
    $$PartnersPricesTableUpdateCompanionBuilder,
    (
      PartnersPrice,
      BaseReferences<_$AppDataStore, $PartnersPricesTable, PartnersPrice>
    ),
    PartnersPrice,
    PrefetchHooks Function()> {
  $$PartnersPricesTableTableManager(
      _$AppDataStore db, $PartnersPricesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PartnersPricesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PartnersPricesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PartnersPricesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> guid = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            Value<int> goodsId = const Value.absent(),
            Value<int> partnerId = const Value.absent(),
            Value<double> price = const Value.absent(),
            Value<DateTime> dateFrom = const Value.absent(),
            Value<DateTime> dateTo = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              PartnersPricesCompanion(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            goodsId: goodsId,
            partnerId: partnerId,
            price: price,
            dateFrom: dateFrom,
            dateTo: dateTo,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String guid,
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            required int goodsId,
            required int partnerId,
            required double price,
            required DateTime dateFrom,
            required DateTime dateTo,
            Value<int> rowid = const Value.absent(),
          }) =>
              PartnersPricesCompanion.insert(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            goodsId: goodsId,
            partnerId: partnerId,
            price: price,
            dateFrom: dateFrom,
            dateTo: dateTo,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$PartnersPricesTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $PartnersPricesTable,
    PartnersPrice,
    $$PartnersPricesTableFilterComposer,
    $$PartnersPricesTableOrderingComposer,
    $$PartnersPricesTableAnnotationComposer,
    $$PartnersPricesTableCreateCompanionBuilder,
    $$PartnersPricesTableUpdateCompanionBuilder,
    (
      PartnersPrice,
      BaseReferences<_$AppDataStore, $PartnersPricesTable, PartnersPrice>
    ),
    PartnersPrice,
    PrefetchHooks Function()>;
typedef $$PricelistPricesTableCreateCompanionBuilder = PricelistPricesCompanion
    Function({
  required int goodsId,
  required int pricelistId,
  required double price,
  required DateTime dateFrom,
  required DateTime dateTo,
  Value<int> rowid,
});
typedef $$PricelistPricesTableUpdateCompanionBuilder = PricelistPricesCompanion
    Function({
  Value<int> goodsId,
  Value<int> pricelistId,
  Value<double> price,
  Value<DateTime> dateFrom,
  Value<DateTime> dateTo,
  Value<int> rowid,
});

class $$PricelistPricesTableFilterComposer
    extends Composer<_$AppDataStore, $PricelistPricesTable> {
  $$PricelistPricesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get pricelistId => $composableBuilder(
      column: $table.pricelistId, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get dateFrom => $composableBuilder(
      column: $table.dateFrom, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get dateTo => $composableBuilder(
      column: $table.dateTo, builder: (column) => ColumnFilters(column));
}

class $$PricelistPricesTableOrderingComposer
    extends Composer<_$AppDataStore, $PricelistPricesTable> {
  $$PricelistPricesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get pricelistId => $composableBuilder(
      column: $table.pricelistId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get dateFrom => $composableBuilder(
      column: $table.dateFrom, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get dateTo => $composableBuilder(
      column: $table.dateTo, builder: (column) => ColumnOrderings(column));
}

class $$PricelistPricesTableAnnotationComposer
    extends Composer<_$AppDataStore, $PricelistPricesTable> {
  $$PricelistPricesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get goodsId =>
      $composableBuilder(column: $table.goodsId, builder: (column) => column);

  GeneratedColumn<int> get pricelistId => $composableBuilder(
      column: $table.pricelistId, builder: (column) => column);

  GeneratedColumn<double> get price =>
      $composableBuilder(column: $table.price, builder: (column) => column);

  GeneratedColumn<DateTime> get dateFrom =>
      $composableBuilder(column: $table.dateFrom, builder: (column) => column);

  GeneratedColumn<DateTime> get dateTo =>
      $composableBuilder(column: $table.dateTo, builder: (column) => column);
}

class $$PricelistPricesTableTableManager extends RootTableManager<
    _$AppDataStore,
    $PricelistPricesTable,
    PricelistPrice,
    $$PricelistPricesTableFilterComposer,
    $$PricelistPricesTableOrderingComposer,
    $$PricelistPricesTableAnnotationComposer,
    $$PricelistPricesTableCreateCompanionBuilder,
    $$PricelistPricesTableUpdateCompanionBuilder,
    (
      PricelistPrice,
      BaseReferences<_$AppDataStore, $PricelistPricesTable, PricelistPrice>
    ),
    PricelistPrice,
    PrefetchHooks Function()> {
  $$PricelistPricesTableTableManager(
      _$AppDataStore db, $PricelistPricesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PricelistPricesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PricelistPricesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PricelistPricesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> goodsId = const Value.absent(),
            Value<int> pricelistId = const Value.absent(),
            Value<double> price = const Value.absent(),
            Value<DateTime> dateFrom = const Value.absent(),
            Value<DateTime> dateTo = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              PricelistPricesCompanion(
            goodsId: goodsId,
            pricelistId: pricelistId,
            price: price,
            dateFrom: dateFrom,
            dateTo: dateTo,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required int goodsId,
            required int pricelistId,
            required double price,
            required DateTime dateFrom,
            required DateTime dateTo,
            Value<int> rowid = const Value.absent(),
          }) =>
              PricelistPricesCompanion.insert(
            goodsId: goodsId,
            pricelistId: pricelistId,
            price: price,
            dateFrom: dateFrom,
            dateTo: dateTo,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$PricelistPricesTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $PricelistPricesTable,
    PricelistPrice,
    $$PricelistPricesTableFilterComposer,
    $$PricelistPricesTableOrderingComposer,
    $$PricelistPricesTableAnnotationComposer,
    $$PricelistPricesTableCreateCompanionBuilder,
    $$PricelistPricesTableUpdateCompanionBuilder,
    (
      PricelistPrice,
      BaseReferences<_$AppDataStore, $PricelistPricesTable, PricelistPrice>
    ),
    PricelistPrice,
    PrefetchHooks Function()>;
typedef $$PartnersPricelistsTableCreateCompanionBuilder
    = PartnersPricelistsCompanion Function({
  required String guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  required int partnerId,
  required int pricelistId,
  required int pricelistSetId,
  required double discount,
  Value<int> rowid,
});
typedef $$PartnersPricelistsTableUpdateCompanionBuilder
    = PartnersPricelistsCompanion Function({
  Value<String> guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  Value<int> partnerId,
  Value<int> pricelistId,
  Value<int> pricelistSetId,
  Value<double> discount,
  Value<int> rowid,
});

class $$PartnersPricelistsTableFilterComposer
    extends Composer<_$AppDataStore, $PartnersPricelistsTable> {
  $$PartnersPricelistsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get partnerId => $composableBuilder(
      column: $table.partnerId, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get pricelistId => $composableBuilder(
      column: $table.pricelistId, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get pricelistSetId => $composableBuilder(
      column: $table.pricelistSetId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get discount => $composableBuilder(
      column: $table.discount, builder: (column) => ColumnFilters(column));
}

class $$PartnersPricelistsTableOrderingComposer
    extends Composer<_$AppDataStore, $PartnersPricelistsTable> {
  $$PartnersPricelistsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get partnerId => $composableBuilder(
      column: $table.partnerId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get pricelistId => $composableBuilder(
      column: $table.pricelistId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get pricelistSetId => $composableBuilder(
      column: $table.pricelistSetId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get discount => $composableBuilder(
      column: $table.discount, builder: (column) => ColumnOrderings(column));
}

class $$PartnersPricelistsTableAnnotationComposer
    extends Composer<_$AppDataStore, $PartnersPricelistsTable> {
  $$PartnersPricelistsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get guid =>
      $composableBuilder(column: $table.guid, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => column);

  GeneratedColumn<bool> get needSync =>
      $composableBuilder(column: $table.needSync, builder: (column) => column);

  GeneratedColumn<bool> get isNew =>
      $composableBuilder(column: $table.isNew, builder: (column) => column);

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get partnerId =>
      $composableBuilder(column: $table.partnerId, builder: (column) => column);

  GeneratedColumn<int> get pricelistId => $composableBuilder(
      column: $table.pricelistId, builder: (column) => column);

  GeneratedColumn<int> get pricelistSetId => $composableBuilder(
      column: $table.pricelistSetId, builder: (column) => column);

  GeneratedColumn<double> get discount =>
      $composableBuilder(column: $table.discount, builder: (column) => column);
}

class $$PartnersPricelistsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $PartnersPricelistsTable,
    PartnersPricelist,
    $$PartnersPricelistsTableFilterComposer,
    $$PartnersPricelistsTableOrderingComposer,
    $$PartnersPricelistsTableAnnotationComposer,
    $$PartnersPricelistsTableCreateCompanionBuilder,
    $$PartnersPricelistsTableUpdateCompanionBuilder,
    (
      PartnersPricelist,
      BaseReferences<_$AppDataStore, $PartnersPricelistsTable,
          PartnersPricelist>
    ),
    PartnersPricelist,
    PrefetchHooks Function()> {
  $$PartnersPricelistsTableTableManager(
      _$AppDataStore db, $PartnersPricelistsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PartnersPricelistsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PartnersPricelistsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PartnersPricelistsTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> guid = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            Value<int> partnerId = const Value.absent(),
            Value<int> pricelistId = const Value.absent(),
            Value<int> pricelistSetId = const Value.absent(),
            Value<double> discount = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              PartnersPricelistsCompanion(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            partnerId: partnerId,
            pricelistId: pricelistId,
            pricelistSetId: pricelistSetId,
            discount: discount,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String guid,
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            required int partnerId,
            required int pricelistId,
            required int pricelistSetId,
            required double discount,
            Value<int> rowid = const Value.absent(),
          }) =>
              PartnersPricelistsCompanion.insert(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            partnerId: partnerId,
            pricelistId: pricelistId,
            pricelistSetId: pricelistSetId,
            discount: discount,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$PartnersPricelistsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $PartnersPricelistsTable,
    PartnersPricelist,
    $$PartnersPricelistsTableFilterComposer,
    $$PartnersPricelistsTableOrderingComposer,
    $$PartnersPricelistsTableAnnotationComposer,
    $$PartnersPricelistsTableCreateCompanionBuilder,
    $$PartnersPricelistsTableUpdateCompanionBuilder,
    (
      PartnersPricelist,
      BaseReferences<_$AppDataStore, $PartnersPricelistsTable,
          PartnersPricelist>
    ),
    PartnersPricelist,
    PrefetchHooks Function()>;
typedef $$GoodsRestrictionsTableCreateCompanionBuilder
    = GoodsRestrictionsCompanion Function({
  required int goodsId,
  required int buyerId,
  Value<int> rowid,
});
typedef $$GoodsRestrictionsTableUpdateCompanionBuilder
    = GoodsRestrictionsCompanion Function({
  Value<int> goodsId,
  Value<int> buyerId,
  Value<int> rowid,
});

class $$GoodsRestrictionsTableFilterComposer
    extends Composer<_$AppDataStore, $GoodsRestrictionsTable> {
  $$GoodsRestrictionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnFilters(column));
}

class $$GoodsRestrictionsTableOrderingComposer
    extends Composer<_$AppDataStore, $GoodsRestrictionsTable> {
  $$GoodsRestrictionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnOrderings(column));
}

class $$GoodsRestrictionsTableAnnotationComposer
    extends Composer<_$AppDataStore, $GoodsRestrictionsTable> {
  $$GoodsRestrictionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get goodsId =>
      $composableBuilder(column: $table.goodsId, builder: (column) => column);

  GeneratedColumn<int> get buyerId =>
      $composableBuilder(column: $table.buyerId, builder: (column) => column);
}

class $$GoodsRestrictionsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $GoodsRestrictionsTable,
    GoodsRestriction,
    $$GoodsRestrictionsTableFilterComposer,
    $$GoodsRestrictionsTableOrderingComposer,
    $$GoodsRestrictionsTableAnnotationComposer,
    $$GoodsRestrictionsTableCreateCompanionBuilder,
    $$GoodsRestrictionsTableUpdateCompanionBuilder,
    (
      GoodsRestriction,
      BaseReferences<_$AppDataStore, $GoodsRestrictionsTable, GoodsRestriction>
    ),
    GoodsRestriction,
    PrefetchHooks Function()> {
  $$GoodsRestrictionsTableTableManager(
      _$AppDataStore db, $GoodsRestrictionsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$GoodsRestrictionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$GoodsRestrictionsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$GoodsRestrictionsTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> goodsId = const Value.absent(),
            Value<int> buyerId = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              GoodsRestrictionsCompanion(
            goodsId: goodsId,
            buyerId: buyerId,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required int goodsId,
            required int buyerId,
            Value<int> rowid = const Value.absent(),
          }) =>
              GoodsRestrictionsCompanion.insert(
            goodsId: goodsId,
            buyerId: buyerId,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$GoodsRestrictionsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $GoodsRestrictionsTable,
    GoodsRestriction,
    $$GoodsRestrictionsTableFilterComposer,
    $$GoodsRestrictionsTableOrderingComposer,
    $$GoodsRestrictionsTableAnnotationComposer,
    $$GoodsRestrictionsTableCreateCompanionBuilder,
    $$GoodsRestrictionsTableUpdateCompanionBuilder,
    (
      GoodsRestriction,
      BaseReferences<_$AppDataStore, $GoodsRestrictionsTable, GoodsRestriction>
    ),
    GoodsRestriction,
    PrefetchHooks Function()>;
typedef $$GoodsStocksTableCreateCompanionBuilder = GoodsStocksCompanion
    Function({
  required int goodsId,
  required int siteId,
  required bool isVollow,
  required int vol,
  required int minVol,
  Value<int> rowid,
});
typedef $$GoodsStocksTableUpdateCompanionBuilder = GoodsStocksCompanion
    Function({
  Value<int> goodsId,
  Value<int> siteId,
  Value<bool> isVollow,
  Value<int> vol,
  Value<int> minVol,
  Value<int> rowid,
});

class $$GoodsStocksTableFilterComposer
    extends Composer<_$AppDataStore, $GoodsStocksTable> {
  $$GoodsStocksTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get siteId => $composableBuilder(
      column: $table.siteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isVollow => $composableBuilder(
      column: $table.isVollow, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get vol => $composableBuilder(
      column: $table.vol, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get minVol => $composableBuilder(
      column: $table.minVol, builder: (column) => ColumnFilters(column));
}

class $$GoodsStocksTableOrderingComposer
    extends Composer<_$AppDataStore, $GoodsStocksTable> {
  $$GoodsStocksTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get siteId => $composableBuilder(
      column: $table.siteId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isVollow => $composableBuilder(
      column: $table.isVollow, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get vol => $composableBuilder(
      column: $table.vol, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get minVol => $composableBuilder(
      column: $table.minVol, builder: (column) => ColumnOrderings(column));
}

class $$GoodsStocksTableAnnotationComposer
    extends Composer<_$AppDataStore, $GoodsStocksTable> {
  $$GoodsStocksTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get goodsId =>
      $composableBuilder(column: $table.goodsId, builder: (column) => column);

  GeneratedColumn<int> get siteId =>
      $composableBuilder(column: $table.siteId, builder: (column) => column);

  GeneratedColumn<bool> get isVollow =>
      $composableBuilder(column: $table.isVollow, builder: (column) => column);

  GeneratedColumn<int> get vol =>
      $composableBuilder(column: $table.vol, builder: (column) => column);

  GeneratedColumn<int> get minVol =>
      $composableBuilder(column: $table.minVol, builder: (column) => column);
}

class $$GoodsStocksTableTableManager extends RootTableManager<
    _$AppDataStore,
    $GoodsStocksTable,
    GoodsStock,
    $$GoodsStocksTableFilterComposer,
    $$GoodsStocksTableOrderingComposer,
    $$GoodsStocksTableAnnotationComposer,
    $$GoodsStocksTableCreateCompanionBuilder,
    $$GoodsStocksTableUpdateCompanionBuilder,
    (GoodsStock, BaseReferences<_$AppDataStore, $GoodsStocksTable, GoodsStock>),
    GoodsStock,
    PrefetchHooks Function()> {
  $$GoodsStocksTableTableManager(_$AppDataStore db, $GoodsStocksTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$GoodsStocksTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$GoodsStocksTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$GoodsStocksTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> goodsId = const Value.absent(),
            Value<int> siteId = const Value.absent(),
            Value<bool> isVollow = const Value.absent(),
            Value<int> vol = const Value.absent(),
            Value<int> minVol = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              GoodsStocksCompanion(
            goodsId: goodsId,
            siteId: siteId,
            isVollow: isVollow,
            vol: vol,
            minVol: minVol,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required int goodsId,
            required int siteId,
            required bool isVollow,
            required int vol,
            required int minVol,
            Value<int> rowid = const Value.absent(),
          }) =>
              GoodsStocksCompanion.insert(
            goodsId: goodsId,
            siteId: siteId,
            isVollow: isVollow,
            vol: vol,
            minVol: minVol,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$GoodsStocksTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $GoodsStocksTable,
    GoodsStock,
    $$GoodsStocksTableFilterComposer,
    $$GoodsStocksTableOrderingComposer,
    $$GoodsStocksTableAnnotationComposer,
    $$GoodsStocksTableCreateCompanionBuilder,
    $$GoodsStocksTableUpdateCompanionBuilder,
    (GoodsStock, BaseReferences<_$AppDataStore, $GoodsStocksTable, GoodsStock>),
    GoodsStock,
    PrefetchHooks Function()>;
typedef $$GoodsPartnersPricelistsTableCreateCompanionBuilder
    = GoodsPartnersPricelistsCompanion Function({
  required int goodsId,
  required int partnerPricelistId,
  required int pricelistId,
  required double discount,
  Value<int> rowid,
});
typedef $$GoodsPartnersPricelistsTableUpdateCompanionBuilder
    = GoodsPartnersPricelistsCompanion Function({
  Value<int> goodsId,
  Value<int> partnerPricelistId,
  Value<int> pricelistId,
  Value<double> discount,
  Value<int> rowid,
});

class $$GoodsPartnersPricelistsTableFilterComposer
    extends Composer<_$AppDataStore, $GoodsPartnersPricelistsTable> {
  $$GoodsPartnersPricelistsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get partnerPricelistId => $composableBuilder(
      column: $table.partnerPricelistId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get pricelistId => $composableBuilder(
      column: $table.pricelistId, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get discount => $composableBuilder(
      column: $table.discount, builder: (column) => ColumnFilters(column));
}

class $$GoodsPartnersPricelistsTableOrderingComposer
    extends Composer<_$AppDataStore, $GoodsPartnersPricelistsTable> {
  $$GoodsPartnersPricelistsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get partnerPricelistId => $composableBuilder(
      column: $table.partnerPricelistId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get pricelistId => $composableBuilder(
      column: $table.pricelistId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get discount => $composableBuilder(
      column: $table.discount, builder: (column) => ColumnOrderings(column));
}

class $$GoodsPartnersPricelistsTableAnnotationComposer
    extends Composer<_$AppDataStore, $GoodsPartnersPricelistsTable> {
  $$GoodsPartnersPricelistsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get goodsId =>
      $composableBuilder(column: $table.goodsId, builder: (column) => column);

  GeneratedColumn<int> get partnerPricelistId => $composableBuilder(
      column: $table.partnerPricelistId, builder: (column) => column);

  GeneratedColumn<int> get pricelistId => $composableBuilder(
      column: $table.pricelistId, builder: (column) => column);

  GeneratedColumn<double> get discount =>
      $composableBuilder(column: $table.discount, builder: (column) => column);
}

class $$GoodsPartnersPricelistsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $GoodsPartnersPricelistsTable,
    GoodsPartnersPricelist,
    $$GoodsPartnersPricelistsTableFilterComposer,
    $$GoodsPartnersPricelistsTableOrderingComposer,
    $$GoodsPartnersPricelistsTableAnnotationComposer,
    $$GoodsPartnersPricelistsTableCreateCompanionBuilder,
    $$GoodsPartnersPricelistsTableUpdateCompanionBuilder,
    (
      GoodsPartnersPricelist,
      BaseReferences<_$AppDataStore, $GoodsPartnersPricelistsTable,
          GoodsPartnersPricelist>
    ),
    GoodsPartnersPricelist,
    PrefetchHooks Function()> {
  $$GoodsPartnersPricelistsTableTableManager(
      _$AppDataStore db, $GoodsPartnersPricelistsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$GoodsPartnersPricelistsTableFilterComposer(
                  $db: db, $table: table),
          createOrderingComposer: () =>
              $$GoodsPartnersPricelistsTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$GoodsPartnersPricelistsTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> goodsId = const Value.absent(),
            Value<int> partnerPricelistId = const Value.absent(),
            Value<int> pricelistId = const Value.absent(),
            Value<double> discount = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              GoodsPartnersPricelistsCompanion(
            goodsId: goodsId,
            partnerPricelistId: partnerPricelistId,
            pricelistId: pricelistId,
            discount: discount,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required int goodsId,
            required int partnerPricelistId,
            required int pricelistId,
            required double discount,
            Value<int> rowid = const Value.absent(),
          }) =>
              GoodsPartnersPricelistsCompanion.insert(
            goodsId: goodsId,
            partnerPricelistId: partnerPricelistId,
            pricelistId: pricelistId,
            discount: discount,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$GoodsPartnersPricelistsTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDataStore,
        $GoodsPartnersPricelistsTable,
        GoodsPartnersPricelist,
        $$GoodsPartnersPricelistsTableFilterComposer,
        $$GoodsPartnersPricelistsTableOrderingComposer,
        $$GoodsPartnersPricelistsTableAnnotationComposer,
        $$GoodsPartnersPricelistsTableCreateCompanionBuilder,
        $$GoodsPartnersPricelistsTableUpdateCompanionBuilder,
        (
          GoodsPartnersPricelist,
          BaseReferences<_$AppDataStore, $GoodsPartnersPricelistsTable,
              GoodsPartnersPricelist>
        ),
        GoodsPartnersPricelist,
        PrefetchHooks Function()>;
typedef $$GoodsReturnStocksTableCreateCompanionBuilder
    = GoodsReturnStocksCompanion Function({
  required int goodsId,
  required int returnActTypeId,
  required int buyerId,
  required double vol,
  required int receptId,
  required int receptSubid,
  required DateTime receptDate,
  required String receptNdoc,
  Value<int> rowid,
});
typedef $$GoodsReturnStocksTableUpdateCompanionBuilder
    = GoodsReturnStocksCompanion Function({
  Value<int> goodsId,
  Value<int> returnActTypeId,
  Value<int> buyerId,
  Value<double> vol,
  Value<int> receptId,
  Value<int> receptSubid,
  Value<DateTime> receptDate,
  Value<String> receptNdoc,
  Value<int> rowid,
});

class $$GoodsReturnStocksTableFilterComposer
    extends Composer<_$AppDataStore, $GoodsReturnStocksTable> {
  $$GoodsReturnStocksTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get returnActTypeId => $composableBuilder(
      column: $table.returnActTypeId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get vol => $composableBuilder(
      column: $table.vol, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get receptId => $composableBuilder(
      column: $table.receptId, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get receptSubid => $composableBuilder(
      column: $table.receptSubid, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get receptDate => $composableBuilder(
      column: $table.receptDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get receptNdoc => $composableBuilder(
      column: $table.receptNdoc, builder: (column) => ColumnFilters(column));
}

class $$GoodsReturnStocksTableOrderingComposer
    extends Composer<_$AppDataStore, $GoodsReturnStocksTable> {
  $$GoodsReturnStocksTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get returnActTypeId => $composableBuilder(
      column: $table.returnActTypeId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get vol => $composableBuilder(
      column: $table.vol, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get receptId => $composableBuilder(
      column: $table.receptId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get receptSubid => $composableBuilder(
      column: $table.receptSubid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get receptDate => $composableBuilder(
      column: $table.receptDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get receptNdoc => $composableBuilder(
      column: $table.receptNdoc, builder: (column) => ColumnOrderings(column));
}

class $$GoodsReturnStocksTableAnnotationComposer
    extends Composer<_$AppDataStore, $GoodsReturnStocksTable> {
  $$GoodsReturnStocksTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get goodsId =>
      $composableBuilder(column: $table.goodsId, builder: (column) => column);

  GeneratedColumn<int> get returnActTypeId => $composableBuilder(
      column: $table.returnActTypeId, builder: (column) => column);

  GeneratedColumn<int> get buyerId =>
      $composableBuilder(column: $table.buyerId, builder: (column) => column);

  GeneratedColumn<double> get vol =>
      $composableBuilder(column: $table.vol, builder: (column) => column);

  GeneratedColumn<int> get receptId =>
      $composableBuilder(column: $table.receptId, builder: (column) => column);

  GeneratedColumn<int> get receptSubid => $composableBuilder(
      column: $table.receptSubid, builder: (column) => column);

  GeneratedColumn<DateTime> get receptDate => $composableBuilder(
      column: $table.receptDate, builder: (column) => column);

  GeneratedColumn<String> get receptNdoc => $composableBuilder(
      column: $table.receptNdoc, builder: (column) => column);
}

class $$GoodsReturnStocksTableTableManager extends RootTableManager<
    _$AppDataStore,
    $GoodsReturnStocksTable,
    GoodsReturnStock,
    $$GoodsReturnStocksTableFilterComposer,
    $$GoodsReturnStocksTableOrderingComposer,
    $$GoodsReturnStocksTableAnnotationComposer,
    $$GoodsReturnStocksTableCreateCompanionBuilder,
    $$GoodsReturnStocksTableUpdateCompanionBuilder,
    (
      GoodsReturnStock,
      BaseReferences<_$AppDataStore, $GoodsReturnStocksTable, GoodsReturnStock>
    ),
    GoodsReturnStock,
    PrefetchHooks Function()> {
  $$GoodsReturnStocksTableTableManager(
      _$AppDataStore db, $GoodsReturnStocksTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$GoodsReturnStocksTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$GoodsReturnStocksTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$GoodsReturnStocksTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> goodsId = const Value.absent(),
            Value<int> returnActTypeId = const Value.absent(),
            Value<int> buyerId = const Value.absent(),
            Value<double> vol = const Value.absent(),
            Value<int> receptId = const Value.absent(),
            Value<int> receptSubid = const Value.absent(),
            Value<DateTime> receptDate = const Value.absent(),
            Value<String> receptNdoc = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              GoodsReturnStocksCompanion(
            goodsId: goodsId,
            returnActTypeId: returnActTypeId,
            buyerId: buyerId,
            vol: vol,
            receptId: receptId,
            receptSubid: receptSubid,
            receptDate: receptDate,
            receptNdoc: receptNdoc,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required int goodsId,
            required int returnActTypeId,
            required int buyerId,
            required double vol,
            required int receptId,
            required int receptSubid,
            required DateTime receptDate,
            required String receptNdoc,
            Value<int> rowid = const Value.absent(),
          }) =>
              GoodsReturnStocksCompanion.insert(
            goodsId: goodsId,
            returnActTypeId: returnActTypeId,
            buyerId: buyerId,
            vol: vol,
            receptId: receptId,
            receptSubid: receptSubid,
            receptDate: receptDate,
            receptNdoc: receptNdoc,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$GoodsReturnStocksTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $GoodsReturnStocksTable,
    GoodsReturnStock,
    $$GoodsReturnStocksTableFilterComposer,
    $$GoodsReturnStocksTableOrderingComposer,
    $$GoodsReturnStocksTableAnnotationComposer,
    $$GoodsReturnStocksTableCreateCompanionBuilder,
    $$GoodsReturnStocksTableUpdateCompanionBuilder,
    (
      GoodsReturnStock,
      BaseReferences<_$AppDataStore, $GoodsReturnStocksTable, GoodsReturnStock>
    ),
    GoodsReturnStock,
    PrefetchHooks Function()>;
typedef $$ReturnActsTableCreateCompanionBuilder = ReturnActsCompanion Function({
  required String guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  Value<DateTime?> date,
  Value<String?> number,
  Value<int?> buyerId,
  required bool needPickup,
  Value<int?> returnActTypeId,
  Value<int?> receptId,
  Value<String?> receptNdoc,
  Value<DateTime?> receptDate,
  Value<int> rowid,
});
typedef $$ReturnActsTableUpdateCompanionBuilder = ReturnActsCompanion Function({
  Value<String> guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  Value<DateTime?> date,
  Value<String?> number,
  Value<int?> buyerId,
  Value<bool> needPickup,
  Value<int?> returnActTypeId,
  Value<int?> receptId,
  Value<String?> receptNdoc,
  Value<DateTime?> receptDate,
  Value<int> rowid,
});

final class $$ReturnActsTableReferences
    extends BaseReferences<_$AppDataStore, $ReturnActsTable, ReturnAct> {
  $$ReturnActsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$ReturnActLinesTable, List<ReturnActLine>>
      _returnActLinesRefsTable(_$AppDataStore db) =>
          MultiTypedResultKey.fromTable(db.returnActLines,
              aliasName: $_aliasNameGenerator(
                  db.returnActs.guid, db.returnActLines.returnActGuid));

  $$ReturnActLinesTableProcessedTableManager get returnActLinesRefs {
    final manager = $$ReturnActLinesTableTableManager($_db, $_db.returnActLines)
        .filter((f) =>
            f.returnActGuid.guid.sqlEquals($_itemColumn<String>('guid')!));

    final cache = $_typedResult.readTableOrNull(_returnActLinesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$ReturnActsTableFilterComposer
    extends Composer<_$AppDataStore, $ReturnActsTable> {
  $$ReturnActsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get number => $composableBuilder(
      column: $table.number, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needPickup => $composableBuilder(
      column: $table.needPickup, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get returnActTypeId => $composableBuilder(
      column: $table.returnActTypeId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get receptId => $composableBuilder(
      column: $table.receptId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get receptNdoc => $composableBuilder(
      column: $table.receptNdoc, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get receptDate => $composableBuilder(
      column: $table.receptDate, builder: (column) => ColumnFilters(column));

  Expression<bool> returnActLinesRefs(
      Expression<bool> Function($$ReturnActLinesTableFilterComposer f) f) {
    final $$ReturnActLinesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.guid,
        referencedTable: $db.returnActLines,
        getReferencedColumn: (t) => t.returnActGuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReturnActLinesTableFilterComposer(
              $db: $db,
              $table: $db.returnActLines,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$ReturnActsTableOrderingComposer
    extends Composer<_$AppDataStore, $ReturnActsTable> {
  $$ReturnActsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get number => $composableBuilder(
      column: $table.number, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needPickup => $composableBuilder(
      column: $table.needPickup, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get returnActTypeId => $composableBuilder(
      column: $table.returnActTypeId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get receptId => $composableBuilder(
      column: $table.receptId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get receptNdoc => $composableBuilder(
      column: $table.receptNdoc, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get receptDate => $composableBuilder(
      column: $table.receptDate, builder: (column) => ColumnOrderings(column));
}

class $$ReturnActsTableAnnotationComposer
    extends Composer<_$AppDataStore, $ReturnActsTable> {
  $$ReturnActsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get guid =>
      $composableBuilder(column: $table.guid, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => column);

  GeneratedColumn<bool> get needSync =>
      $composableBuilder(column: $table.needSync, builder: (column) => column);

  GeneratedColumn<bool> get isNew =>
      $composableBuilder(column: $table.isNew, builder: (column) => column);

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  GeneratedColumn<String> get number =>
      $composableBuilder(column: $table.number, builder: (column) => column);

  GeneratedColumn<int> get buyerId =>
      $composableBuilder(column: $table.buyerId, builder: (column) => column);

  GeneratedColumn<bool> get needPickup => $composableBuilder(
      column: $table.needPickup, builder: (column) => column);

  GeneratedColumn<int> get returnActTypeId => $composableBuilder(
      column: $table.returnActTypeId, builder: (column) => column);

  GeneratedColumn<int> get receptId =>
      $composableBuilder(column: $table.receptId, builder: (column) => column);

  GeneratedColumn<String> get receptNdoc => $composableBuilder(
      column: $table.receptNdoc, builder: (column) => column);

  GeneratedColumn<DateTime> get receptDate => $composableBuilder(
      column: $table.receptDate, builder: (column) => column);

  Expression<T> returnActLinesRefs<T extends Object>(
      Expression<T> Function($$ReturnActLinesTableAnnotationComposer a) f) {
    final $$ReturnActLinesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.guid,
        referencedTable: $db.returnActLines,
        getReferencedColumn: (t) => t.returnActGuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReturnActLinesTableAnnotationComposer(
              $db: $db,
              $table: $db.returnActLines,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$ReturnActsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $ReturnActsTable,
    ReturnAct,
    $$ReturnActsTableFilterComposer,
    $$ReturnActsTableOrderingComposer,
    $$ReturnActsTableAnnotationComposer,
    $$ReturnActsTableCreateCompanionBuilder,
    $$ReturnActsTableUpdateCompanionBuilder,
    (ReturnAct, $$ReturnActsTableReferences),
    ReturnAct,
    PrefetchHooks Function({bool returnActLinesRefs})> {
  $$ReturnActsTableTableManager(_$AppDataStore db, $ReturnActsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ReturnActsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ReturnActsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ReturnActsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> guid = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            Value<DateTime?> date = const Value.absent(),
            Value<String?> number = const Value.absent(),
            Value<int?> buyerId = const Value.absent(),
            Value<bool> needPickup = const Value.absent(),
            Value<int?> returnActTypeId = const Value.absent(),
            Value<int?> receptId = const Value.absent(),
            Value<String?> receptNdoc = const Value.absent(),
            Value<DateTime?> receptDate = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ReturnActsCompanion(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            date: date,
            number: number,
            buyerId: buyerId,
            needPickup: needPickup,
            returnActTypeId: returnActTypeId,
            receptId: receptId,
            receptNdoc: receptNdoc,
            receptDate: receptDate,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String guid,
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            Value<DateTime?> date = const Value.absent(),
            Value<String?> number = const Value.absent(),
            Value<int?> buyerId = const Value.absent(),
            required bool needPickup,
            Value<int?> returnActTypeId = const Value.absent(),
            Value<int?> receptId = const Value.absent(),
            Value<String?> receptNdoc = const Value.absent(),
            Value<DateTime?> receptDate = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ReturnActsCompanion.insert(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            date: date,
            number: number,
            buyerId: buyerId,
            needPickup: needPickup,
            returnActTypeId: returnActTypeId,
            receptId: receptId,
            receptNdoc: receptNdoc,
            receptDate: receptDate,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$ReturnActsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({returnActLinesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (returnActLinesRefs) db.returnActLines
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (returnActLinesRefs)
                    await $_getPrefetchedData(
                        currentTable: table,
                        referencedTable: $$ReturnActsTableReferences
                            ._returnActLinesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ReturnActsTableReferences(db, table, p0)
                                .returnActLinesRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.returnActGuid == item.guid),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$ReturnActsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $ReturnActsTable,
    ReturnAct,
    $$ReturnActsTableFilterComposer,
    $$ReturnActsTableOrderingComposer,
    $$ReturnActsTableAnnotationComposer,
    $$ReturnActsTableCreateCompanionBuilder,
    $$ReturnActsTableUpdateCompanionBuilder,
    (ReturnAct, $$ReturnActsTableReferences),
    ReturnAct,
    PrefetchHooks Function({bool returnActLinesRefs})>;
typedef $$ReturnActLinesTableCreateCompanionBuilder = ReturnActLinesCompanion
    Function({
  required String guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  required String returnActGuid,
  required int goodsId,
  required double vol,
  required double price,
  Value<DateTime?> productionDate,
  Value<bool?> isBad,
  required int rel,
  Value<int> rowid,
});
typedef $$ReturnActLinesTableUpdateCompanionBuilder = ReturnActLinesCompanion
    Function({
  Value<String> guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  Value<String> returnActGuid,
  Value<int> goodsId,
  Value<double> vol,
  Value<double> price,
  Value<DateTime?> productionDate,
  Value<bool?> isBad,
  Value<int> rel,
  Value<int> rowid,
});

final class $$ReturnActLinesTableReferences extends BaseReferences<
    _$AppDataStore, $ReturnActLinesTable, ReturnActLine> {
  $$ReturnActLinesTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $ReturnActsTable _returnActGuidTable(_$AppDataStore db) =>
      db.returnActs.createAlias($_aliasNameGenerator(
          db.returnActLines.returnActGuid, db.returnActs.guid));

  $$ReturnActsTableProcessedTableManager get returnActGuid {
    final $_column = $_itemColumn<String>('return_act_guid')!;

    final manager = $$ReturnActsTableTableManager($_db, $_db.returnActs)
        .filter((f) => f.guid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_returnActGuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$ReturnActLinesTableFilterComposer
    extends Composer<_$AppDataStore, $ReturnActLinesTable> {
  $$ReturnActLinesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get vol => $composableBuilder(
      column: $table.vol, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get productionDate => $composableBuilder(
      column: $table.productionDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isBad => $composableBuilder(
      column: $table.isBad, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get rel => $composableBuilder(
      column: $table.rel, builder: (column) => ColumnFilters(column));

  $$ReturnActsTableFilterComposer get returnActGuid {
    final $$ReturnActsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.returnActGuid,
        referencedTable: $db.returnActs,
        getReferencedColumn: (t) => t.guid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReturnActsTableFilterComposer(
              $db: $db,
              $table: $db.returnActs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ReturnActLinesTableOrderingComposer
    extends Composer<_$AppDataStore, $ReturnActLinesTable> {
  $$ReturnActLinesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get vol => $composableBuilder(
      column: $table.vol, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get productionDate => $composableBuilder(
      column: $table.productionDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isBad => $composableBuilder(
      column: $table.isBad, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get rel => $composableBuilder(
      column: $table.rel, builder: (column) => ColumnOrderings(column));

  $$ReturnActsTableOrderingComposer get returnActGuid {
    final $$ReturnActsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.returnActGuid,
        referencedTable: $db.returnActs,
        getReferencedColumn: (t) => t.guid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReturnActsTableOrderingComposer(
              $db: $db,
              $table: $db.returnActs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ReturnActLinesTableAnnotationComposer
    extends Composer<_$AppDataStore, $ReturnActLinesTable> {
  $$ReturnActLinesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get guid =>
      $composableBuilder(column: $table.guid, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => column);

  GeneratedColumn<bool> get needSync =>
      $composableBuilder(column: $table.needSync, builder: (column) => column);

  GeneratedColumn<bool> get isNew =>
      $composableBuilder(column: $table.isNew, builder: (column) => column);

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get goodsId =>
      $composableBuilder(column: $table.goodsId, builder: (column) => column);

  GeneratedColumn<double> get vol =>
      $composableBuilder(column: $table.vol, builder: (column) => column);

  GeneratedColumn<double> get price =>
      $composableBuilder(column: $table.price, builder: (column) => column);

  GeneratedColumn<DateTime> get productionDate => $composableBuilder(
      column: $table.productionDate, builder: (column) => column);

  GeneratedColumn<bool> get isBad =>
      $composableBuilder(column: $table.isBad, builder: (column) => column);

  GeneratedColumn<int> get rel =>
      $composableBuilder(column: $table.rel, builder: (column) => column);

  $$ReturnActsTableAnnotationComposer get returnActGuid {
    final $$ReturnActsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.returnActGuid,
        referencedTable: $db.returnActs,
        getReferencedColumn: (t) => t.guid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReturnActsTableAnnotationComposer(
              $db: $db,
              $table: $db.returnActs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ReturnActLinesTableTableManager extends RootTableManager<
    _$AppDataStore,
    $ReturnActLinesTable,
    ReturnActLine,
    $$ReturnActLinesTableFilterComposer,
    $$ReturnActLinesTableOrderingComposer,
    $$ReturnActLinesTableAnnotationComposer,
    $$ReturnActLinesTableCreateCompanionBuilder,
    $$ReturnActLinesTableUpdateCompanionBuilder,
    (ReturnActLine, $$ReturnActLinesTableReferences),
    ReturnActLine,
    PrefetchHooks Function({bool returnActGuid})> {
  $$ReturnActLinesTableTableManager(
      _$AppDataStore db, $ReturnActLinesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ReturnActLinesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ReturnActLinesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ReturnActLinesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> guid = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            Value<String> returnActGuid = const Value.absent(),
            Value<int> goodsId = const Value.absent(),
            Value<double> vol = const Value.absent(),
            Value<double> price = const Value.absent(),
            Value<DateTime?> productionDate = const Value.absent(),
            Value<bool?> isBad = const Value.absent(),
            Value<int> rel = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ReturnActLinesCompanion(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            returnActGuid: returnActGuid,
            goodsId: goodsId,
            vol: vol,
            price: price,
            productionDate: productionDate,
            isBad: isBad,
            rel: rel,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String guid,
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            required String returnActGuid,
            required int goodsId,
            required double vol,
            required double price,
            Value<DateTime?> productionDate = const Value.absent(),
            Value<bool?> isBad = const Value.absent(),
            required int rel,
            Value<int> rowid = const Value.absent(),
          }) =>
              ReturnActLinesCompanion.insert(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            returnActGuid: returnActGuid,
            goodsId: goodsId,
            vol: vol,
            price: price,
            productionDate: productionDate,
            isBad: isBad,
            rel: rel,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$ReturnActLinesTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({returnActGuid = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (returnActGuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.returnActGuid,
                    referencedTable:
                        $$ReturnActLinesTableReferences._returnActGuidTable(db),
                    referencedColumn: $$ReturnActLinesTableReferences
                        ._returnActGuidTable(db)
                        .guid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$ReturnActLinesTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $ReturnActLinesTable,
    ReturnActLine,
    $$ReturnActLinesTableFilterComposer,
    $$ReturnActLinesTableOrderingComposer,
    $$ReturnActLinesTableAnnotationComposer,
    $$ReturnActLinesTableCreateCompanionBuilder,
    $$ReturnActLinesTableUpdateCompanionBuilder,
    (ReturnActLine, $$ReturnActLinesTableReferences),
    ReturnActLine,
    PrefetchHooks Function({bool returnActGuid})>;
typedef $$ReturnActTypesTableCreateCompanionBuilder = ReturnActTypesCompanion
    Function({
  Value<int> id,
  required String name,
});
typedef $$ReturnActTypesTableUpdateCompanionBuilder = ReturnActTypesCompanion
    Function({
  Value<int> id,
  Value<String> name,
});

class $$ReturnActTypesTableFilterComposer
    extends Composer<_$AppDataStore, $ReturnActTypesTable> {
  $$ReturnActTypesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));
}

class $$ReturnActTypesTableOrderingComposer
    extends Composer<_$AppDataStore, $ReturnActTypesTable> {
  $$ReturnActTypesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));
}

class $$ReturnActTypesTableAnnotationComposer
    extends Composer<_$AppDataStore, $ReturnActTypesTable> {
  $$ReturnActTypesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);
}

class $$ReturnActTypesTableTableManager extends RootTableManager<
    _$AppDataStore,
    $ReturnActTypesTable,
    ReturnActType,
    $$ReturnActTypesTableFilterComposer,
    $$ReturnActTypesTableOrderingComposer,
    $$ReturnActTypesTableAnnotationComposer,
    $$ReturnActTypesTableCreateCompanionBuilder,
    $$ReturnActTypesTableUpdateCompanionBuilder,
    (
      ReturnActType,
      BaseReferences<_$AppDataStore, $ReturnActTypesTable, ReturnActType>
    ),
    ReturnActType,
    PrefetchHooks Function()> {
  $$ReturnActTypesTableTableManager(
      _$AppDataStore db, $ReturnActTypesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ReturnActTypesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ReturnActTypesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ReturnActTypesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> name = const Value.absent(),
          }) =>
              ReturnActTypesCompanion(
            id: id,
            name: name,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String name,
          }) =>
              ReturnActTypesCompanion.insert(
            id: id,
            name: name,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$ReturnActTypesTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $ReturnActTypesTable,
    ReturnActType,
    $$ReturnActTypesTableFilterComposer,
    $$ReturnActTypesTableOrderingComposer,
    $$ReturnActTypesTableAnnotationComposer,
    $$ReturnActTypesTableCreateCompanionBuilder,
    $$ReturnActTypesTableUpdateCompanionBuilder,
    (
      ReturnActType,
      BaseReferences<_$AppDataStore, $ReturnActTypesTable, ReturnActType>
    ),
    ReturnActType,
    PrefetchHooks Function()>;
typedef $$PartnersReturnActTypesTableCreateCompanionBuilder
    = PartnersReturnActTypesCompanion Function({
  required int returnActTypeId,
  required int partnerId,
  Value<int> rowid,
});
typedef $$PartnersReturnActTypesTableUpdateCompanionBuilder
    = PartnersReturnActTypesCompanion Function({
  Value<int> returnActTypeId,
  Value<int> partnerId,
  Value<int> rowid,
});

class $$PartnersReturnActTypesTableFilterComposer
    extends Composer<_$AppDataStore, $PartnersReturnActTypesTable> {
  $$PartnersReturnActTypesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get returnActTypeId => $composableBuilder(
      column: $table.returnActTypeId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get partnerId => $composableBuilder(
      column: $table.partnerId, builder: (column) => ColumnFilters(column));
}

class $$PartnersReturnActTypesTableOrderingComposer
    extends Composer<_$AppDataStore, $PartnersReturnActTypesTable> {
  $$PartnersReturnActTypesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get returnActTypeId => $composableBuilder(
      column: $table.returnActTypeId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get partnerId => $composableBuilder(
      column: $table.partnerId, builder: (column) => ColumnOrderings(column));
}

class $$PartnersReturnActTypesTableAnnotationComposer
    extends Composer<_$AppDataStore, $PartnersReturnActTypesTable> {
  $$PartnersReturnActTypesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get returnActTypeId => $composableBuilder(
      column: $table.returnActTypeId, builder: (column) => column);

  GeneratedColumn<int> get partnerId =>
      $composableBuilder(column: $table.partnerId, builder: (column) => column);
}

class $$PartnersReturnActTypesTableTableManager extends RootTableManager<
    _$AppDataStore,
    $PartnersReturnActTypesTable,
    PartnersReturnActType,
    $$PartnersReturnActTypesTableFilterComposer,
    $$PartnersReturnActTypesTableOrderingComposer,
    $$PartnersReturnActTypesTableAnnotationComposer,
    $$PartnersReturnActTypesTableCreateCompanionBuilder,
    $$PartnersReturnActTypesTableUpdateCompanionBuilder,
    (
      PartnersReturnActType,
      BaseReferences<_$AppDataStore, $PartnersReturnActTypesTable,
          PartnersReturnActType>
    ),
    PartnersReturnActType,
    PrefetchHooks Function()> {
  $$PartnersReturnActTypesTableTableManager(
      _$AppDataStore db, $PartnersReturnActTypesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PartnersReturnActTypesTableFilterComposer(
                  $db: db, $table: table),
          createOrderingComposer: () =>
              $$PartnersReturnActTypesTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PartnersReturnActTypesTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> returnActTypeId = const Value.absent(),
            Value<int> partnerId = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              PartnersReturnActTypesCompanion(
            returnActTypeId: returnActTypeId,
            partnerId: partnerId,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required int returnActTypeId,
            required int partnerId,
            Value<int> rowid = const Value.absent(),
          }) =>
              PartnersReturnActTypesCompanion.insert(
            returnActTypeId: returnActTypeId,
            partnerId: partnerId,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$PartnersReturnActTypesTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDataStore,
        $PartnersReturnActTypesTable,
        PartnersReturnActType,
        $$PartnersReturnActTypesTableFilterComposer,
        $$PartnersReturnActTypesTableOrderingComposer,
        $$PartnersReturnActTypesTableAnnotationComposer,
        $$PartnersReturnActTypesTableCreateCompanionBuilder,
        $$PartnersReturnActTypesTableUpdateCompanionBuilder,
        (
          PartnersReturnActType,
          BaseReferences<_$AppDataStore, $PartnersReturnActTypesTable,
              PartnersReturnActType>
        ),
        PartnersReturnActType,
        PrefetchHooks Function()>;
typedef $$RoutePointsTableCreateCompanionBuilder = RoutePointsCompanion
    Function({
  Value<int> id,
  required DateTime date,
  required int buyerId,
  Value<bool?> visited,
});
typedef $$RoutePointsTableUpdateCompanionBuilder = RoutePointsCompanion
    Function({
  Value<int> id,
  Value<DateTime> date,
  Value<int> buyerId,
  Value<bool?> visited,
});

class $$RoutePointsTableFilterComposer
    extends Composer<_$AppDataStore, $RoutePointsTable> {
  $$RoutePointsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get visited => $composableBuilder(
      column: $table.visited, builder: (column) => ColumnFilters(column));
}

class $$RoutePointsTableOrderingComposer
    extends Composer<_$AppDataStore, $RoutePointsTable> {
  $$RoutePointsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get visited => $composableBuilder(
      column: $table.visited, builder: (column) => ColumnOrderings(column));
}

class $$RoutePointsTableAnnotationComposer
    extends Composer<_$AppDataStore, $RoutePointsTable> {
  $$RoutePointsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  GeneratedColumn<int> get buyerId =>
      $composableBuilder(column: $table.buyerId, builder: (column) => column);

  GeneratedColumn<bool> get visited =>
      $composableBuilder(column: $table.visited, builder: (column) => column);
}

class $$RoutePointsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $RoutePointsTable,
    RoutePoint,
    $$RoutePointsTableFilterComposer,
    $$RoutePointsTableOrderingComposer,
    $$RoutePointsTableAnnotationComposer,
    $$RoutePointsTableCreateCompanionBuilder,
    $$RoutePointsTableUpdateCompanionBuilder,
    (RoutePoint, BaseReferences<_$AppDataStore, $RoutePointsTable, RoutePoint>),
    RoutePoint,
    PrefetchHooks Function()> {
  $$RoutePointsTableTableManager(_$AppDataStore db, $RoutePointsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$RoutePointsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$RoutePointsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$RoutePointsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<DateTime> date = const Value.absent(),
            Value<int> buyerId = const Value.absent(),
            Value<bool?> visited = const Value.absent(),
          }) =>
              RoutePointsCompanion(
            id: id,
            date: date,
            buyerId: buyerId,
            visited: visited,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required DateTime date,
            required int buyerId,
            Value<bool?> visited = const Value.absent(),
          }) =>
              RoutePointsCompanion.insert(
            id: id,
            date: date,
            buyerId: buyerId,
            visited: visited,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$RoutePointsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $RoutePointsTable,
    RoutePoint,
    $$RoutePointsTableFilterComposer,
    $$RoutePointsTableOrderingComposer,
    $$RoutePointsTableAnnotationComposer,
    $$RoutePointsTableCreateCompanionBuilder,
    $$RoutePointsTableUpdateCompanionBuilder,
    (RoutePoint, BaseReferences<_$AppDataStore, $RoutePointsTable, RoutePoint>),
    RoutePoint,
    PrefetchHooks Function()>;
typedef $$VisitSkipReasonsTableCreateCompanionBuilder
    = VisitSkipReasonsCompanion Function({
  Value<int> id,
  required String name,
});
typedef $$VisitSkipReasonsTableUpdateCompanionBuilder
    = VisitSkipReasonsCompanion Function({
  Value<int> id,
  Value<String> name,
});

class $$VisitSkipReasonsTableFilterComposer
    extends Composer<_$AppDataStore, $VisitSkipReasonsTable> {
  $$VisitSkipReasonsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));
}

class $$VisitSkipReasonsTableOrderingComposer
    extends Composer<_$AppDataStore, $VisitSkipReasonsTable> {
  $$VisitSkipReasonsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));
}

class $$VisitSkipReasonsTableAnnotationComposer
    extends Composer<_$AppDataStore, $VisitSkipReasonsTable> {
  $$VisitSkipReasonsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);
}

class $$VisitSkipReasonsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $VisitSkipReasonsTable,
    VisitSkipReason,
    $$VisitSkipReasonsTableFilterComposer,
    $$VisitSkipReasonsTableOrderingComposer,
    $$VisitSkipReasonsTableAnnotationComposer,
    $$VisitSkipReasonsTableCreateCompanionBuilder,
    $$VisitSkipReasonsTableUpdateCompanionBuilder,
    (
      VisitSkipReason,
      BaseReferences<_$AppDataStore, $VisitSkipReasonsTable, VisitSkipReason>
    ),
    VisitSkipReason,
    PrefetchHooks Function()> {
  $$VisitSkipReasonsTableTableManager(
      _$AppDataStore db, $VisitSkipReasonsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$VisitSkipReasonsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$VisitSkipReasonsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$VisitSkipReasonsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> name = const Value.absent(),
          }) =>
              VisitSkipReasonsCompanion(
            id: id,
            name: name,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String name,
          }) =>
              VisitSkipReasonsCompanion.insert(
            id: id,
            name: name,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$VisitSkipReasonsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $VisitSkipReasonsTable,
    VisitSkipReason,
    $$VisitSkipReasonsTableFilterComposer,
    $$VisitSkipReasonsTableOrderingComposer,
    $$VisitSkipReasonsTableAnnotationComposer,
    $$VisitSkipReasonsTableCreateCompanionBuilder,
    $$VisitSkipReasonsTableUpdateCompanionBuilder,
    (
      VisitSkipReason,
      BaseReferences<_$AppDataStore, $VisitSkipReasonsTable, VisitSkipReason>
    ),
    VisitSkipReason,
    PrefetchHooks Function()>;
typedef $$VisitsTableCreateCompanionBuilder = VisitsCompanion Function({
  required String guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  required DateTime date,
  required int buyerId,
  Value<int?> routePointId,
  Value<int?> visitSkipReasonId,
  required bool needCheckGL,
  required bool needTakePhotos,
  required bool needFillSoftware,
  Value<int> rowid,
});
typedef $$VisitsTableUpdateCompanionBuilder = VisitsCompanion Function({
  Value<String> guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  Value<DateTime> date,
  Value<int> buyerId,
  Value<int?> routePointId,
  Value<int?> visitSkipReasonId,
  Value<bool> needCheckGL,
  Value<bool> needTakePhotos,
  Value<bool> needFillSoftware,
  Value<int> rowid,
});

final class $$VisitsTableReferences
    extends BaseReferences<_$AppDataStore, $VisitsTable, Visit> {
  $$VisitsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$VisitImagesTable, List<VisitImage>>
      _visitImagesRefsTable(_$AppDataStore db) => MultiTypedResultKey.fromTable(
          db.visitImages,
          aliasName:
              $_aliasNameGenerator(db.visits.guid, db.visitImages.visitGuid));

  $$VisitImagesTableProcessedTableManager get visitImagesRefs {
    final manager = $$VisitImagesTableTableManager($_db, $_db.visitImages)
        .filter(
            (f) => f.visitGuid.guid.sqlEquals($_itemColumn<String>('guid')!));

    final cache = $_typedResult.readTableOrNull(_visitImagesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$VisitSoftwaresTable, List<VisitSoftware>>
      _visitSoftwaresRefsTable(_$AppDataStore db) =>
          MultiTypedResultKey.fromTable(db.visitSoftwares,
              aliasName: $_aliasNameGenerator(
                  db.visits.guid, db.visitSoftwares.visitGuid));

  $$VisitSoftwaresTableProcessedTableManager get visitSoftwaresRefs {
    final manager = $$VisitSoftwaresTableTableManager($_db, $_db.visitSoftwares)
        .filter(
            (f) => f.visitGuid.guid.sqlEquals($_itemColumn<String>('guid')!));

    final cache = $_typedResult.readTableOrNull(_visitSoftwaresRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$VisitGoodsListsTable, List<VisitGoodsList>>
      _visitGoodsListsRefsTable(_$AppDataStore db) =>
          MultiTypedResultKey.fromTable(db.visitGoodsLists,
              aliasName: $_aliasNameGenerator(
                  db.visits.guid, db.visitGoodsLists.visitGuid));

  $$VisitGoodsListsTableProcessedTableManager get visitGoodsListsRefs {
    final manager =
        $$VisitGoodsListsTableTableManager($_db, $_db.visitGoodsLists).filter(
            (f) => f.visitGuid.guid.sqlEquals($_itemColumn<String>('guid')!));

    final cache =
        $_typedResult.readTableOrNull(_visitGoodsListsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$VisitsTableFilterComposer
    extends Composer<_$AppDataStore, $VisitsTable> {
  $$VisitsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get routePointId => $composableBuilder(
      column: $table.routePointId, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get visitSkipReasonId => $composableBuilder(
      column: $table.visitSkipReasonId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needCheckGL => $composableBuilder(
      column: $table.needCheckGL, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needTakePhotos => $composableBuilder(
      column: $table.needTakePhotos,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needFillSoftware => $composableBuilder(
      column: $table.needFillSoftware,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needDetails => $composableBuilder(
      column: $table.needDetails, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get visited => $composableBuilder(
      column: $table.visited, builder: (column) => ColumnFilters(column));

  Expression<bool> visitImagesRefs(
      Expression<bool> Function($$VisitImagesTableFilterComposer f) f) {
    final $$VisitImagesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.guid,
        referencedTable: $db.visitImages,
        getReferencedColumn: (t) => t.visitGuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$VisitImagesTableFilterComposer(
              $db: $db,
              $table: $db.visitImages,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> visitSoftwaresRefs(
      Expression<bool> Function($$VisitSoftwaresTableFilterComposer f) f) {
    final $$VisitSoftwaresTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.guid,
        referencedTable: $db.visitSoftwares,
        getReferencedColumn: (t) => t.visitGuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$VisitSoftwaresTableFilterComposer(
              $db: $db,
              $table: $db.visitSoftwares,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> visitGoodsListsRefs(
      Expression<bool> Function($$VisitGoodsListsTableFilterComposer f) f) {
    final $$VisitGoodsListsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.guid,
        referencedTable: $db.visitGoodsLists,
        getReferencedColumn: (t) => t.visitGuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$VisitGoodsListsTableFilterComposer(
              $db: $db,
              $table: $db.visitGoodsLists,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$VisitsTableOrderingComposer
    extends Composer<_$AppDataStore, $VisitsTable> {
  $$VisitsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get buyerId => $composableBuilder(
      column: $table.buyerId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get routePointId => $composableBuilder(
      column: $table.routePointId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get visitSkipReasonId => $composableBuilder(
      column: $table.visitSkipReasonId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needCheckGL => $composableBuilder(
      column: $table.needCheckGL, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needTakePhotos => $composableBuilder(
      column: $table.needTakePhotos,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needFillSoftware => $composableBuilder(
      column: $table.needFillSoftware,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needDetails => $composableBuilder(
      column: $table.needDetails, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get visited => $composableBuilder(
      column: $table.visited, builder: (column) => ColumnOrderings(column));
}

class $$VisitsTableAnnotationComposer
    extends Composer<_$AppDataStore, $VisitsTable> {
  $$VisitsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get guid =>
      $composableBuilder(column: $table.guid, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => column);

  GeneratedColumn<bool> get needSync =>
      $composableBuilder(column: $table.needSync, builder: (column) => column);

  GeneratedColumn<bool> get isNew =>
      $composableBuilder(column: $table.isNew, builder: (column) => column);

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  GeneratedColumn<int> get buyerId =>
      $composableBuilder(column: $table.buyerId, builder: (column) => column);

  GeneratedColumn<int> get routePointId => $composableBuilder(
      column: $table.routePointId, builder: (column) => column);

  GeneratedColumn<int> get visitSkipReasonId => $composableBuilder(
      column: $table.visitSkipReasonId, builder: (column) => column);

  GeneratedColumn<bool> get needCheckGL => $composableBuilder(
      column: $table.needCheckGL, builder: (column) => column);

  GeneratedColumn<bool> get needTakePhotos => $composableBuilder(
      column: $table.needTakePhotos, builder: (column) => column);

  GeneratedColumn<bool> get needFillSoftware => $composableBuilder(
      column: $table.needFillSoftware, builder: (column) => column);

  GeneratedColumn<bool> get needDetails => $composableBuilder(
      column: $table.needDetails, builder: (column) => column);

  GeneratedColumn<bool> get visited =>
      $composableBuilder(column: $table.visited, builder: (column) => column);

  Expression<T> visitImagesRefs<T extends Object>(
      Expression<T> Function($$VisitImagesTableAnnotationComposer a) f) {
    final $$VisitImagesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.guid,
        referencedTable: $db.visitImages,
        getReferencedColumn: (t) => t.visitGuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$VisitImagesTableAnnotationComposer(
              $db: $db,
              $table: $db.visitImages,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> visitSoftwaresRefs<T extends Object>(
      Expression<T> Function($$VisitSoftwaresTableAnnotationComposer a) f) {
    final $$VisitSoftwaresTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.guid,
        referencedTable: $db.visitSoftwares,
        getReferencedColumn: (t) => t.visitGuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$VisitSoftwaresTableAnnotationComposer(
              $db: $db,
              $table: $db.visitSoftwares,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> visitGoodsListsRefs<T extends Object>(
      Expression<T> Function($$VisitGoodsListsTableAnnotationComposer a) f) {
    final $$VisitGoodsListsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.guid,
        referencedTable: $db.visitGoodsLists,
        getReferencedColumn: (t) => t.visitGuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$VisitGoodsListsTableAnnotationComposer(
              $db: $db,
              $table: $db.visitGoodsLists,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$VisitsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $VisitsTable,
    Visit,
    $$VisitsTableFilterComposer,
    $$VisitsTableOrderingComposer,
    $$VisitsTableAnnotationComposer,
    $$VisitsTableCreateCompanionBuilder,
    $$VisitsTableUpdateCompanionBuilder,
    (Visit, $$VisitsTableReferences),
    Visit,
    PrefetchHooks Function(
        {bool visitImagesRefs,
        bool visitSoftwaresRefs,
        bool visitGoodsListsRefs})> {
  $$VisitsTableTableManager(_$AppDataStore db, $VisitsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$VisitsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$VisitsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$VisitsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> guid = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            Value<DateTime> date = const Value.absent(),
            Value<int> buyerId = const Value.absent(),
            Value<int?> routePointId = const Value.absent(),
            Value<int?> visitSkipReasonId = const Value.absent(),
            Value<bool> needCheckGL = const Value.absent(),
            Value<bool> needTakePhotos = const Value.absent(),
            Value<bool> needFillSoftware = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              VisitsCompanion(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            date: date,
            buyerId: buyerId,
            routePointId: routePointId,
            visitSkipReasonId: visitSkipReasonId,
            needCheckGL: needCheckGL,
            needTakePhotos: needTakePhotos,
            needFillSoftware: needFillSoftware,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String guid,
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            required DateTime date,
            required int buyerId,
            Value<int?> routePointId = const Value.absent(),
            Value<int?> visitSkipReasonId = const Value.absent(),
            required bool needCheckGL,
            required bool needTakePhotos,
            required bool needFillSoftware,
            Value<int> rowid = const Value.absent(),
          }) =>
              VisitsCompanion.insert(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            date: date,
            buyerId: buyerId,
            routePointId: routePointId,
            visitSkipReasonId: visitSkipReasonId,
            needCheckGL: needCheckGL,
            needTakePhotos: needTakePhotos,
            needFillSoftware: needFillSoftware,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $$VisitsTableReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: (
              {visitImagesRefs = false,
              visitSoftwaresRefs = false,
              visitGoodsListsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (visitImagesRefs) db.visitImages,
                if (visitSoftwaresRefs) db.visitSoftwares,
                if (visitGoodsListsRefs) db.visitGoodsLists
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (visitImagesRefs)
                    await $_getPrefetchedData(
                        currentTable: table,
                        referencedTable:
                            $$VisitsTableReferences._visitImagesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$VisitsTableReferences(db, table, p0)
                                .visitImagesRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.visitGuid == item.guid),
                        typedResults: items),
                  if (visitSoftwaresRefs)
                    await $_getPrefetchedData(
                        currentTable: table,
                        referencedTable: $$VisitsTableReferences
                            ._visitSoftwaresRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$VisitsTableReferences(db, table, p0)
                                .visitSoftwaresRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.visitGuid == item.guid),
                        typedResults: items),
                  if (visitGoodsListsRefs)
                    await $_getPrefetchedData(
                        currentTable: table,
                        referencedTable: $$VisitsTableReferences
                            ._visitGoodsListsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$VisitsTableReferences(db, table, p0)
                                .visitGoodsListsRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.visitGuid == item.guid),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$VisitsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $VisitsTable,
    Visit,
    $$VisitsTableFilterComposer,
    $$VisitsTableOrderingComposer,
    $$VisitsTableAnnotationComposer,
    $$VisitsTableCreateCompanionBuilder,
    $$VisitsTableUpdateCompanionBuilder,
    (Visit, $$VisitsTableReferences),
    Visit,
    PrefetchHooks Function(
        {bool visitImagesRefs,
        bool visitSoftwaresRefs,
        bool visitGoodsListsRefs})>;
typedef $$SitesTableCreateCompanionBuilder = SitesCompanion Function({
  Value<int> id,
  required String name,
});
typedef $$SitesTableUpdateCompanionBuilder = SitesCompanion Function({
  Value<int> id,
  Value<String> name,
});

class $$SitesTableFilterComposer extends Composer<_$AppDataStore, $SitesTable> {
  $$SitesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));
}

class $$SitesTableOrderingComposer
    extends Composer<_$AppDataStore, $SitesTable> {
  $$SitesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));
}

class $$SitesTableAnnotationComposer
    extends Composer<_$AppDataStore, $SitesTable> {
  $$SitesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);
}

class $$SitesTableTableManager extends RootTableManager<
    _$AppDataStore,
    $SitesTable,
    Site,
    $$SitesTableFilterComposer,
    $$SitesTableOrderingComposer,
    $$SitesTableAnnotationComposer,
    $$SitesTableCreateCompanionBuilder,
    $$SitesTableUpdateCompanionBuilder,
    (Site, BaseReferences<_$AppDataStore, $SitesTable, Site>),
    Site,
    PrefetchHooks Function()> {
  $$SitesTableTableManager(_$AppDataStore db, $SitesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SitesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SitesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SitesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> name = const Value.absent(),
          }) =>
              SitesCompanion(
            id: id,
            name: name,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String name,
          }) =>
              SitesCompanion.insert(
            id: id,
            name: name,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$SitesTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $SitesTable,
    Site,
    $$SitesTableFilterComposer,
    $$SitesTableOrderingComposer,
    $$SitesTableAnnotationComposer,
    $$SitesTableCreateCompanionBuilder,
    $$SitesTableUpdateCompanionBuilder,
    (Site, BaseReferences<_$AppDataStore, $SitesTable, Site>),
    Site,
    PrefetchHooks Function()>;
typedef $$NtDeptTypesTableCreateCompanionBuilder = NtDeptTypesCompanion
    Function({
  Value<int> id,
  required String name,
});
typedef $$NtDeptTypesTableUpdateCompanionBuilder = NtDeptTypesCompanion
    Function({
  Value<int> id,
  Value<String> name,
});

class $$NtDeptTypesTableFilterComposer
    extends Composer<_$AppDataStore, $NtDeptTypesTable> {
  $$NtDeptTypesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));
}

class $$NtDeptTypesTableOrderingComposer
    extends Composer<_$AppDataStore, $NtDeptTypesTable> {
  $$NtDeptTypesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));
}

class $$NtDeptTypesTableAnnotationComposer
    extends Composer<_$AppDataStore, $NtDeptTypesTable> {
  $$NtDeptTypesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);
}

class $$NtDeptTypesTableTableManager extends RootTableManager<
    _$AppDataStore,
    $NtDeptTypesTable,
    NtDeptType,
    $$NtDeptTypesTableFilterComposer,
    $$NtDeptTypesTableOrderingComposer,
    $$NtDeptTypesTableAnnotationComposer,
    $$NtDeptTypesTableCreateCompanionBuilder,
    $$NtDeptTypesTableUpdateCompanionBuilder,
    (NtDeptType, BaseReferences<_$AppDataStore, $NtDeptTypesTable, NtDeptType>),
    NtDeptType,
    PrefetchHooks Function()> {
  $$NtDeptTypesTableTableManager(_$AppDataStore db, $NtDeptTypesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$NtDeptTypesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$NtDeptTypesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$NtDeptTypesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> name = const Value.absent(),
          }) =>
              NtDeptTypesCompanion(
            id: id,
            name: name,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String name,
          }) =>
              NtDeptTypesCompanion.insert(
            id: id,
            name: name,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$NtDeptTypesTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $NtDeptTypesTable,
    NtDeptType,
    $$NtDeptTypesTableFilterComposer,
    $$NtDeptTypesTableOrderingComposer,
    $$NtDeptTypesTableAnnotationComposer,
    $$NtDeptTypesTableCreateCompanionBuilder,
    $$NtDeptTypesTableUpdateCompanionBuilder,
    (NtDeptType, BaseReferences<_$AppDataStore, $NtDeptTypesTable, NtDeptType>),
    NtDeptType,
    PrefetchHooks Function()>;
typedef $$GoodsListsTableCreateCompanionBuilder = GoodsListsCompanion Function({
  Value<int> id,
  required String name,
});
typedef $$GoodsListsTableUpdateCompanionBuilder = GoodsListsCompanion Function({
  Value<int> id,
  Value<String> name,
});

class $$GoodsListsTableFilterComposer
    extends Composer<_$AppDataStore, $GoodsListsTable> {
  $$GoodsListsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));
}

class $$GoodsListsTableOrderingComposer
    extends Composer<_$AppDataStore, $GoodsListsTable> {
  $$GoodsListsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));
}

class $$GoodsListsTableAnnotationComposer
    extends Composer<_$AppDataStore, $GoodsListsTable> {
  $$GoodsListsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);
}

class $$GoodsListsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $GoodsListsTable,
    GoodsList,
    $$GoodsListsTableFilterComposer,
    $$GoodsListsTableOrderingComposer,
    $$GoodsListsTableAnnotationComposer,
    $$GoodsListsTableCreateCompanionBuilder,
    $$GoodsListsTableUpdateCompanionBuilder,
    (GoodsList, BaseReferences<_$AppDataStore, $GoodsListsTable, GoodsList>),
    GoodsList,
    PrefetchHooks Function()> {
  $$GoodsListsTableTableManager(_$AppDataStore db, $GoodsListsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$GoodsListsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$GoodsListsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$GoodsListsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> name = const Value.absent(),
          }) =>
              GoodsListsCompanion(
            id: id,
            name: name,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String name,
          }) =>
              GoodsListsCompanion.insert(
            id: id,
            name: name,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$GoodsListsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $GoodsListsTable,
    GoodsList,
    $$GoodsListsTableFilterComposer,
    $$GoodsListsTableOrderingComposer,
    $$GoodsListsTableAnnotationComposer,
    $$GoodsListsTableCreateCompanionBuilder,
    $$GoodsListsTableUpdateCompanionBuilder,
    (GoodsList, BaseReferences<_$AppDataStore, $GoodsListsTable, GoodsList>),
    GoodsList,
    PrefetchHooks Function()>;
typedef $$AllGoodsListGoodsTableCreateCompanionBuilder
    = AllGoodsListGoodsCompanion Function({
  required int goodsListId,
  required int goodsId,
  Value<int> rowid,
});
typedef $$AllGoodsListGoodsTableUpdateCompanionBuilder
    = AllGoodsListGoodsCompanion Function({
  Value<int> goodsListId,
  Value<int> goodsId,
  Value<int> rowid,
});

class $$AllGoodsListGoodsTableFilterComposer
    extends Composer<_$AppDataStore, $AllGoodsListGoodsTable> {
  $$AllGoodsListGoodsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get goodsListId => $composableBuilder(
      column: $table.goodsListId, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnFilters(column));
}

class $$AllGoodsListGoodsTableOrderingComposer
    extends Composer<_$AppDataStore, $AllGoodsListGoodsTable> {
  $$AllGoodsListGoodsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get goodsListId => $composableBuilder(
      column: $table.goodsListId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnOrderings(column));
}

class $$AllGoodsListGoodsTableAnnotationComposer
    extends Composer<_$AppDataStore, $AllGoodsListGoodsTable> {
  $$AllGoodsListGoodsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get goodsListId => $composableBuilder(
      column: $table.goodsListId, builder: (column) => column);

  GeneratedColumn<int> get goodsId =>
      $composableBuilder(column: $table.goodsId, builder: (column) => column);
}

class $$AllGoodsListGoodsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $AllGoodsListGoodsTable,
    GoodsListGoods,
    $$AllGoodsListGoodsTableFilterComposer,
    $$AllGoodsListGoodsTableOrderingComposer,
    $$AllGoodsListGoodsTableAnnotationComposer,
    $$AllGoodsListGoodsTableCreateCompanionBuilder,
    $$AllGoodsListGoodsTableUpdateCompanionBuilder,
    (
      GoodsListGoods,
      BaseReferences<_$AppDataStore, $AllGoodsListGoodsTable, GoodsListGoods>
    ),
    GoodsListGoods,
    PrefetchHooks Function()> {
  $$AllGoodsListGoodsTableTableManager(
      _$AppDataStore db, $AllGoodsListGoodsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AllGoodsListGoodsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AllGoodsListGoodsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AllGoodsListGoodsTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> goodsListId = const Value.absent(),
            Value<int> goodsId = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              AllGoodsListGoodsCompanion(
            goodsListId: goodsListId,
            goodsId: goodsId,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required int goodsListId,
            required int goodsId,
            Value<int> rowid = const Value.absent(),
          }) =>
              AllGoodsListGoodsCompanion.insert(
            goodsListId: goodsListId,
            goodsId: goodsId,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$AllGoodsListGoodsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $AllGoodsListGoodsTable,
    GoodsListGoods,
    $$AllGoodsListGoodsTableFilterComposer,
    $$AllGoodsListGoodsTableOrderingComposer,
    $$AllGoodsListGoodsTableAnnotationComposer,
    $$AllGoodsListGoodsTableCreateCompanionBuilder,
    $$AllGoodsListGoodsTableUpdateCompanionBuilder,
    (
      GoodsListGoods,
      BaseReferences<_$AppDataStore, $AllGoodsListGoodsTable, GoodsListGoods>
    ),
    GoodsListGoods,
    PrefetchHooks Function()>;
typedef $$VisitImagesTableCreateCompanionBuilder = VisitImagesCompanion
    Function({
  required double latitude,
  required double longitude,
  required double accuracy,
  required String imageUrl,
  required String imageKey,
  required String guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  required int id,
  required String visitGuid,
  Value<int> rowid,
});
typedef $$VisitImagesTableUpdateCompanionBuilder = VisitImagesCompanion
    Function({
  Value<double> latitude,
  Value<double> longitude,
  Value<double> accuracy,
  Value<String> imageUrl,
  Value<String> imageKey,
  Value<String> guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int> id,
  Value<String> visitGuid,
  Value<int> rowid,
});

final class $$VisitImagesTableReferences
    extends BaseReferences<_$AppDataStore, $VisitImagesTable, VisitImage> {
  $$VisitImagesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $VisitsTable _visitGuidTable(_$AppDataStore db) =>
      db.visits.createAlias(
          $_aliasNameGenerator(db.visitImages.visitGuid, db.visits.guid));

  $$VisitsTableProcessedTableManager get visitGuid {
    final $_column = $_itemColumn<String>('visit_guid')!;

    final manager = $$VisitsTableTableManager($_db, $_db.visits)
        .filter((f) => f.guid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_visitGuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$VisitImagesTableFilterComposer
    extends Composer<_$AppDataStore, $VisitImagesTable> {
  $$VisitImagesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<double> get latitude => $composableBuilder(
      column: $table.latitude, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get longitude => $composableBuilder(
      column: $table.longitude, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get accuracy => $composableBuilder(
      column: $table.accuracy, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get imageUrl => $composableBuilder(
      column: $table.imageUrl, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get imageKey => $composableBuilder(
      column: $table.imageKey, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  $$VisitsTableFilterComposer get visitGuid {
    final $$VisitsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.visitGuid,
        referencedTable: $db.visits,
        getReferencedColumn: (t) => t.guid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$VisitsTableFilterComposer(
              $db: $db,
              $table: $db.visits,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$VisitImagesTableOrderingComposer
    extends Composer<_$AppDataStore, $VisitImagesTable> {
  $$VisitImagesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<double> get latitude => $composableBuilder(
      column: $table.latitude, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get longitude => $composableBuilder(
      column: $table.longitude, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get accuracy => $composableBuilder(
      column: $table.accuracy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get imageUrl => $composableBuilder(
      column: $table.imageUrl, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get imageKey => $composableBuilder(
      column: $table.imageKey, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  $$VisitsTableOrderingComposer get visitGuid {
    final $$VisitsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.visitGuid,
        referencedTable: $db.visits,
        getReferencedColumn: (t) => t.guid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$VisitsTableOrderingComposer(
              $db: $db,
              $table: $db.visits,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$VisitImagesTableAnnotationComposer
    extends Composer<_$AppDataStore, $VisitImagesTable> {
  $$VisitImagesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<double> get latitude =>
      $composableBuilder(column: $table.latitude, builder: (column) => column);

  GeneratedColumn<double> get longitude =>
      $composableBuilder(column: $table.longitude, builder: (column) => column);

  GeneratedColumn<double> get accuracy =>
      $composableBuilder(column: $table.accuracy, builder: (column) => column);

  GeneratedColumn<String> get imageUrl =>
      $composableBuilder(column: $table.imageUrl, builder: (column) => column);

  GeneratedColumn<String> get imageKey =>
      $composableBuilder(column: $table.imageKey, builder: (column) => column);

  GeneratedColumn<String> get guid =>
      $composableBuilder(column: $table.guid, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => column);

  GeneratedColumn<bool> get needSync =>
      $composableBuilder(column: $table.needSync, builder: (column) => column);

  GeneratedColumn<bool> get isNew =>
      $composableBuilder(column: $table.isNew, builder: (column) => column);

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  $$VisitsTableAnnotationComposer get visitGuid {
    final $$VisitsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.visitGuid,
        referencedTable: $db.visits,
        getReferencedColumn: (t) => t.guid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$VisitsTableAnnotationComposer(
              $db: $db,
              $table: $db.visits,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$VisitImagesTableTableManager extends RootTableManager<
    _$AppDataStore,
    $VisitImagesTable,
    VisitImage,
    $$VisitImagesTableFilterComposer,
    $$VisitImagesTableOrderingComposer,
    $$VisitImagesTableAnnotationComposer,
    $$VisitImagesTableCreateCompanionBuilder,
    $$VisitImagesTableUpdateCompanionBuilder,
    (VisitImage, $$VisitImagesTableReferences),
    VisitImage,
    PrefetchHooks Function({bool visitGuid})> {
  $$VisitImagesTableTableManager(_$AppDataStore db, $VisitImagesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$VisitImagesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$VisitImagesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$VisitImagesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<double> latitude = const Value.absent(),
            Value<double> longitude = const Value.absent(),
            Value<double> accuracy = const Value.absent(),
            Value<String> imageUrl = const Value.absent(),
            Value<String> imageKey = const Value.absent(),
            Value<String> guid = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int> id = const Value.absent(),
            Value<String> visitGuid = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              VisitImagesCompanion(
            latitude: latitude,
            longitude: longitude,
            accuracy: accuracy,
            imageUrl: imageUrl,
            imageKey: imageKey,
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            visitGuid: visitGuid,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required double latitude,
            required double longitude,
            required double accuracy,
            required String imageUrl,
            required String imageKey,
            required String guid,
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            required int id,
            required String visitGuid,
            Value<int> rowid = const Value.absent(),
          }) =>
              VisitImagesCompanion.insert(
            latitude: latitude,
            longitude: longitude,
            accuracy: accuracy,
            imageUrl: imageUrl,
            imageKey: imageKey,
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            visitGuid: visitGuid,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$VisitImagesTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({visitGuid = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (visitGuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.visitGuid,
                    referencedTable:
                        $$VisitImagesTableReferences._visitGuidTable(db),
                    referencedColumn:
                        $$VisitImagesTableReferences._visitGuidTable(db).guid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$VisitImagesTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $VisitImagesTable,
    VisitImage,
    $$VisitImagesTableFilterComposer,
    $$VisitImagesTableOrderingComposer,
    $$VisitImagesTableAnnotationComposer,
    $$VisitImagesTableCreateCompanionBuilder,
    $$VisitImagesTableUpdateCompanionBuilder,
    (VisitImage, $$VisitImagesTableReferences),
    VisitImage,
    PrefetchHooks Function({bool visitGuid})>;
typedef $$VisitSoftwaresTableCreateCompanionBuilder = VisitSoftwaresCompanion
    Function({
  required double latitude,
  required double longitude,
  required double accuracy,
  required String imageUrl,
  required String imageKey,
  required String guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  required int id,
  required String visitGuid,
  Value<int> rowid,
});
typedef $$VisitSoftwaresTableUpdateCompanionBuilder = VisitSoftwaresCompanion
    Function({
  Value<double> latitude,
  Value<double> longitude,
  Value<double> accuracy,
  Value<String> imageUrl,
  Value<String> imageKey,
  Value<String> guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int> id,
  Value<String> visitGuid,
  Value<int> rowid,
});

final class $$VisitSoftwaresTableReferences extends BaseReferences<
    _$AppDataStore, $VisitSoftwaresTable, VisitSoftware> {
  $$VisitSoftwaresTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $VisitsTable _visitGuidTable(_$AppDataStore db) =>
      db.visits.createAlias(
          $_aliasNameGenerator(db.visitSoftwares.visitGuid, db.visits.guid));

  $$VisitsTableProcessedTableManager get visitGuid {
    final $_column = $_itemColumn<String>('visit_guid')!;

    final manager = $$VisitsTableTableManager($_db, $_db.visits)
        .filter((f) => f.guid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_visitGuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$VisitSoftwaresTableFilterComposer
    extends Composer<_$AppDataStore, $VisitSoftwaresTable> {
  $$VisitSoftwaresTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<double> get latitude => $composableBuilder(
      column: $table.latitude, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get longitude => $composableBuilder(
      column: $table.longitude, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get accuracy => $composableBuilder(
      column: $table.accuracy, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get imageUrl => $composableBuilder(
      column: $table.imageUrl, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get imageKey => $composableBuilder(
      column: $table.imageKey, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  $$VisitsTableFilterComposer get visitGuid {
    final $$VisitsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.visitGuid,
        referencedTable: $db.visits,
        getReferencedColumn: (t) => t.guid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$VisitsTableFilterComposer(
              $db: $db,
              $table: $db.visits,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$VisitSoftwaresTableOrderingComposer
    extends Composer<_$AppDataStore, $VisitSoftwaresTable> {
  $$VisitSoftwaresTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<double> get latitude => $composableBuilder(
      column: $table.latitude, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get longitude => $composableBuilder(
      column: $table.longitude, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get accuracy => $composableBuilder(
      column: $table.accuracy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get imageUrl => $composableBuilder(
      column: $table.imageUrl, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get imageKey => $composableBuilder(
      column: $table.imageKey, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  $$VisitsTableOrderingComposer get visitGuid {
    final $$VisitsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.visitGuid,
        referencedTable: $db.visits,
        getReferencedColumn: (t) => t.guid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$VisitsTableOrderingComposer(
              $db: $db,
              $table: $db.visits,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$VisitSoftwaresTableAnnotationComposer
    extends Composer<_$AppDataStore, $VisitSoftwaresTable> {
  $$VisitSoftwaresTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<double> get latitude =>
      $composableBuilder(column: $table.latitude, builder: (column) => column);

  GeneratedColumn<double> get longitude =>
      $composableBuilder(column: $table.longitude, builder: (column) => column);

  GeneratedColumn<double> get accuracy =>
      $composableBuilder(column: $table.accuracy, builder: (column) => column);

  GeneratedColumn<String> get imageUrl =>
      $composableBuilder(column: $table.imageUrl, builder: (column) => column);

  GeneratedColumn<String> get imageKey =>
      $composableBuilder(column: $table.imageKey, builder: (column) => column);

  GeneratedColumn<String> get guid =>
      $composableBuilder(column: $table.guid, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => column);

  GeneratedColumn<bool> get needSync =>
      $composableBuilder(column: $table.needSync, builder: (column) => column);

  GeneratedColumn<bool> get isNew =>
      $composableBuilder(column: $table.isNew, builder: (column) => column);

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  $$VisitsTableAnnotationComposer get visitGuid {
    final $$VisitsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.visitGuid,
        referencedTable: $db.visits,
        getReferencedColumn: (t) => t.guid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$VisitsTableAnnotationComposer(
              $db: $db,
              $table: $db.visits,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$VisitSoftwaresTableTableManager extends RootTableManager<
    _$AppDataStore,
    $VisitSoftwaresTable,
    VisitSoftware,
    $$VisitSoftwaresTableFilterComposer,
    $$VisitSoftwaresTableOrderingComposer,
    $$VisitSoftwaresTableAnnotationComposer,
    $$VisitSoftwaresTableCreateCompanionBuilder,
    $$VisitSoftwaresTableUpdateCompanionBuilder,
    (VisitSoftware, $$VisitSoftwaresTableReferences),
    VisitSoftware,
    PrefetchHooks Function({bool visitGuid})> {
  $$VisitSoftwaresTableTableManager(
      _$AppDataStore db, $VisitSoftwaresTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$VisitSoftwaresTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$VisitSoftwaresTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$VisitSoftwaresTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<double> latitude = const Value.absent(),
            Value<double> longitude = const Value.absent(),
            Value<double> accuracy = const Value.absent(),
            Value<String> imageUrl = const Value.absent(),
            Value<String> imageKey = const Value.absent(),
            Value<String> guid = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int> id = const Value.absent(),
            Value<String> visitGuid = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              VisitSoftwaresCompanion(
            latitude: latitude,
            longitude: longitude,
            accuracy: accuracy,
            imageUrl: imageUrl,
            imageKey: imageKey,
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            visitGuid: visitGuid,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required double latitude,
            required double longitude,
            required double accuracy,
            required String imageUrl,
            required String imageKey,
            required String guid,
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            required int id,
            required String visitGuid,
            Value<int> rowid = const Value.absent(),
          }) =>
              VisitSoftwaresCompanion.insert(
            latitude: latitude,
            longitude: longitude,
            accuracy: accuracy,
            imageUrl: imageUrl,
            imageKey: imageKey,
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            visitGuid: visitGuid,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$VisitSoftwaresTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({visitGuid = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (visitGuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.visitGuid,
                    referencedTable:
                        $$VisitSoftwaresTableReferences._visitGuidTable(db),
                    referencedColumn: $$VisitSoftwaresTableReferences
                        ._visitGuidTable(db)
                        .guid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$VisitSoftwaresTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $VisitSoftwaresTable,
    VisitSoftware,
    $$VisitSoftwaresTableFilterComposer,
    $$VisitSoftwaresTableOrderingComposer,
    $$VisitSoftwaresTableAnnotationComposer,
    $$VisitSoftwaresTableCreateCompanionBuilder,
    $$VisitSoftwaresTableUpdateCompanionBuilder,
    (VisitSoftware, $$VisitSoftwaresTableReferences),
    VisitSoftware,
    PrefetchHooks Function({bool visitGuid})>;
typedef $$VisitGoodsListsTableCreateCompanionBuilder = VisitGoodsListsCompanion
    Function({
  required String guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  required int goodsListId,
  required String visitGuid,
  Value<int> rowid,
});
typedef $$VisitGoodsListsTableUpdateCompanionBuilder = VisitGoodsListsCompanion
    Function({
  Value<String> guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  Value<int> goodsListId,
  Value<String> visitGuid,
  Value<int> rowid,
});

final class $$VisitGoodsListsTableReferences extends BaseReferences<
    _$AppDataStore, $VisitGoodsListsTable, VisitGoodsList> {
  $$VisitGoodsListsTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $VisitsTable _visitGuidTable(_$AppDataStore db) =>
      db.visits.createAlias(
          $_aliasNameGenerator(db.visitGoodsLists.visitGuid, db.visits.guid));

  $$VisitsTableProcessedTableManager get visitGuid {
    final $_column = $_itemColumn<String>('visit_guid')!;

    final manager = $$VisitsTableTableManager($_db, $_db.visits)
        .filter((f) => f.guid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_visitGuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<$AllVisitGoodsListGoodsTable,
      List<VisitGoodsListGoods>> _allVisitGoodsListGoodsRefsTable(
          _$AppDataStore db) =>
      MultiTypedResultKey.fromTable(db.allVisitGoodsListGoods,
          aliasName: $_aliasNameGenerator(db.visitGoodsLists.guid,
              db.allVisitGoodsListGoods.visitGoodsListGuid));

  $$AllVisitGoodsListGoodsTableProcessedTableManager
      get allVisitGoodsListGoodsRefs {
    final manager = $$AllVisitGoodsListGoodsTableTableManager(
            $_db, $_db.allVisitGoodsListGoods)
        .filter((f) =>
            f.visitGoodsListGuid.guid.sqlEquals($_itemColumn<String>('guid')!));

    final cache =
        $_typedResult.readTableOrNull(_allVisitGoodsListGoodsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$VisitGoodsListsTableFilterComposer
    extends Composer<_$AppDataStore, $VisitGoodsListsTable> {
  $$VisitGoodsListsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get goodsListId => $composableBuilder(
      column: $table.goodsListId, builder: (column) => ColumnFilters(column));

  $$VisitsTableFilterComposer get visitGuid {
    final $$VisitsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.visitGuid,
        referencedTable: $db.visits,
        getReferencedColumn: (t) => t.guid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$VisitsTableFilterComposer(
              $db: $db,
              $table: $db.visits,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> allVisitGoodsListGoodsRefs(
      Expression<bool> Function($$AllVisitGoodsListGoodsTableFilterComposer f)
          f) {
    final $$AllVisitGoodsListGoodsTableFilterComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.guid,
            referencedTable: $db.allVisitGoodsListGoods,
            getReferencedColumn: (t) => t.visitGoodsListGuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$AllVisitGoodsListGoodsTableFilterComposer(
                  $db: $db,
                  $table: $db.allVisitGoodsListGoods,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $$VisitGoodsListsTableOrderingComposer
    extends Composer<_$AppDataStore, $VisitGoodsListsTable> {
  $$VisitGoodsListsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get goodsListId => $composableBuilder(
      column: $table.goodsListId, builder: (column) => ColumnOrderings(column));

  $$VisitsTableOrderingComposer get visitGuid {
    final $$VisitsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.visitGuid,
        referencedTable: $db.visits,
        getReferencedColumn: (t) => t.guid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$VisitsTableOrderingComposer(
              $db: $db,
              $table: $db.visits,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$VisitGoodsListsTableAnnotationComposer
    extends Composer<_$AppDataStore, $VisitGoodsListsTable> {
  $$VisitGoodsListsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get guid =>
      $composableBuilder(column: $table.guid, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => column);

  GeneratedColumn<bool> get needSync =>
      $composableBuilder(column: $table.needSync, builder: (column) => column);

  GeneratedColumn<bool> get isNew =>
      $composableBuilder(column: $table.isNew, builder: (column) => column);

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get goodsListId => $composableBuilder(
      column: $table.goodsListId, builder: (column) => column);

  $$VisitsTableAnnotationComposer get visitGuid {
    final $$VisitsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.visitGuid,
        referencedTable: $db.visits,
        getReferencedColumn: (t) => t.guid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$VisitsTableAnnotationComposer(
              $db: $db,
              $table: $db.visits,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> allVisitGoodsListGoodsRefs<T extends Object>(
      Expression<T> Function($$AllVisitGoodsListGoodsTableAnnotationComposer a)
          f) {
    final $$AllVisitGoodsListGoodsTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.guid,
            referencedTable: $db.allVisitGoodsListGoods,
            getReferencedColumn: (t) => t.visitGoodsListGuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$AllVisitGoodsListGoodsTableAnnotationComposer(
                  $db: $db,
                  $table: $db.allVisitGoodsListGoods,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $$VisitGoodsListsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $VisitGoodsListsTable,
    VisitGoodsList,
    $$VisitGoodsListsTableFilterComposer,
    $$VisitGoodsListsTableOrderingComposer,
    $$VisitGoodsListsTableAnnotationComposer,
    $$VisitGoodsListsTableCreateCompanionBuilder,
    $$VisitGoodsListsTableUpdateCompanionBuilder,
    (VisitGoodsList, $$VisitGoodsListsTableReferences),
    VisitGoodsList,
    PrefetchHooks Function({bool visitGuid, bool allVisitGoodsListGoodsRefs})> {
  $$VisitGoodsListsTableTableManager(
      _$AppDataStore db, $VisitGoodsListsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$VisitGoodsListsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$VisitGoodsListsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$VisitGoodsListsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> guid = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            Value<int> goodsListId = const Value.absent(),
            Value<String> visitGuid = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              VisitGoodsListsCompanion(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            goodsListId: goodsListId,
            visitGuid: visitGuid,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String guid,
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            required int goodsListId,
            required String visitGuid,
            Value<int> rowid = const Value.absent(),
          }) =>
              VisitGoodsListsCompanion.insert(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            goodsListId: goodsListId,
            visitGuid: visitGuid,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$VisitGoodsListsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {visitGuid = false, allVisitGoodsListGoodsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (allVisitGoodsListGoodsRefs) db.allVisitGoodsListGoods
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (visitGuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.visitGuid,
                    referencedTable:
                        $$VisitGoodsListsTableReferences._visitGuidTable(db),
                    referencedColumn: $$VisitGoodsListsTableReferences
                        ._visitGuidTable(db)
                        .guid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (allVisitGoodsListGoodsRefs)
                    await $_getPrefetchedData(
                        currentTable: table,
                        referencedTable: $$VisitGoodsListsTableReferences
                            ._allVisitGoodsListGoodsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$VisitGoodsListsTableReferences(db, table, p0)
                                .allVisitGoodsListGoodsRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems.where(
                                (e) => e.visitGoodsListGuid == item.guid),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$VisitGoodsListsTableProcessedTableManager = ProcessedTableManager<
    _$AppDataStore,
    $VisitGoodsListsTable,
    VisitGoodsList,
    $$VisitGoodsListsTableFilterComposer,
    $$VisitGoodsListsTableOrderingComposer,
    $$VisitGoodsListsTableAnnotationComposer,
    $$VisitGoodsListsTableCreateCompanionBuilder,
    $$VisitGoodsListsTableUpdateCompanionBuilder,
    (VisitGoodsList, $$VisitGoodsListsTableReferences),
    VisitGoodsList,
    PrefetchHooks Function({bool visitGuid, bool allVisitGoodsListGoodsRefs})>;
typedef $$AllVisitGoodsListGoodsTableCreateCompanionBuilder
    = AllVisitGoodsListGoodsCompanion Function({
  required String guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  required int goodsId,
  required String visitGoodsListGuid,
  Value<int> rowid,
});
typedef $$AllVisitGoodsListGoodsTableUpdateCompanionBuilder
    = AllVisitGoodsListGoodsCompanion Function({
  Value<String> guid,
  Value<bool> isDeleted,
  Value<DateTime> timestamp,
  Value<DateTime> currentTimestamp,
  Value<DateTime?> lastSyncTime,
  Value<int?> id,
  Value<int> goodsId,
  Value<String> visitGoodsListGuid,
  Value<int> rowid,
});

final class $$AllVisitGoodsListGoodsTableReferences extends BaseReferences<
    _$AppDataStore, $AllVisitGoodsListGoodsTable, VisitGoodsListGoods> {
  $$AllVisitGoodsListGoodsTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $VisitGoodsListsTable _visitGoodsListGuidTable(_$AppDataStore db) =>
      db.visitGoodsLists.createAlias($_aliasNameGenerator(
          db.allVisitGoodsListGoods.visitGoodsListGuid,
          db.visitGoodsLists.guid));

  $$VisitGoodsListsTableProcessedTableManager get visitGoodsListGuid {
    final $_column = $_itemColumn<String>('visit_goods_list_guid')!;

    final manager =
        $$VisitGoodsListsTableTableManager($_db, $_db.visitGoodsLists)
            .filter((f) => f.guid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_visitGoodsListGuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$AllVisitGoodsListGoodsTableFilterComposer
    extends Composer<_$AppDataStore, $AllVisitGoodsListGoodsTable> {
  $$AllVisitGoodsListGoodsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnFilters(column));

  $$VisitGoodsListsTableFilterComposer get visitGoodsListGuid {
    final $$VisitGoodsListsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.visitGoodsListGuid,
        referencedTable: $db.visitGoodsLists,
        getReferencedColumn: (t) => t.guid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$VisitGoodsListsTableFilterComposer(
              $db: $db,
              $table: $db.visitGoodsLists,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$AllVisitGoodsListGoodsTableOrderingComposer
    extends Composer<_$AppDataStore, $AllVisitGoodsListGoodsTable> {
  $$AllVisitGoodsListGoodsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get guid => $composableBuilder(
      column: $table.guid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get needSync => $composableBuilder(
      column: $table.needSync, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isNew => $composableBuilder(
      column: $table.isNew, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get goodsId => $composableBuilder(
      column: $table.goodsId, builder: (column) => ColumnOrderings(column));

  $$VisitGoodsListsTableOrderingComposer get visitGoodsListGuid {
    final $$VisitGoodsListsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.visitGoodsListGuid,
        referencedTable: $db.visitGoodsLists,
        getReferencedColumn: (t) => t.guid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$VisitGoodsListsTableOrderingComposer(
              $db: $db,
              $table: $db.visitGoodsLists,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$AllVisitGoodsListGoodsTableAnnotationComposer
    extends Composer<_$AppDataStore, $AllVisitGoodsListGoodsTable> {
  $$AllVisitGoodsListGoodsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get guid =>
      $composableBuilder(column: $table.guid, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get currentTimestamp => $composableBuilder(
      column: $table.currentTimestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncTime => $composableBuilder(
      column: $table.lastSyncTime, builder: (column) => column);

  GeneratedColumn<bool> get needSync =>
      $composableBuilder(column: $table.needSync, builder: (column) => column);

  GeneratedColumn<bool> get isNew =>
      $composableBuilder(column: $table.isNew, builder: (column) => column);

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get goodsId =>
      $composableBuilder(column: $table.goodsId, builder: (column) => column);

  $$VisitGoodsListsTableAnnotationComposer get visitGoodsListGuid {
    final $$VisitGoodsListsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.visitGoodsListGuid,
        referencedTable: $db.visitGoodsLists,
        getReferencedColumn: (t) => t.guid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$VisitGoodsListsTableAnnotationComposer(
              $db: $db,
              $table: $db.visitGoodsLists,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$AllVisitGoodsListGoodsTableTableManager extends RootTableManager<
    _$AppDataStore,
    $AllVisitGoodsListGoodsTable,
    VisitGoodsListGoods,
    $$AllVisitGoodsListGoodsTableFilterComposer,
    $$AllVisitGoodsListGoodsTableOrderingComposer,
    $$AllVisitGoodsListGoodsTableAnnotationComposer,
    $$AllVisitGoodsListGoodsTableCreateCompanionBuilder,
    $$AllVisitGoodsListGoodsTableUpdateCompanionBuilder,
    (VisitGoodsListGoods, $$AllVisitGoodsListGoodsTableReferences),
    VisitGoodsListGoods,
    PrefetchHooks Function({bool visitGoodsListGuid})> {
  $$AllVisitGoodsListGoodsTableTableManager(
      _$AppDataStore db, $AllVisitGoodsListGoodsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AllVisitGoodsListGoodsTableFilterComposer(
                  $db: db, $table: table),
          createOrderingComposer: () =>
              $$AllVisitGoodsListGoodsTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AllVisitGoodsListGoodsTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> guid = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            Value<int> goodsId = const Value.absent(),
            Value<String> visitGoodsListGuid = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              AllVisitGoodsListGoodsCompanion(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            goodsId: goodsId,
            visitGoodsListGuid: visitGoodsListGuid,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String guid,
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<DateTime> currentTimestamp = const Value.absent(),
            Value<DateTime?> lastSyncTime = const Value.absent(),
            Value<int?> id = const Value.absent(),
            required int goodsId,
            required String visitGoodsListGuid,
            Value<int> rowid = const Value.absent(),
          }) =>
              AllVisitGoodsListGoodsCompanion.insert(
            guid: guid,
            isDeleted: isDeleted,
            timestamp: timestamp,
            currentTimestamp: currentTimestamp,
            lastSyncTime: lastSyncTime,
            id: id,
            goodsId: goodsId,
            visitGoodsListGuid: visitGoodsListGuid,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$AllVisitGoodsListGoodsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({visitGoodsListGuid = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (visitGoodsListGuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.visitGoodsListGuid,
                    referencedTable: $$AllVisitGoodsListGoodsTableReferences
                        ._visitGoodsListGuidTable(db),
                    referencedColumn: $$AllVisitGoodsListGoodsTableReferences
                        ._visitGoodsListGuidTable(db)
                        .guid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$AllVisitGoodsListGoodsTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDataStore,
        $AllVisitGoodsListGoodsTable,
        VisitGoodsListGoods,
        $$AllVisitGoodsListGoodsTableFilterComposer,
        $$AllVisitGoodsListGoodsTableOrderingComposer,
        $$AllVisitGoodsListGoodsTableAnnotationComposer,
        $$AllVisitGoodsListGoodsTableCreateCompanionBuilder,
        $$AllVisitGoodsListGoodsTableUpdateCompanionBuilder,
        (VisitGoodsListGoods, $$AllVisitGoodsListGoodsTableReferences),
        VisitGoodsListGoods,
        PrefetchHooks Function({bool visitGoodsListGuid})>;

class $AppDataStoreManager {
  final _$AppDataStore _db;
  $AppDataStoreManager(this._db);
  $$UsersTableTableManager get users =>
      $$UsersTableTableManager(_db, _db.users);
  $$PrefsTableTableManager get prefs =>
      $$PrefsTableTableManager(_db, _db.prefs);
  $$BuyersTableTableManager get buyers =>
      $$BuyersTableTableManager(_db, _db.buyers);
  $$PartnersTableTableManager get partners =>
      $$PartnersTableTableManager(_db, _db.partners);
  $$LocationsTableTableManager get locations =>
      $$LocationsTableTableManager(_db, _db.locations);
  $$PointFormatsTableTableManager get pointFormats =>
      $$PointFormatsTableTableManager(_db, _db.pointFormats);
  $$PointsTableTableManager get points =>
      $$PointsTableTableManager(_db, _db.points);
  $$PointImagesTableTableManager get pointImages =>
      $$PointImagesTableTableManager(_db, _db.pointImages);
  $$PreEncashmentsTableTableManager get preEncashments =>
      $$PreEncashmentsTableTableManager(_db, _db.preEncashments);
  $$DebtsTableTableManager get debts =>
      $$DebtsTableTableManager(_db, _db.debts);
  $$DepositsTableTableManager get deposits =>
      $$DepositsTableTableManager(_db, _db.deposits);
  $$ShipmentsTableTableManager get shipments =>
      $$ShipmentsTableTableManager(_db, _db.shipments);
  $$ShipmentLinesTableTableManager get shipmentLines =>
      $$ShipmentLinesTableTableManager(_db, _db.shipmentLines);
  $$IncRequestsTableTableManager get incRequests =>
      $$IncRequestsTableTableManager(_db, _db.incRequests);
  $$AllGoodsTableTableManager get allGoods =>
      $$AllGoodsTableTableManager(_db, _db.allGoods);
  $$WorkdatesTableTableManager get workdates =>
      $$WorkdatesTableTableManager(_db, _db.workdates);
  $$ShopDepartmentsTableTableManager get shopDepartments =>
      $$ShopDepartmentsTableTableManager(_db, _db.shopDepartments);
  $$CategoriesTableTableManager get categories =>
      $$CategoriesTableTableManager(_db, _db.categories);
  $$GoodsFiltersTableTableManager get goodsFilters =>
      $$GoodsFiltersTableTableManager(_db, _db.goodsFilters);
  $$OrdersTableTableManager get orders =>
      $$OrdersTableTableManager(_db, _db.orders);
  $$OrderLinesTableTableManager get orderLines =>
      $$OrderLinesTableTableManager(_db, _db.orderLines);
  $$PreOrdersTableTableManager get preOrders =>
      $$PreOrdersTableTableManager(_db, _db.preOrders);
  $$PreOrderLinesTableTableManager get preOrderLines =>
      $$PreOrderLinesTableTableManager(_db, _db.preOrderLines);
  $$SeenPreOrdersTableTableManager get seenPreOrders =>
      $$SeenPreOrdersTableTableManager(_db, _db.seenPreOrders);
  $$BonusProgramGroupsTableTableManager get bonusProgramGroups =>
      $$BonusProgramGroupsTableTableManager(_db, _db.bonusProgramGroups);
  $$BonusProgramsTableTableManager get bonusPrograms =>
      $$BonusProgramsTableTableManager(_db, _db.bonusPrograms);
  $$BuyersSetsTableTableManager get buyersSets =>
      $$BuyersSetsTableTableManager(_db, _db.buyersSets);
  $$BuyersSetsBonusProgramsTableTableManager get buyersSetsBonusPrograms =>
      $$BuyersSetsBonusProgramsTableTableManager(
          _db, _db.buyersSetsBonusPrograms);
  $$BuyersSetsBuyersTableTableManager get buyersSetsBuyers =>
      $$BuyersSetsBuyersTableTableManager(_db, _db.buyersSetsBuyers);
  $$GoodsBonusProgramsTableTableManager get goodsBonusPrograms =>
      $$GoodsBonusProgramsTableTableManager(_db, _db.goodsBonusPrograms);
  $$GoodsBonusProgramPricesTableTableManager get goodsBonusProgramPrices =>
      $$GoodsBonusProgramPricesTableTableManager(
          _db, _db.goodsBonusProgramPrices);
  $$PricelistsTableTableManager get pricelists =>
      $$PricelistsTableTableManager(_db, _db.pricelists);
  $$PricelistSetCategoriesTableTableManager get pricelistSetCategories =>
      $$PricelistSetCategoriesTableTableManager(
          _db, _db.pricelistSetCategories);
  $$PartnersPricesTableTableManager get partnersPrices =>
      $$PartnersPricesTableTableManager(_db, _db.partnersPrices);
  $$PricelistPricesTableTableManager get pricelistPrices =>
      $$PricelistPricesTableTableManager(_db, _db.pricelistPrices);
  $$PartnersPricelistsTableTableManager get partnersPricelists =>
      $$PartnersPricelistsTableTableManager(_db, _db.partnersPricelists);
  $$GoodsRestrictionsTableTableManager get goodsRestrictions =>
      $$GoodsRestrictionsTableTableManager(_db, _db.goodsRestrictions);
  $$GoodsStocksTableTableManager get goodsStocks =>
      $$GoodsStocksTableTableManager(_db, _db.goodsStocks);
  $$GoodsPartnersPricelistsTableTableManager get goodsPartnersPricelists =>
      $$GoodsPartnersPricelistsTableTableManager(
          _db, _db.goodsPartnersPricelists);
  $$GoodsReturnStocksTableTableManager get goodsReturnStocks =>
      $$GoodsReturnStocksTableTableManager(_db, _db.goodsReturnStocks);
  $$ReturnActsTableTableManager get returnActs =>
      $$ReturnActsTableTableManager(_db, _db.returnActs);
  $$ReturnActLinesTableTableManager get returnActLines =>
      $$ReturnActLinesTableTableManager(_db, _db.returnActLines);
  $$ReturnActTypesTableTableManager get returnActTypes =>
      $$ReturnActTypesTableTableManager(_db, _db.returnActTypes);
  $$PartnersReturnActTypesTableTableManager get partnersReturnActTypes =>
      $$PartnersReturnActTypesTableTableManager(
          _db, _db.partnersReturnActTypes);
  $$RoutePointsTableTableManager get routePoints =>
      $$RoutePointsTableTableManager(_db, _db.routePoints);
  $$VisitSkipReasonsTableTableManager get visitSkipReasons =>
      $$VisitSkipReasonsTableTableManager(_db, _db.visitSkipReasons);
  $$VisitsTableTableManager get visits =>
      $$VisitsTableTableManager(_db, _db.visits);
  $$SitesTableTableManager get sites =>
      $$SitesTableTableManager(_db, _db.sites);
  $$NtDeptTypesTableTableManager get ntDeptTypes =>
      $$NtDeptTypesTableTableManager(_db, _db.ntDeptTypes);
  $$GoodsListsTableTableManager get goodsLists =>
      $$GoodsListsTableTableManager(_db, _db.goodsLists);
  $$AllGoodsListGoodsTableTableManager get allGoodsListGoods =>
      $$AllGoodsListGoodsTableTableManager(_db, _db.allGoodsListGoods);
  $$VisitImagesTableTableManager get visitImages =>
      $$VisitImagesTableTableManager(_db, _db.visitImages);
  $$VisitSoftwaresTableTableManager get visitSoftwares =>
      $$VisitSoftwaresTableTableManager(_db, _db.visitSoftwares);
  $$VisitGoodsListsTableTableManager get visitGoodsLists =>
      $$VisitGoodsListsTableTableManager(_db, _db.visitGoodsLists);
  $$AllVisitGoodsListGoodsTableTableManager get allVisitGoodsListGoods =>
      $$AllVisitGoodsListGoodsTableTableManager(
          _db, _db.allVisitGoodsListGoods);
}

class AppInfoResult {
  final bool showLocalImage;
  final bool showWithPrice;
  final DateTime? lastLoadTime;
  final int pointsToSync;
  final int ordersToSync;
  final int returnActsToSync;
  final int preEncashmentsToSync;
  final int incRequestsToSync;
  final int partnerPricesToSync;
  final int partnersPricelistsToSync;
  final int routePointsTotal;
  final int pointsTotal;
  final int preEncashmentsTotal;
  final int shipmentsTotal;
  final int ordersTotal;
  final int preOrdersTotal;
  final int returnActsTotal;
  AppInfoResult({
    required this.showLocalImage,
    required this.showWithPrice,
    this.lastLoadTime,
    required this.pointsToSync,
    required this.ordersToSync,
    required this.returnActsToSync,
    required this.preEncashmentsToSync,
    required this.incRequestsToSync,
    required this.partnerPricesToSync,
    required this.partnersPricelistsToSync,
    required this.routePointsTotal,
    required this.pointsTotal,
    required this.preEncashmentsTotal,
    required this.shipmentsTotal,
    required this.ordersTotal,
    required this.preOrdersTotal,
    required this.returnActsTotal,
  });
}

mixin _$BonusProgramsDaoMixin on DatabaseAccessor<AppDataStore> {
  $AllGoodsTable get allGoods => attachedDatabase.allGoods;
  $BonusProgramGroupsTable get bonusProgramGroups =>
      attachedDatabase.bonusProgramGroups;
  $BonusProgramsTable get bonusPrograms => attachedDatabase.bonusPrograms;
  $BuyersSetsTable get buyersSets => attachedDatabase.buyersSets;
  $BuyersSetsBonusProgramsTable get buyersSetsBonusPrograms =>
      attachedDatabase.buyersSetsBonusPrograms;
  $BuyersSetsBuyersTable get buyersSetsBuyers =>
      attachedDatabase.buyersSetsBuyers;
  $GoodsBonusProgramsTable get goodsBonusPrograms =>
      attachedDatabase.goodsBonusPrograms;
  $GoodsBonusProgramPricesTable get goodsBonusProgramPrices =>
      attachedDatabase.goodsBonusProgramPrices;
  Selectable<FilteredBonusProgramsResult> filteredBonusPrograms(
      int buyerId,
      String? bonusProgramGroupId,
      String? goodsId,
      String? categoryId,
      DateTime date) {
    return customSelect(
        'SELECT DISTINCT bonus_programs.id, bonus_programs.name, bonus_programs.condition, bonus_programs.present FROM bonus_programs JOIN buyers_sets_bonus_programs ON buyers_sets_bonus_programs.bonus_program_id = bonus_programs.id JOIN buyers_sets_buyers ON buyers_sets_buyers.buyers_set_id = buyers_sets_bonus_programs.buyers_set_id JOIN buyers_sets ON buyers_sets.id = buyers_sets_buyers.buyers_set_id JOIN goods_bonus_programs ON goods_bonus_programs.bonus_program_id = bonus_programs.id JOIN goods ON goods.id = goods_bonus_programs.goods_id WHERE buyers_sets_buyers.buyer_id = ?1 AND(?2 = bonus_programs.bonus_program_group_id OR ?2 IS NULL)AND(?3 = goods_bonus_programs.goods_id OR ?3 IS NULL)AND(?4 = goods.category_id OR ?4 IS NULL)AND ?5 BETWEEN bonus_programs.date_from AND bonus_programs.date_to ORDER BY bonus_programs.name',
        variables: [
          Variable<int>(buyerId),
          Variable<String>(bonusProgramGroupId),
          Variable<String>(goodsId),
          Variable<String>(categoryId),
          Variable<DateTime>(date)
        ],
        readsFrom: {
          bonusPrograms,
          buyersSetsBonusPrograms,
          buyersSetsBuyers,
          buyersSets,
          goodsBonusPrograms,
          allGoods,
        }).map((QueryRow row) => FilteredBonusProgramsResult(
          id: row.read<int>('id'),
          name: row.read<String>('name'),
          condition: row.read<String>('condition'),
          present: row.read<String>('present'),
        ));
  }

  Selectable<FilteredGoodsBonusProgramsResult> filteredGoodsBonusPrograms(
      List<int> goodsIds, int buyerId, DateTime date) {
    var $arrayStartIndex = 3;
    final expandedgoodsIds = $expandVar($arrayStartIndex, goodsIds.length);
    $arrayStartIndex += goodsIds.length;
    return customSelect(
        'SELECT CAST(COALESCE(MAX(CASE WHEN bonus_programs.discount > 0 THEN bonus_programs.conditional_discount ELSE 0 END), 0) AS INT) AS conditional_discount, (SELECT MAX(goods_bonus_program_prices.price) FROM goods_bonus_program_prices WHERE goods_bonus_program_prices.bonus_program_id = bonus_programs.id AND goods_bonus_program_prices.goods_id = goods_bonus_programs.goods_id) AS goods_price, MAX(bonus_programs.discount) AS discount, MAX(bonus_programs.coef) AS coef, bonus_programs.tag_text, goods_bonus_programs.goods_id FROM bonus_programs JOIN goods_bonus_programs ON goods_bonus_programs.bonus_program_id = bonus_programs.id WHERE goods_bonus_programs.goods_id IN ($expandedgoodsIds) AND goods_bonus_programs.bonus_program_id IN (SELECT DISTINCT bonus_programs.id FROM bonus_programs JOIN buyers_sets_bonus_programs ON buyers_sets_bonus_programs.bonus_program_id = bonus_programs.id JOIN buyers_sets_buyers ON buyers_sets_buyers.buyers_set_id = buyers_sets_bonus_programs.buyers_set_id JOIN buyers_sets ON buyers_sets.id = buyers_sets_buyers.buyers_set_id WHERE buyers_sets_buyers.buyer_id = ?1 AND ?2 BETWEEN bonus_programs.date_from AND bonus_programs.date_to) GROUP BY goods_bonus_programs.bonus_program_id, goods_bonus_programs.goods_id, bonus_programs.tag_text',
        variables: [
          Variable<int>(buyerId),
          Variable<DateTime>(date),
          for (var $ in goodsIds) Variable<int>($)
        ],
        readsFrom: {
          bonusPrograms,
          goodsBonusProgramPrices,
          goodsBonusPrograms,
          buyersSetsBonusPrograms,
          buyersSetsBuyers,
          buyersSets,
        }).map((QueryRow row) => FilteredGoodsBonusProgramsResult(
          conditionalDiscount: row.read<bool>('conditional_discount'),
          goodsPrice: row.readNullable<double>('goods_price'),
          discount: row.readNullable<double>('discount'),
          coef: row.readNullable<double>('coef'),
          tagText: row.read<String>('tag_text'),
          goodsId: row.read<int>('goods_id'),
        ));
  }
}

class FilteredBonusProgramsResult {
  final int id;
  final String name;
  final String condition;
  final String present;
  FilteredBonusProgramsResult({
    required this.id,
    required this.name,
    required this.condition,
    required this.present,
  });
}

class FilteredGoodsBonusProgramsResult {
  final bool conditionalDiscount;
  final double? goodsPrice;
  final double? discount;
  final double? coef;
  final String tagText;
  final int goodsId;
  FilteredGoodsBonusProgramsResult({
    required this.conditionalDiscount,
    this.goodsPrice,
    this.discount,
    this.coef,
    required this.tagText,
    required this.goodsId,
  });
}

mixin _$DebtsDaoMixin on DatabaseAccessor<AppDataStore> {
  $PartnersTable get partners => attachedDatabase.partners;
  $BuyersTable get buyers => attachedDatabase.buyers;
  $DebtsTable get debts => attachedDatabase.debts;
  $DepositsTable get deposits => attachedDatabase.deposits;
  $PreEncashmentsTable get preEncashments => attachedDatabase.preEncashments;
}
mixin _$OrdersDaoMixin on DatabaseAccessor<AppDataStore> {
  $BuyersTable get buyers => attachedDatabase.buyers;
  $AllGoodsTable get allGoods => attachedDatabase.allGoods;
  $CategoriesTable get categories => attachedDatabase.categories;
  $ShopDepartmentsTable get shopDepartments => attachedDatabase.shopDepartments;
  $GoodsFiltersTable get goodsFilters => attachedDatabase.goodsFilters;
  $ShipmentsTable get shipments => attachedDatabase.shipments;
  $ShipmentLinesTable get shipmentLines => attachedDatabase.shipmentLines;
  $GoodsBonusProgramsTable get goodsBonusPrograms =>
      attachedDatabase.goodsBonusPrograms;
  $GoodsStocksTable get goodsStocks => attachedDatabase.goodsStocks;
  $GoodsRestrictionsTable get goodsRestrictions =>
      attachedDatabase.goodsRestrictions;
  $OrdersTable get orders => attachedDatabase.orders;
  $OrderLinesTable get orderLines => attachedDatabase.orderLines;
  $PreOrdersTable get preOrders => attachedDatabase.preOrders;
  $PreOrderLinesTable get preOrderLines => attachedDatabase.preOrderLines;
  $SeenPreOrdersTable get seenPreOrders => attachedDatabase.seenPreOrders;
  Selectable<OrderExResult> orderEx() {
    return customSelect(
        'SELECT"orders"."guid" AS "nested_0.guid", "orders"."is_deleted" AS "nested_0.is_deleted", "orders"."timestamp" AS "nested_0.timestamp", "orders"."current_timestamp" AS "nested_0.current_timestamp", "orders"."last_sync_time" AS "nested_0.last_sync_time", "orders"."need_sync" AS "nested_0.need_sync", "orders"."is_new" AS "nested_0.is_new", "orders"."id" AS "nested_0.id", "orders"."date" AS "nested_0.date", "orders"."status" AS "nested_0.status", "orders"."pre_order_id" AS "nested_0.pre_order_id", "orders"."need_docs" AS "nested_0.need_docs", "orders"."need_inc" AS "nested_0.need_inc", "orders"."is_physical" AS "nested_0.is_physical", "orders"."buyer_id" AS "nested_0.buyer_id", "orders"."info" AS "nested_0.info", "orders"."need_processing" AS "nested_0.need_processing", "orders"."is_editable" AS "nested_0.is_editable","buyers"."id" AS "nested_1.id", "buyers"."name" AS "nested_1.name", "buyers"."loadto" AS "nested_1.loadto", "buyers"."partner_id" AS "nested_1.partner_id", "buyers"."site_id" AS "nested_1.site_id", "buyers"."point_id" AS "nested_1.point_id", "buyers"."weekdays" AS "nested_1.weekdays", COALESCE((SELECT SUM(order_lines.rel * order_lines.vol * order_lines.price) FROM order_lines WHERE order_lines.order_guid = orders.guid AND order_lines.is_deleted = 0), 0) AS lines_total, (SELECT COUNT(*) FROM order_lines WHERE order_guid = orders.guid AND order_lines.is_deleted = 0) AS lines_count, COALESCE((SELECT MAX(need_sync) FROM order_lines WHERE order_guid = orders.guid), 0) AS lines_need_sync FROM orders LEFT JOIN buyers ON buyers.id = orders.buyer_id ORDER BY orders.date DESC, buyers.name',
        variables: [],
        readsFrom: {
          orderLines,
          orders,
          buyers,
        }).asyncMap((QueryRow row) async => OrderExResult(
          order: await orders.mapFromRow(row, tablePrefix: 'nested_0'),
          buyer: await buyers.mapFromRowOrNull(row, tablePrefix: 'nested_1'),
          linesTotal: row.read<double>('lines_total'),
          linesCount: row.read<int>('lines_count'),
          linesNeedSync: row.read<bool>('lines_need_sync'),
        ));
  }

  Selectable<OrderLineExResult> orderLineEx(String orderGuid) {
    return customSelect(
        'SELECT"order_lines"."guid" AS "nested_0.guid", "order_lines"."is_deleted" AS "nested_0.is_deleted", "order_lines"."timestamp" AS "nested_0.timestamp", "order_lines"."current_timestamp" AS "nested_0.current_timestamp", "order_lines"."last_sync_time" AS "nested_0.last_sync_time", "order_lines"."need_sync" AS "nested_0.need_sync", "order_lines"."is_new" AS "nested_0.is_new", "order_lines"."id" AS "nested_0.id", "order_lines"."order_guid" AS "nested_0.order_guid", "order_lines"."goods_id" AS "nested_0.goods_id", "order_lines"."vol" AS "nested_0.vol", "order_lines"."price" AS "nested_0.price", "order_lines"."price_original" AS "nested_0.price_original", "order_lines"."package" AS "nested_0.package", "order_lines"."rel" AS "nested_0.rel", goods.name AS goods_name FROM order_lines JOIN goods ON goods.id = order_lines.goods_id WHERE order_lines.order_guid = ?1 ORDER BY goods.name',
        variables: [
          Variable<String>(orderGuid)
        ],
        readsFrom: {
          allGoods,
          orderLines,
        }).asyncMap((QueryRow row) async => OrderLineExResult(
          line: await orderLines.mapFromRow(row, tablePrefix: 'nested_0'),
          goodsName: row.read<String>('goods_name'),
        ));
  }

  Selectable<PreOrderExResult> preOrderEx() {
    return customSelect(
        'SELECT"pre_orders"."id" AS "nested_0.id", "pre_orders"."date" AS "nested_0.date", "pre_orders"."buyer_id" AS "nested_0.buyer_id", "pre_orders"."need_docs" AS "nested_0.need_docs", "pre_orders"."info" AS "nested_0.info","buyers"."id" AS "nested_1.id", "buyers"."name" AS "nested_1.name", "buyers"."loadto" AS "nested_1.loadto", "buyers"."partner_id" AS "nested_1.partner_id", "buyers"."site_id" AS "nested_1.site_id", "buyers"."point_id" AS "nested_1.point_id", "buyers"."weekdays" AS "nested_1.weekdays", COALESCE((SELECT SUM(pre_order_lines.rel * pre_order_lines.vol * pre_order_lines.price) FROM pre_order_lines WHERE pre_order_lines.pre_order_id = pre_orders.id), 0) AS lines_total, (SELECT COUNT(*) FROM pre_order_lines WHERE pre_order_id = pre_orders.id) AS lines_count, EXISTS (SELECT 1 AS _c0 FROM orders WHERE pre_order_id = pre_orders.id) AS has_order, EXISTS (SELECT 1 AS _c1 FROM seen_pre_orders WHERE id = pre_orders.id) AS was_seen FROM pre_orders JOIN buyers ON buyers.id = pre_orders.buyer_id ORDER BY pre_orders.date DESC, buyers.name',
        variables: [],
        readsFrom: {
          preOrderLines,
          preOrders,
          orders,
          seenPreOrders,
          buyers,
        }).asyncMap((QueryRow row) async => PreOrderExResult(
          preOrder: await preOrders.mapFromRow(row, tablePrefix: 'nested_0'),
          buyer: await buyers.mapFromRow(row, tablePrefix: 'nested_1'),
          linesTotal: row.read<double>('lines_total'),
          linesCount: row.read<int>('lines_count'),
          hasOrder: row.read<bool>('has_order'),
          wasSeen: row.read<bool>('was_seen'),
        ));
  }

  Selectable<PreOrderLineExResult> preOrderLineEx(int preOrderId) {
    return customSelect(
        'SELECT"pre_order_lines"."id" AS "nested_0.id", "pre_order_lines"."pre_order_id" AS "nested_0.pre_order_id", "pre_order_lines"."goods_id" AS "nested_0.goods_id", "pre_order_lines"."vol" AS "nested_0.vol", "pre_order_lines"."price" AS "nested_0.price", "pre_order_lines"."package" AS "nested_0.package", "pre_order_lines"."rel" AS "nested_0.rel", goods.name AS goods_name FROM pre_order_lines JOIN goods ON goods.id = pre_order_lines.goods_id WHERE pre_order_lines.pre_order_id = ?1 ORDER BY goods.name',
        variables: [
          Variable<int>(preOrderId)
        ],
        readsFrom: {
          allGoods,
          preOrderLines,
        }).asyncMap((QueryRow row) async => PreOrderLineExResult(
          line: await preOrderLines.mapFromRow(row, tablePrefix: 'nested_0'),
          goodsName: row.read<String>('goods_name'),
        ));
  }

  Selectable<GoodsExResult> goodsEx(int buyerId, List<int> goodsIds) {
    var $arrayStartIndex = 2;
    final expandedgoodsIds = $expandVar($arrayStartIndex, goodsIds.length);
    $arrayStartIndex += goodsIds.length;
    return customSelect(
        'SELECT"goods"."image_url" AS "nested_0.image_url", "goods"."image_key" AS "nested_0.image_key", "goods"."id" AS "nested_0.id", "goods"."name" AS "nested_0.name", "goods"."category_id" AS "nested_0.category_id", "goods"."manufacturer" AS "nested_0.manufacturer", "goods"."is_latest" AS "nested_0.is_latest", "goods"."is_orderable" AS "nested_0.is_orderable", "goods"."pricelist_set_id" AS "nested_0.pricelist_set_id", "goods"."cost" AS "nested_0.cost", "goods"."min_price" AS "nested_0.min_price", "goods"."extra_label" AS "nested_0.extra_label", "goods"."order_rel" AS "nested_0.order_rel", "goods"."order_package" AS "nested_0.order_package", "goods"."category_box_rel" AS "nested_0.category_box_rel", "goods"."category_block_rel" AS "nested_0.category_block_rel", "goods"."weight" AS "nested_0.weight", "goods"."volume" AS "nested_0.volume", "goods"."for_physical" AS "nested_0.for_physical", "goods"."only_with_docs" AS "nested_0.only_with_docs", "goods"."shelf_life" AS "nested_0.shelf_life", "goods"."shelf_life_type_name" AS "nested_0.shelf_life_type_name", "goods"."barcodes" AS "nested_0.barcodes","goods_stocks"."goods_id" AS "nested_1.goods_id", "goods_stocks"."site_id" AS "nested_1.site_id", "goods_stocks"."is_vollow" AS "nested_1.is_vollow", "goods_stocks"."vol" AS "nested_1.vol", "goods_stocks"."min_vol" AS "nested_1.min_vol", EXISTS (SELECT 1 AS _c0 FROM goods_restrictions WHERE goods_restrictions.goods_id = goods.id AND goods_restrictions.buyer_id = buyers.id) AS restricted, (SELECT MAX(shipments.date) FROM shipment_lines JOIN shipments ON shipments.id = shipment_lines.shipment_id WHERE shipment_lines.goods_id = goods.id AND shipments.buyer_id = buyers.id AND shipments.date < STRFTIME(\'%s\', \'now\', \'start of day\')) AS last_shipment_date FROM goods CROSS JOIN buyers LEFT JOIN goods_stocks ON goods_stocks.goods_id = goods.id AND goods_stocks.site_id = buyers.site_id WHERE buyers.id = ?1 AND goods.id IN ($expandedgoodsIds) ORDER BY goods.name',
        variables: [
          Variable<int>(buyerId),
          for (var $ in goodsIds) Variable<int>($)
        ],
        readsFrom: {
          goodsRestrictions,
          allGoods,
          buyers,
          shipments,
          shipmentLines,
          goodsStocks,
        }).asyncMap((QueryRow row) async => GoodsExResult(
          goods: await allGoods.mapFromRow(row, tablePrefix: 'nested_0'),
          stock:
              await goodsStocks.mapFromRowOrNull(row, tablePrefix: 'nested_1'),
          restricted: row.read<bool>('restricted'),
          lastShipmentDate: row.readNullable<DateTime>('last_shipment_date'),
        ));
  }

  Selectable<CategoriesExResult> categoriesEx(int buyerId) {
    return customSelect(
        'SELECT"categories"."id" AS "nested_0.id", "categories"."name" AS "nested_0.name", "categories"."ord" AS "nested_0.ord", "categories"."shop_department_id" AS "nested_0.shop_department_id", (SELECT MAX(shipments.date) FROM shipment_lines JOIN shipments ON shipments.id = shipment_lines.shipment_id JOIN goods ON shipment_lines.goods_id = goods.id WHERE categories.id = goods.category_id AND shipments.buyer_id = ?1 AND shipments.date < STRFTIME(\'%s\', \'now\', \'start of day\')) AS last_shipment_date FROM categories ORDER BY categories.name',
        variables: [
          Variable<int>(buyerId)
        ],
        readsFrom: {
          shipments,
          shipmentLines,
          allGoods,
          categories,
        }).asyncMap((QueryRow row) async => CategoriesExResult(
          category: await categories.mapFromRow(row, tablePrefix: 'nested_0'),
          lastShipmentDate: row.readNullable<DateTime>('last_shipment_date'),
        ));
  }
}

class OrderExResult {
  final Order order;
  final Buyer? buyer;
  final double linesTotal;
  final int linesCount;
  final bool linesNeedSync;
  OrderExResult({
    required this.order,
    this.buyer,
    required this.linesTotal,
    required this.linesCount,
    required this.linesNeedSync,
  });
}

class OrderLineExResult {
  final OrderLine line;
  final String goodsName;
  OrderLineExResult({
    required this.line,
    required this.goodsName,
  });
}

class PreOrderExResult {
  final PreOrder preOrder;
  final Buyer buyer;
  final double linesTotal;
  final int linesCount;
  final bool hasOrder;
  final bool wasSeen;
  PreOrderExResult({
    required this.preOrder,
    required this.buyer,
    required this.linesTotal,
    required this.linesCount,
    required this.hasOrder,
    required this.wasSeen,
  });
}

class PreOrderLineExResult {
  final PreOrderLine line;
  final String goodsName;
  PreOrderLineExResult({
    required this.line,
    required this.goodsName,
  });
}

class GoodsExResult {
  final Goods goods;
  final GoodsStock? stock;
  final bool restricted;
  final DateTime? lastShipmentDate;
  GoodsExResult({
    required this.goods,
    this.stock,
    required this.restricted,
    this.lastShipmentDate,
  });
}

class CategoriesExResult {
  final Category category;
  final DateTime? lastShipmentDate;
  CategoriesExResult({
    required this.category,
    this.lastShipmentDate,
  });
}

mixin _$PartnersDaoMixin on DatabaseAccessor<AppDataStore> {
  $BuyersTable get buyers => attachedDatabase.buyers;
  $PartnersTable get partners => attachedDatabase.partners;
  $SitesTable get sites => attachedDatabase.sites;
}
mixin _$PointsDaoMixin on DatabaseAccessor<AppDataStore> {
  $BuyersTable get buyers => attachedDatabase.buyers;
  $PointsTable get points => attachedDatabase.points;
  $PointImagesTable get pointImages => attachedDatabase.pointImages;
  $PointFormatsTable get pointFormats => attachedDatabase.pointFormats;
  $RoutePointsTable get routePoints => attachedDatabase.routePoints;
}
mixin _$PricesDaoMixin on DatabaseAccessor<AppDataStore> {
  $BuyersTable get buyers => attachedDatabase.buyers;
  $AllGoodsTable get allGoods => attachedDatabase.allGoods;
  $PricelistsTable get pricelists => attachedDatabase.pricelists;
  $PricelistSetCategoriesTable get pricelistSetCategories =>
      attachedDatabase.pricelistSetCategories;
  $PartnersPricesTable get partnersPrices => attachedDatabase.partnersPrices;
  $PricelistPricesTable get pricelistPrices => attachedDatabase.pricelistPrices;
  $PartnersPricelistsTable get partnersPricelists =>
      attachedDatabase.partnersPricelists;
  $GoodsPartnersPricelistsTable get goodsPartnersPricelists =>
      attachedDatabase.goodsPartnersPricelists;
  Selectable<GoodsPricesResult> goodsPrices(
      int buyerId, List<int> goodsIds, DateTime date) {
    var $arrayStartIndex = 3;
    final expandedgoodsIds = $expandVar($arrayStartIndex, goodsIds.length);
    $arrayStartIndex += goodsIds.length;
    return customSelect(
        'SELECT goods_id, MIN(price) AS price FROM (SELECT prices.goods_id, prices.disc * pricelist_prices.price AS price FROM (SELECT goods_partners_pricelists.goods_id, goods_partners_pricelists.pricelist_id,(100 + goods_partners_pricelists.discount)/ 100 *(1 - partners_pricelists.discount / 100.0)AS disc FROM partners_pricelists JOIN buyers ON buyers.partner_id = partners_pricelists.partner_id JOIN goods_partners_pricelists ON goods_partners_pricelists.partner_pricelist_id = partners_pricelists.pricelist_id JOIN goods ON goods.id = goods_partners_pricelists.goods_id WHERE buyers.id = ?1 AND goods_partners_pricelists.goods_id IN ($expandedgoodsIds) AND(EXISTS (SELECT 1 AS _c0 FROM pricelist_set_categories WHERE pricelist_set_categories.pricelist_set_id = partners_pricelists.pricelist_set_id AND pricelist_set_categories.category_id = goods.category_id) OR NOT EXISTS (SELECT 1 AS _c1 FROM pricelist_set_categories WHERE pricelist_set_categories.pricelist_set_id = partners_pricelists.pricelist_set_id))) AS prices JOIN pricelist_prices ON pricelist_prices.pricelist_id = prices.pricelist_id AND pricelist_prices.goods_id = prices.goods_id AND ?2 BETWEEN pricelist_prices.date_from AND pricelist_prices.date_to WHERE NOT EXISTS (SELECT 1 AS _c2 FROM partners_prices JOIN buyers ON buyers.partner_id = partners_prices.partner_id WHERE partners_prices.goods_id IN ($expandedgoodsIds) AND buyers.id = ?1 AND ?2 BETWEEN partners_prices.date_from AND partners_prices.date_to AND partners_prices.goods_id = pricelist_prices.goods_id) UNION ALL SELECT partners_prices.goods_id, partners_prices.price FROM partners_prices JOIN buyers ON buyers.partner_id = partners_prices.partner_id WHERE partners_prices.goods_id IN ($expandedgoodsIds) AND buyers.id = ?1 AND ?2 BETWEEN partners_prices.date_from AND partners_prices.date_to) GROUP BY goods_id',
        variables: [
          Variable<int>(buyerId),
          Variable<DateTime>(date),
          for (var $ in goodsIds) Variable<int>($)
        ],
        readsFrom: {
          pricelistPrices,
          goodsPartnersPricelists,
          partnersPricelists,
          buyers,
          allGoods,
          pricelistSetCategories,
          partnersPrices,
        }).map((QueryRow row) => GoodsPricesResult(
          goodsId: row.read<int>('goods_id'),
          price: row.readNullable<double>('price'),
        ));
  }

  Selectable<GoodsPricelistsResult> goodsPricelists(
      DateTime date, int goodsId) {
    return customSelect(
        'SELECT pricelists.id, pricelists.name, pricelists.permit,(100 + goods_partners_pricelists.discount)/ 100 * pricelist_prices.price AS price FROM pricelists JOIN goods_partners_pricelists ON goods_partners_pricelists.partner_pricelist_id = pricelists.id AND goods_partners_pricelists.goods_id = pricelist_prices.goods_id JOIN pricelist_prices ON goods_partners_pricelists.pricelist_id = pricelist_prices.pricelist_id WHERE ?1 BETWEEN pricelist_prices.date_from AND pricelist_prices.date_to AND goods_partners_pricelists.goods_id = ?2 ORDER BY price, pricelists.name',
        variables: [
          Variable<DateTime>(date),
          Variable<int>(goodsId)
        ],
        readsFrom: {
          pricelists,
          goodsPartnersPricelists,
          pricelistPrices,
        }).map((QueryRow row) => GoodsPricelistsResult(
          id: row.read<int>('id'),
          name: row.read<String>('name'),
          permit: row.read<bool>('permit'),
          price: row.read<double>('price'),
        ));
  }
}

class GoodsPricesResult {
  final int goodsId;
  final double? price;
  GoodsPricesResult({
    required this.goodsId,
    this.price,
  });
}

class GoodsPricelistsResult {
  final int id;
  final String name;
  final bool permit;
  final double price;
  GoodsPricelistsResult({
    required this.id,
    required this.name,
    required this.permit,
    required this.price,
  });
}

mixin _$ShipmentsDaoMixin on DatabaseAccessor<AppDataStore> {
  $BuyersTable get buyers => attachedDatabase.buyers;
  $ShipmentsTable get shipments => attachedDatabase.shipments;
  $ShipmentLinesTable get shipmentLines => attachedDatabase.shipmentLines;
  $IncRequestsTable get incRequests => attachedDatabase.incRequests;
  $AllGoodsTable get allGoods => attachedDatabase.allGoods;
  $WorkdatesTable get workdates => attachedDatabase.workdates;
  Selectable<ShipmentExResult> shipmentEx() {
    return customSelect(
        'SELECT"shipments"."id" AS "nested_0.id", "shipments"."date" AS "nested_0.date", "shipments"."ndoc" AS "nested_0.ndoc", "shipments"."info" AS "nested_0.info", "shipments"."status" AS "nested_0.status", "shipments"."debt_sum" AS "nested_0.debt_sum", "shipments"."shipment_sum" AS "nested_0.shipment_sum", "shipments"."buyer_id" AS "nested_0.buyer_id","buyers"."id" AS "nested_1.id", "buyers"."name" AS "nested_1.name", "buyers"."loadto" AS "nested_1.loadto", "buyers"."partner_id" AS "nested_1.partner_id", "buyers"."site_id" AS "nested_1.site_id", "buyers"."point_id" AS "nested_1.point_id", "buyers"."weekdays" AS "nested_1.weekdays", (SELECT COUNT(*) FROM shipment_lines WHERE shipments.id = shipment_lines.shipment_id) AS lines_count FROM shipments JOIN buyers ON buyers.id = shipments.buyer_id ORDER BY shipments.date DESC, buyers.name',
        variables: [],
        readsFrom: {
          shipmentLines,
          shipments,
          buyers,
        }).asyncMap((QueryRow row) async => ShipmentExResult(
          shipment: await shipments.mapFromRow(row, tablePrefix: 'nested_0'),
          buyer: await buyers.mapFromRow(row, tablePrefix: 'nested_1'),
          linesCount: row.read<int>('lines_count'),
        ));
  }

  Selectable<GoodsShipmentsResult> goodsShipments(int buyerId, int goodsId) {
    return customSelect(
        'SELECT shipments.date, shipment_lines.vol, shipment_lines.price FROM shipments JOIN shipment_lines ON shipment_lines.shipment_id = shipments.id WHERE shipments.buyer_id = ?1 AND shipment_lines.goods_id = ?2 ORDER BY shipments.date DESC',
        variables: [
          Variable<int>(buyerId),
          Variable<int>(goodsId)
        ],
        readsFrom: {
          shipments,
          shipmentLines,
        }).map((QueryRow row) => GoodsShipmentsResult(
          date: row.read<DateTime>('date'),
          vol: row.read<double>('vol'),
          price: row.read<double>('price'),
        ));
  }
}

class ShipmentExResult {
  final Shipment shipment;
  final Buyer buyer;
  final int linesCount;
  ShipmentExResult({
    required this.shipment,
    required this.buyer,
    required this.linesCount,
  });
}

class GoodsShipmentsResult {
  final DateTime date;
  final double vol;
  final double price;
  GoodsShipmentsResult({
    required this.date,
    required this.vol,
    required this.price,
  });
}

mixin _$ReturnActsDaoMixin on DatabaseAccessor<AppDataStore> {
  $CategoriesTable get categories => attachedDatabase.categories;
  $BuyersTable get buyers => attachedDatabase.buyers;
  $AllGoodsTable get allGoods => attachedDatabase.allGoods;
  $GoodsReturnStocksTable get goodsReturnStocks =>
      attachedDatabase.goodsReturnStocks;
  $ReturnActsTable get returnActs => attachedDatabase.returnActs;
  $ReturnActLinesTable get returnActLines => attachedDatabase.returnActLines;
  $ReturnActTypesTable get returnActTypes => attachedDatabase.returnActTypes;
  $PartnersReturnActTypesTable get partnersReturnActTypes =>
      attachedDatabase.partnersReturnActTypes;
  Selectable<ReturnActExResult> returnActEx() {
    return customSelect(
        'SELECT"return_acts"."guid" AS "nested_0.guid", "return_acts"."is_deleted" AS "nested_0.is_deleted", "return_acts"."timestamp" AS "nested_0.timestamp", "return_acts"."current_timestamp" AS "nested_0.current_timestamp", "return_acts"."last_sync_time" AS "nested_0.last_sync_time", "return_acts"."need_sync" AS "nested_0.need_sync", "return_acts"."is_new" AS "nested_0.is_new", "return_acts"."id" AS "nested_0.id", "return_acts"."date" AS "nested_0.date", "return_acts"."number" AS "nested_0.number", "return_acts"."buyer_id" AS "nested_0.buyer_id", "return_acts"."need_pickup" AS "nested_0.need_pickup", "return_acts"."return_act_type_id" AS "nested_0.return_act_type_id", "return_acts"."recept_id" AS "nested_0.recept_id", "return_acts"."recept_ndoc" AS "nested_0.recept_ndoc", "return_acts"."recept_date" AS "nested_0.recept_date", COALESCE((SELECT name FROM return_act_types WHERE return_act_types.id = return_acts.return_act_type_id), \'Не указан\') AS return_act_type_name,"buyers"."id" AS "nested_1.id", "buyers"."name" AS "nested_1.name", "buyers"."loadto" AS "nested_1.loadto", "buyers"."partner_id" AS "nested_1.partner_id", "buyers"."site_id" AS "nested_1.site_id", "buyers"."point_id" AS "nested_1.point_id", "buyers"."weekdays" AS "nested_1.weekdays", COALESCE((SELECT SUM(return_act_lines.rel * return_act_lines.vol * return_act_lines.price) FROM return_act_lines WHERE return_act_lines.return_act_guid = return_acts.guid AND return_act_lines.is_deleted = 0), 0) AS lines_total, (SELECT COUNT(*) FROM return_act_lines WHERE return_act_lines.return_act_guid = return_acts.guid AND return_act_lines.is_deleted = 0) AS lines_count, COALESCE((SELECT MAX(need_sync) FROM return_act_lines WHERE return_act_lines.return_act_guid = return_acts.guid), 0) AS lines_need_sync FROM return_acts LEFT JOIN buyers ON buyers.id = return_acts.buyer_id ORDER BY return_acts.date DESC, buyers.name',
        variables: [],
        readsFrom: {
          returnActTypes,
          returnActs,
          returnActLines,
          buyers,
        }).asyncMap((QueryRow row) async => ReturnActExResult(
          returnAct: await returnActs.mapFromRow(row, tablePrefix: 'nested_0'),
          returnActTypeName: row.read<String>('return_act_type_name'),
          buyer: await buyers.mapFromRowOrNull(row, tablePrefix: 'nested_1'),
          linesTotal: row.read<double>('lines_total'),
          linesCount: row.read<int>('lines_count'),
          linesNeedSync: row.read<bool>('lines_need_sync'),
        ));
  }

  Selectable<ReturnActLineExResult> returnActLineEx(String returnActGuid) {
    return customSelect(
        'SELECT"return_act_lines"."guid" AS "nested_0.guid", "return_act_lines"."is_deleted" AS "nested_0.is_deleted", "return_act_lines"."timestamp" AS "nested_0.timestamp", "return_act_lines"."current_timestamp" AS "nested_0.current_timestamp", "return_act_lines"."last_sync_time" AS "nested_0.last_sync_time", "return_act_lines"."need_sync" AS "nested_0.need_sync", "return_act_lines"."is_new" AS "nested_0.is_new", "return_act_lines"."id" AS "nested_0.id", "return_act_lines"."return_act_guid" AS "nested_0.return_act_guid", "return_act_lines"."goods_id" AS "nested_0.goods_id", "return_act_lines"."vol" AS "nested_0.vol", "return_act_lines"."price" AS "nested_0.price", "return_act_lines"."production_date" AS "nested_0.production_date", "return_act_lines"."is_bad" AS "nested_0.is_bad", "return_act_lines"."rel" AS "nested_0.rel", goods.name AS goods_name FROM return_act_lines JOIN goods ON goods.id = return_act_lines.goods_id WHERE return_act_lines.return_act_guid = ?1 ORDER BY goods.name',
        variables: [
          Variable<String>(returnActGuid)
        ],
        readsFrom: {
          allGoods,
          returnActLines,
        }).asyncMap((QueryRow row) async => ReturnActLineExResult(
          line: await returnActLines.mapFromRow(row, tablePrefix: 'nested_0'),
          goodsName: row.read<String>('goods_name'),
        ));
  }

  Selectable<ReceptExResult> receptEx(int buyerId, int returnActTypeId) {
    return customSelect(
        'SELECT goods_return_stocks.recept_id AS id, goods_return_stocks.recept_date AS date, goods_return_stocks.recept_ndoc AS ndoc FROM goods_return_stocks WHERE goods_return_stocks.buyer_id = ?1 AND goods_return_stocks.return_act_type_id = ?2 GROUP BY recept_id, recept_date, recept_ndoc ORDER BY recept_ndoc, recept_date DESC',
        variables: [
          Variable<int>(buyerId),
          Variable<int>(returnActTypeId)
        ],
        readsFrom: {
          goodsReturnStocks,
        }).map((QueryRow row) => ReceptExResult(
          id: row.read<int>('id'),
          date: row.read<DateTime>('date'),
          ndoc: row.read<String>('ndoc'),
        ));
  }
}

class ReturnActExResult {
  final ReturnAct returnAct;
  final String returnActTypeName;
  final Buyer? buyer;
  final double linesTotal;
  final int linesCount;
  final bool linesNeedSync;
  ReturnActExResult({
    required this.returnAct,
    required this.returnActTypeName,
    this.buyer,
    required this.linesTotal,
    required this.linesCount,
    required this.linesNeedSync,
  });
}

class ReturnActLineExResult {
  final ReturnActLine line;
  final String goodsName;
  ReturnActLineExResult({
    required this.line,
    required this.goodsName,
  });
}

class ReceptExResult {
  final int id;
  final DateTime date;
  final String ndoc;
  ReceptExResult({
    required this.id,
    required this.date,
    required this.ndoc,
  });
}

mixin _$UsersDaoMixin on DatabaseAccessor<AppDataStore> {
  $UsersTable get users => attachedDatabase.users;
}
mixin _$VisitsDaoMixin on DatabaseAccessor<AppDataStore> {
  $AllGoodsTable get allGoods => attachedDatabase.allGoods;
  $BuyersTable get buyers => attachedDatabase.buyers;
  $PartnersTable get partners => attachedDatabase.partners;
  $SitesTable get sites => attachedDatabase.sites;
  $RoutePointsTable get routePoints => attachedDatabase.routePoints;
  $VisitsTable get visits => attachedDatabase.visits;
  $VisitImagesTable get visitImages => attachedDatabase.visitImages;
  $VisitSoftwaresTable get visitSoftwares => attachedDatabase.visitSoftwares;
  $VisitGoodsListsTable get visitGoodsLists => attachedDatabase.visitGoodsLists;
  $AllVisitGoodsListGoodsTable get allVisitGoodsListGoods =>
      attachedDatabase.allVisitGoodsListGoods;
  $GoodsListsTable get goodsLists => attachedDatabase.goodsLists;
  $AllGoodsListGoodsTable get allGoodsListGoods =>
      attachedDatabase.allGoodsListGoods;
  Selectable<GoodsListVisitExResult> goodsListVisitEx(String? guid) {
    return customSelect(
        'SELECT"goods_lists"."id" AS "nested_0.id", "goods_lists"."name" AS "nested_0.name", visit_goods_lists.id IS NOT NULL AS has_visit_goods_list, goods_lists.id AS "\$n_0", visit_goods_lists.guid AS "\$n_1" FROM goods_lists LEFT JOIN visit_goods_lists ON visit_goods_lists.goods_list_id = goods_lists.id AND visit_goods_lists.visit_guid = ?1 ORDER BY goods_lists.name',
        variables: [
          Variable<String>(guid)
        ],
        readsFrom: {
          allGoods,
          allGoodsListGoods,
          goodsLists,
          visitGoodsLists,
          allVisitGoodsListGoods,
        }).asyncMap((QueryRow row) async => GoodsListVisitExResult(
          goodsList: await goodsLists.mapFromRow(row, tablePrefix: 'nested_0'),
          goods: await customSelect(
                  'SELECT goods.id, goods.name FROM goods JOIN goods_list_goods ON goods_list_goods.goods_id = goods.id WHERE goods_list_goods.goods_list_id = ?1',
                  variables: [
                Variable<int>(row.read('\$n_0'))
              ],
                  readsFrom: {
                allGoods,
                allGoodsListGoods,
                goodsLists,
              })
              .map((QueryRow row) => GoodsListVisitExGoods(
                    id: row.read<int>('id'),
                    name: row.read<String>('name'),
                  ))
              .get(),
          hasVisitGoodsList: row.read<bool>('has_visit_goods_list'),
          visitGoods: await customSelect(
                  'SELECT goods.id, goods.name FROM goods JOIN visit_goods_list_goods ON visit_goods_list_goods.goods_id = goods.id WHERE ?1 = visit_goods_list_goods.visit_goods_list_guid',
                  variables: [
                Variable<String>(row.read('\$n_1'))
              ],
                  readsFrom: {
                allGoods,
                allVisitGoodsListGoods,
                visitGoodsLists,
              })
              .map((QueryRow row) => GoodsListVisitExVisitGoods(
                    id: row.read<int>('id'),
                    name: row.read<String>('name'),
                  ))
              .get(),
        ));
  }
}

class GoodsListVisitExResult {
  final GoodsList goodsList;
  final List<GoodsListVisitExGoods> goods;
  final bool hasVisitGoodsList;
  final List<GoodsListVisitExVisitGoods> visitGoods;
  GoodsListVisitExResult({
    required this.goodsList,
    required this.goods,
    required this.hasVisitGoodsList,
    required this.visitGoods,
  });
}

class GoodsListVisitExGoods {
  final int id;
  final String name;
  GoodsListVisitExGoods({
    required this.id,
    required this.name,
  });
}

class GoodsListVisitExVisitGoods {
  final int id;
  final String name;
  GoodsListVisitExVisitGoods({
    required this.id,
    required this.name,
  });
}
